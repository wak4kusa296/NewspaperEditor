
<!DOCTYPE html>
<html lang="ja">

<head>
    <!DOCTYPE html>
    <html lang="ja">

    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <meta name="theme-color" content="#EEEEEE">
        <meta name="apple-mobile-web-app-capable" content="yes">
        <meta name="apple-mobile-web-app-status-bar-style" content="black">
        <link rel="manifest" href="manifest.webmanifest">
        <link rel="icon" type="image/png" sizes="192x192" href="icons/icon-192.png">
        <link rel="icon" type="image/png" sizes="512x512" href="icons/icon-512.png">
        <link rel="apple-touch-icon" sizes="180x180" href="icons/apple-touch-icon-180.png">
        <link rel="preconnect" href="https://fonts.googleapis.com">
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link
            href="https://fonts.googleapis.com/css2?family=BIZ+UDMincho&family=Noto+Sans+JP:wght@400;700;900&family=Noto+Serif+JP:wght@400;700;900&family=Yuji+Syuku&display=block"
            rel="stylesheet">

        <style>
            :root {
                --ui-bg: #DDDDDD;
                --panel-bg: #FFFFFF;
                --border-col: #DDDDDD;
                --primary: #333333;
                --accent: #333333;
                --masthead: #161616;
                --link-col: #333333;
                --text: #333333;
            }

            body {
                margin: 0;
                height: 100vh;
                overflow: hidden;
                display: flex;
                font-family: "Noto Sans JP", sans-serif;
                background: var(--ui-bg);
                color: var(--text);
                user-select: none;
                -webkit-user-select: none;
                touch-action: none;
            }

            /* å·¦ã‚µã‚¤ãƒ‰ãƒãƒ¼ */
            .toolbar {
                width: 50px;
                height: 100vh;
                position: sticky;
                top: 0;
                background: var(--panel-bg);
                border-right: 1px solid var(--border-col);
                display: flex;
                flex-direction: column;
                align-items: center;
                padding: 0;
                z-index: 100;
                overflow-y: auto;
                overflow-x: hidden;
            }

            .toolbar::-webkit-scrollbar {
                width: 4px;
            }

            .toolbar::-webkit-scrollbar-thumb {
                background: var(--border-col);
                border-radius: 2px;
            }

            .tool-btn {
                width: 50px;
                height: 50px;
                margin-bottom: 8px;
                border: 1px solid var(--border-col);
                background: var(--panel-bg);
                cursor: pointer;
                border-radius: 0;
                display: flex;
                flex-direction: column;
                justify-content: center;
                align-items: center;
                gap: 2px;
                font-size: 18px;
                transition: background 0.2s;
                position: relative;
                filter: grayscale(100%);
            }

            .tool-btn:hover {
                background: var(--ui-bg);
            }

            .tool-btn.active {
                background: var(--primary);
                color: #fff;
                border-color: var(--primary);
                filter: grayscale(0%);
            }

            .tool-btn.active.btn-heading {
                background: var(--accent);
                border-color: var(--accent);
            }

            .tool-btn.active.btn-masthead {
                background: var(--masthead);
                border-color: var(--masthead);
            }

            .tool-label {
                font-size: 8px;
                line-height: 1;
                font-weight: 500;
            }

            /* ãƒ¡ã‚¤ãƒ³ã‚¨ãƒªã‚¢ */
            .viewport {
                flex: 1;
                position: relative;
                overflow: hidden;
                background: var(--ui-bg);
                background-image: none;
                background-size: 20px 20px;
                cursor: default;
                touch-action: none;
            }

            .viewport.mode-create {
                cursor: crosshair;
            }

            .viewport.mode-hand {
                cursor: grab;
            }

            .viewport.mode-hand:active {
                cursor: grabbing;
            }

            /* SVGç”¨ç´™ã‚³ãƒ³ãƒ†ãƒŠ */
            #canvas-container {
                transform-origin: 0 0;
                position: absolute;
                top: 0;
                left: 0;
            }

            /* SVGç”¨ç´™ */
            #main-svg {
                background: transparent;
                display: block;
                shape-rendering: geometricPrecision;
                text-rendering: geometricPrecision;
                overflow: visible;
            }

            /* å³ã‚µã‚¤ãƒ‰ãƒãƒ¼ */
            .properties {
                width: 280px;
                background: var(--panel-bg);
                border-left: 1px solid var(--border-col);
                padding: 15px;
                box-sizing: border-box;
                overflow-y: auto;
                z-index: 100;
            }

            .prop-group {
                margin-bottom: 20px;
                border-bottom: 1px solid #eee;
                padding-bottom: 15px;
            }

            .prop-group:last-child {
                border-bottom: none;
            }

            .prop-label {
                font-size: 12px;
                font-weight: bold;
                margin-bottom: 5px;
                display: block;
                color: #555;
            }

            .prop-row {
                display: flex;
                gap: 5px;
                margin-bottom: 8px;
                align-items: center;
            }

            .prop-input,
            .prop-select,
            .prop-textarea {
                width: 100%;
                box-sizing: border-box;
                padding: 6px;
                border: 1px solid var(--border-col);
                margin-bottom: 8px;
                font-size: 14px;
                font-family: inherit;
                user-select: text;
                -webkit-user-select: text;
            }

            .prop-textarea {
                resize: vertical;
                min-height: 100px;
            }

            /* ã‚¹ãƒ©ã‚¤ãƒ€ãƒ¼ */
            input[type=range] {
                -webkit-appearance: none;
                background: transparent;
                margin: 0;
                vertical-align: middle;
                cursor: pointer;
            }

            input[type=range]:focus {
                outline: none;
            }

            input[type=range]::-webkit-slider-thumb {
                -webkit-appearance: none;
                height: 16px;
                width: 16px;
                border-radius: 50%;
                background: var(--primary);
                cursor: pointer;
                margin-top: -6px;
                border: 2px solid #fff;
            }

            input[type=range]::-webkit-slider-runnable-track {
                width: 100%;
                height: 4px;
                background: #e0e0e0;
                border-radius: 2px;
            }

            .heading-slider::-webkit-slider-thumb {
                background: var(--accent);
            }

            .masthead-slider::-webkit-slider-thumb {
                background: var(--masthead);
            }

            .btn-primary {
                width: 100%;
                padding: 8px;
                background: var(--primary);
                color: white;
                border: none;
                border-radius: 4px;
                cursor: pointer;
            }

            .btn-primary:hover {
                opacity: 0.9;
            }

            .btn-delete {
                background: #e53935;
                margin-top: 20px;
            }

            .btn-secondary {
                flex: 1;
                padding: 6px;
                background: #f0f0f0;
                color: #333;
                border: 1px solid var(--border-col);
                border-radius: 4px;
                cursor: pointer;
                font-size: 12px;
                text-align: center;
            }

            .btn-secondary:hover {
                background: #e0e0e0;
            }

            /* UIã‚¹ã‚¿ã‚¤ãƒ« */
            .selection-rect {
                fill: none;
                stroke: var(--primary);
                stroke-width: 2px;
                stroke-dasharray: 4 2;
                pointer-events: none;
                vector-effect: non-scaling-stroke;
            }

            .selection-rect.heading-select {
                stroke: var(--accent);
            }

            .selection-rect.masthead-select {
                stroke: var(--masthead);
            }

            .creation-preview-rect {
                fill: rgba(33, 150, 243, 0.2);
                stroke: var(--primary);
                stroke-width: 1px;
                stroke-dasharray: 4 2;
                pointer-events: none;
                vector-effect: non-scaling-stroke;
            }

            /* ãƒãƒ³ãƒ‰ãƒ« */
            .handle-group {
                cursor: pointer;
            }

            .resize-handle-visual {
                fill: white;
                stroke: var(--primary);
                stroke-width: 2px;
                vector-effect: non-scaling-stroke;
                pointer-events: none;
            }

            .resize-handle-hit {
                fill: #ffffff;
                fill-opacity: 0;
                cursor: pointer;
                pointer-events: all;
            }

            .handle-group:hover .resize-handle-visual {
                fill: var(--primary);
            }

            .handle-group.heading-handle .resize-handle-visual {
                stroke: var(--accent);
            }

            .handle-group.heading-handle:hover .resize-handle-visual {
                fill: var(--accent);
            }

            .handle-group.masthead-handle .resize-handle-visual {
                stroke: var(--masthead);
            }

            .handle-group.masthead-handle:hover .resize-handle-visual {
                fill: var(--masthead);
            }

            /* ãƒªãƒ³ã‚¯ãƒãƒ³ãƒ‰ãƒ« (å››è§’) */
            .link-handle-rect {
                fill: #fff;
                stroke: var(--link-col);
                stroke-width: 2px;
                cursor: pointer;
                vector-effect: non-scaling-stroke;
            }

            .link-handle-rect.connected {
                fill: var(--link-col);
            }

            .link-handle-hit {
                fill: transparent;
                cursor: pointer;
                pointer-events: all;
            }

            .link-line-preview {
                stroke: var(--link-col);
                stroke-width: 2px;
                stroke-dasharray: 4 2;
                fill: none;
                pointer-events: none;
            }

            .cursor-nw {
                cursor: nw-resize;
            }

            .cursor-ne {
                cursor: ne-resize;
            }

            .cursor-sw {
                cursor: sw-resize;
            }

            .cursor-se {
                cursor: se-resize;
            }

            .margin-guide {
                fill: none;
                stroke: #00bcd4;
                stroke-width: 1px;
                stroke-dasharray: 5 5;
                pointer-events: none;
                vector-effect: non-scaling-stroke;
            }

            /* é¸æŠãƒ¢ãƒ¼ãƒ‰ã¯é€šå¸¸ã®ã‚«ãƒ¼ã‚½ãƒ« */
            .viewport.mode-select {
                cursor: default;
            }

            text {
                user-select: none;
                pointer-events: none;
            }

            .grid-line,
            .grid-rect {
                stroke: #b3e5fc;
                stroke-width: 0.5px;
                fill: none;
                pointer-events: none;
                vector-effect: non-scaling-stroke;
            }

            .hit-rect {
                fill: #ffffff;
                fill-opacity: 0;
                cursor: move;
                pointer-events: all;
            }

            /* è‰²åˆ¶å¾¡ç”¨ã‚¯ãƒ©ã‚¹ */
            .ink-fill {
                fill: #333;
            }

            .ink-stroke {
                stroke: #333;
            }

            .paper-fill {
                fill: #fff;
            }

            .paper-stroke {
                stroke: #fff;
            }

            /* ãƒªãƒ³ã‚¯æ¥ç¶šå€™è£œï¼ˆãƒ‰ãƒ©ãƒƒã‚°é–‹å§‹æ™‚ã«æ ç·šã ã‘è¡¨ç¤ºï¼‰ */
            .link-candidate .hit-rect {
                stroke: var(--link-col);
                stroke-width: 2px;
                stroke-dasharray: 4 4;
                fill: none;
                /* å¡—ã‚Šã¤ã¶ã—ãªã— */
            }

            /* ãƒªãƒ³ã‚¯æ¥ç¶šå¯¾è±¡ï¼ˆãƒ›ãƒãƒ¼æ™‚ãƒ»å¼·èª¿ï¼‰ */
            .highlight-target .hit-rect {
                stroke: var(--link-col);
                stroke-width: 3px;
                stroke-dasharray: 4 4;
                fill: rgba(156, 39, 176, 0.2) !important;
                fill-opacity: 1 !important;
            }

            /* è‡ªç”±ãƒ†ã‚­ã‚¹ãƒˆæƒãˆä½ç½®ãƒœã‚¿ãƒ³ */
            .align-btn-group {
                display: flex;
                gap: 6px;
                flex-wrap: nowrap;
                margin-bottom: 8px;
                justify-content: space-between;
            }

            /* 3x3ã‚°ãƒªãƒƒãƒ‰é…ç½®ãƒœã‚¿ãƒ³ */
            .align-grid {
                display: grid;
                grid-template-columns: repeat(3, 1fr);
                gap: 4px;
                margin-bottom: 8px;
            }

            .align-grid-btn {
                aspect-ratio: 1;
                border: 1px solid #666;
                background: #fff;
                cursor: pointer;
                border-radius: 3px;
                padding: 0;
                min-height: 32px;
                transition: all 0.2s;
            }

            .align-grid-btn:hover {
                background: #f0f0f0;
                border-color: #333;
            }

            .align-grid-btn.active {
                background: var(--accent);
                border-color: var(--accent);
                color: #fff;
            }

            #freetext-align-cross.direction-vertical {
                flex-direction: row-reverse;
            }

            .align-btn {
                flex: 1;
                min-width: 80px;
                border: 1px solid #ddd;
                border-radius: 4px;
                background: #fff;
                padding: 8px 6px;
                font-size: 12px;
                cursor: pointer;
                display: flex;
                align-items: center;
                justify-content: center;
                gap: 4px;
                transition: 0.2s;
            }

            .align-btn span {
                line-height: 1;
            }

            .align-btn:hover {
                background: #f0f0f0;
            }

            .align-btn--active {
                background: var(--primary);
                color: #fff;
                border-color: var(--primary);
            }

            .color-toggle-row {
                display: flex;
                gap: 8px;
            }

            .color-toggle-btn {
                flex: 1;
                padding: 6px 0;
                border: 1px solid var(--border-col);
                background: #fff;
                font-size: 12px;
                cursor: pointer;
                transition: background 0.2s, border-color 0.2s;
            }

            .color-toggle-btn.active {
                background: var(--primary);
                color: #fff;
                border-color: var(--primary);
            }

            .align-btn .label-vertical,
            .align-btn .label-horizontal {
                display: none;
            }

            .align-btn-group.direction-vertical .label-vertical {
                display: inline;
            }

            .align-btn-group.direction-horizontal .label-horizontal {
                display: inline;
            }

            /* ãƒ­ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ç”»é¢ */
            #loading-screen {
                position: fixed;
                top: 0;
                left: 0;
                width: 100vw;
                height: 100vh;
                background: var(--ui-bg);
                display: flex;
                flex-direction: column;
                justify-content: center;
                align-items: center;
                z-index: 10001;
                transition: opacity 0.3s ease-out;
            }

            #loading-screen.hidden {
                opacity: 0;
                pointer-events: none;
            }

            .loading-content {
                text-align: center;
            }

            .loading-title {
                font-size: 28px;
                font-weight: 700;
                margin-bottom: 16px;
                color: var(--masthead);
                letter-spacing: 0.05em;
            }

            .loading-spinner {
                width: 60px;
                height: 60px;
                border: 4px solid var(--border-col);
                border-top: 4px solid var(--primary);
                border-radius: 50%;
                animation: spin 1s linear infinite;
                margin: 0 auto 20px;
            }

            @keyframes spin {
                0% {
                    transform: rotate(0deg);
                }

                100% {
                    transform: rotate(360deg);
                }
            }

            .loading-text {
                font-size: 16px;
                color: var(--text);
                margin-bottom: 10px;
                font-weight: 500;
            }

            .loading-subtext {
                font-size: 12px;
                color: #999;
            }

            /* ã‚ªãƒ¼ãƒˆã‚»ãƒ¼ãƒ–ã‚¤ãƒ³ã‚¸ã‚±ãƒ¼ã‚¿ãƒ¼ */
            #autosave-indicator {
                position: fixed;
                top: 10px;
                right: 10px;
                padding: 8px 12px;
                background: #333333;
                color: #FFFFFF;
                border-radius: 4px;
                font-size: 12px;
                font-weight: 500;
                display: flex;
                align-items: center;
                gap: 6px;
                z-index: 10000;
                opacity: 0;
                transition: opacity 0.3s;
                pointer-events: none;
            }

            #autosave-indicator.show {
                opacity: 1;
            }

            #autosave-indicator.error {
                background: #161616;
            }

            .autosave-icon {
                width: 14px;
                height: 14px;
                animation: rotate 1s linear infinite;
            }

            @keyframes rotate {
                from {
                    transform: rotate(0deg);
                }

                to {
                    transform: rotate(360deg);
                }
            }

            /* å³ä¸Šã®æ“ä½œãƒœã‚¿ãƒ³ã‚°ãƒ«ãƒ¼ãƒ—ï¼ˆãƒ„ãƒ¼ãƒ«ãƒãƒ¼ã®å³éš£ï¼‰ */
            .top-right-controls {
                position: fixed;
                top: 10px;
                left: 70px;
                /* ãƒ„ãƒ¼ãƒ«ãƒãƒ¼(50px) + ä½™ç™½(20px) */
                display: flex;
                gap: 8px;
                z-index: 10000;
            }

            .control-btn {
                padding: 8px 16px;
                background: var(--panel-bg);
                border: 1px solid var(--border-col);
                border-radius: 4px;
                cursor: pointer;
                font-size: 13px;
                font-weight: 500;
                transition: all 0.2s;
                display: flex;
                align-items: center;
                gap: 6px;
                user-select: none;
            }

            .control-btn:hover {
                background: var(--ui-bg);
            }

            .control-btn:disabled {
                opacity: 0.3;
                cursor: not-allowed;
            }

            .control-btn.ipad-mode-active {
                background: #4CAF50;
                color: white;
                border-color: #4CAF50;
            }

            .control-btn.ipad-mode-active:hover {
                background: #45a049;
            }
        </style>
    </head>

<body>

    <!-- ã‚ªãƒ¼ãƒˆã‚»ãƒ¼ãƒ–ã‚¤ãƒ³ã‚¸ã‚±ãƒ¼ã‚¿ãƒ¼ -->
    <div id="autosave-indicator">
        <svg class="autosave-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <path d="M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
            <path d="M9 12l2 2 4-4" />
        </svg>
        <span id="autosave-text">ä¿å­˜ä¸­...</span>
    </div>

    <div id="loading-screen">
        <div class="loading-content">
            <div class="loading-title" role="heading" aria-level="1">æ–°èåˆ¶ä½œãƒ„ãƒ¼ãƒ«</div>
            <div class="loading-spinner"></div>
            <div class="loading-text">èª­ã¿è¾¼ã¿ä¸­...</div>
            <div class="loading-subtext">ãƒ•ã‚©ãƒ³ãƒˆãƒ‡ãƒ¼ã‚¿ã‚’æº–å‚™ã—ã¦ã„ã¾ã™</div>
        </div>
    </div>

    <!-- å³ä¸Šã®æ“ä½œãƒœã‚¿ãƒ³ã‚°ãƒ«ãƒ¼ãƒ— -->
    <div class="top-right-controls">
        <button class="control-btn" id="btn-undo" title="å…ƒã«æˆ»ã™ (Ctrl+Z)" onclick="undo()">â†¶ æˆ»ã‚‹</button>
        <button class="control-btn" id="btn-redo" title="ã‚„ã‚Šç›´ã™ (Ctrl+Y)" onclick="redo()">â†· ã‚„ã‚Šç›´ã™</button>
        <button class="control-btn" id="btn-ipad-mode" title="iPadå¯¾å¿œãƒ¢ãƒ¼ãƒ‰" onclick="toggleIpadMode()">ğŸ“± iPadå¯¾å¿œ</button>
    </div>

    <div class="toolbar">
        <button class="tool-btn active" id="btn-select" title="é¸æŠ (V)" onclick="setMode('select')">â–²<span
                class="tool-label">é¸æŠ</span></button>
        <button class="tool-btn" id="btn-hand" title="ãƒãƒ³ãƒ‰ (H)" onclick="setMode('hand')">âœ‹<span
                class="tool-label">ãƒãƒ³ãƒ‰</span></button>
        <button class="tool-btn" id="btn-text" title="è¨˜äº‹ (T)" onclick="setMode('text')">T<span
                class="tool-label">è¨˜äº‹</span></button>
        <button class="tool-btn" id="btn-freetext" title="è‡ªç”±ãƒ†ã‚­ã‚¹ãƒˆ (F)" onclick="setMode('freetext')">A<span
                class="tool-label">è‡ªç”±</span></button>
        <button class="tool-btn btn-heading" id="btn-heading" title="è¦‹å‡ºã— (H)" onclick="setMode('heading')">H<span
                class="tool-label">è¦‹å‡º</span></button>
        <button class="tool-btn btn-masthead" id="btn-masthead" title="é¡Œå­— (M)" onclick="setMode('masthead')">é¡Œ<span
                class="tool-label">é¡Œå­—</span></button>
        <button class="tool-btn" id="btn-rect" title="å¡—ã‚Šã¤ã¶ã— (R)" onclick="setMode('rect')">â– <span
                class="tool-label">å¡—æ½°</span></button>
        <button class="tool-btn" id="btn-vline" title="ç¸¦ç·š (V)" onclick="setMode('vline')">|<span
                class="tool-label">ç¸¦ç·š</span></button>
        <button class="tool-btn" id="btn-image" title="ç”»åƒ (I)" onclick="setMode('image')">ğŸ–¼<span
                class="tool-label">ç”»åƒ</span></button>
        <div style="flex:1"></div>
        <button class="tool-btn" onclick="exportCanvas()" title="ç”»åƒã¨ã—ã¦æ›¸ãå‡ºã—">ğŸ“¤<span
                class="tool-label">æ›¸å‡º</span></button>
        <button class="tool-btn" onclick="newProject()" title="æ–°è¦ä½œæˆ">ğŸ“„<span class="tool-label">æ–°è¦</span></button>
        <button class="tool-btn" onclick="openProjectFile()" title="é–‹ã">ğŸ“‚<span class="tool-label">é–‹ã</span></button>
        <button class="tool-btn" onclick="saveProject()" title="ä¿å­˜">ğŸ’¾<span class="tool-label">ä¿å­˜</span></button>
        <button class="tool-btn" onclick="fitView()" title="å…¨ä½“è¡¨ç¤º">ğŸ”</button>
    </div>

    <div class="viewport" id="viewport">
        <div id="canvas-container">
            <svg id="main-svg" width="297" height="420" viewBox="0 0 297 420" xmlns="http://www.w3.org/2000/svg"
                overflow="visible">
                <defs>
                    <style id="svg-style">
                        .hit-rect {
                            fill: #ffffff;
                            fill-opacity: 0;
                            pointer-events: all;
                        }

                        .ink-fill {
                            fill: #333333;
                        }

                        .ink-stroke {
                            stroke: #333333;
                        }

                        .paper-fill {
                            fill: #ffffff;
                        }

                        .paper-stroke {
                            stroke: #ffffff;
                        }

                        text {
                            fill: #333333;
                        }
                    </style>
                </defs>
                <rect id="paper-bg" class="paper-fill" x="0" y="0" width="100%" height="100%"></rect>

                <!-- ãƒ¬ã‚¤ãƒ¤ãƒ¼é †åº: ã‚°ãƒªãƒƒãƒ‰ < æ®µé–“ç½«ç·š < ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ < UI < æ ç·š -->
                <g id="layer-paper-grid"></g>
                <g id="layer-dan-lines"></g>
                <g id="layer-content"></g>
                <g id="layer-ui"></g>
                <g id="layer-border"></g>
            </svg>
        </div>
    </div>

    <div class="properties">
        <!-- è¨­å®šãƒ‘ãƒãƒ«: æœªé¸æŠ -->
        <div class="prop-group" id="prop-panel-none">
            <div class="prop-label">ç”¨ç´™ã‚µã‚¤ã‚º (mm)</div>
            <div class="prop-row">
                <input type="number" id="inp-canvas-w" class="prop-input" value="297" onchange="updateCanvasSize()">
                <span>Ã—</span>
                <input type="number" id="inp-canvas-h" class="prop-input" value="420" onchange="updateCanvasSize()">
            </div>
            <div class="prop-row">
                <button class="btn-secondary" onclick="setCanvasPreset(210, 297)">A4</button>
                <button class="btn-secondary" onclick="setCanvasPreset(297, 420)">A3</button>
                <button class="btn-secondary" onclick="swapCanvasSize()">ç¸¦æ¨ªå…¥æ›¿</button>
            </div>

            <div class="prop-label" style="margin-top:15px;">ã‚«ãƒ©ãƒ¼è¨­å®š</div>
            <div class="prop-row">
                <span style="font-size:11px; flex:1;">ç´™ã®è‰²</span>
                <input type="color" id="inp-paper-color" value="#ffffff" oninput="updateColors()" style="height:24px;">
            </div>
            <div class="prop-row">
                <span style="font-size:11px; flex:1;">ã‚¤ãƒ³ã‚¯ã®è‰²</span>
                <input type="color" id="inp-ink-color" value="#333333" oninput="updateColors()" style="height:24px;">
            </div>

            <div class="prop-label" style="margin-top:15px;">ä½™ç™½ (mm)</div>
            <div
                style="background:#f9f9f9; padding:10px; border-radius:4px; border:1px solid #eee; margin-bottom:10px;">
                <div class="prop-row">
                    <span style="font-size:11px; flex:1;">ä¸Š</span>
                    <input type="number" id="inp-margin-t" class="prop-input" style="flex:0.6" value="20"
                        oninput="updateCanvasSize()">
                </div>
                <div class="prop-row">
                    <span style="font-size:11px; flex:1;">ä¸‹</span>
                    <input type="number" id="inp-margin-b" class="prop-input" style="flex:0.6" value="20"
                        oninput="updateCanvasSize()">
                </div>
                <div class="prop-row">
                    <span style="font-size:11px; flex:1;">å·¦</span>
                    <input type="number" id="inp-margin-l" class="prop-input" style="flex:0.6" value="20"
                        oninput="updateCanvasSize()">
                </div>
                <div class="prop-row">
                    <span style="font-size:11px; flex:1;">å³</span>
                    <input type="number" id="inp-margin-r" class="prop-input" style="flex:0.6" value="20"
                        oninput="updateCanvasSize()">
                </div>
            </div>

            <div class="prop-label" style="margin-top:15px; color:#2196f3;">ç´™é¢å‰²ä»˜</div>
            <div style="background:#f9f9f9; padding:10px; border-radius:4px; border:1px solid #eee;">
                <div class="prop-row">
                    <span style="font-size:11px; flex:1;">ç¸¦ã®æ®µæ•°</span>
                    <input type="number" id="inp-layout-dan" class="prop-input" style="flex:0.6" value="6"
                        onchange="updateGridSettings()">
                </div>
                <div class="prop-row">
                    <span style="font-size:11px; flex:1;">1æ®µã®æ–‡å­—æ•°</span>
                    <input type="number" id="inp-layout-chars" class="prop-input" style="flex:0.6" value="11"
                        onchange="updateGridSettings()">
                </div>
                <div class="prop-row">
                    <span style="font-size:11px; flex:1;">å…¨ä½“ã®è¡Œæ•°</span>
                    <input type="number" id="inp-layout-lines" class="prop-input" style="flex:0.6" value="25"
                        onchange="updateGridSettings()">
                </div>
                <div class="prop-row">
                    <label style="font-size:11px; display:flex; align-items:center;">
                        <input type="checkbox" id="inp-layout-show" checked onchange="updateGridSettings()"
                            style="margin-right:5px;"> ã‚°ãƒªãƒƒãƒ‰è¡¨ç¤º
                    </label>
                </div>
                <div id="grid-info" style="font-size:10px; color:#666; margin-top:5px;"></div>
            </div>

            <div class="prop-label" style="margin-top:15px;">è¨˜äº‹ãƒœãƒƒã‚¯ã‚¹è¨­å®š</div>
            <div class="prop-row">
                <label style="font-size:11px; display:flex; align-items:center; cursor:pointer;">
                    <input type="checkbox" id="inp-snap-article" checked onchange="updateSnapMode()"
                        style="margin-right:5px;"> è¨˜äº‹é…ç½®ãƒ¢ãƒ¼ãƒ‰ (æ®µã‚¹ãƒŠãƒƒãƒ—)
                </label>
            </div>

            <div class="prop-label" style="margin-top:15px; color:#2196f3;">ãƒ˜ãƒƒãƒ€ãƒ¼ãƒ†ã‚­ã‚¹ãƒˆ</div>
            <div
                style="background:#f9f9f9; padding:10px; border-radius:4px; border:1px solid #eee; margin-bottom:15px;">
                <!-- å·¦ãƒ˜ãƒƒãƒ€ãƒ¼ -->
                <div style="margin-bottom:12px; padding-bottom:12px; border-bottom:1px solid #ddd;">
                    <div style="font-size:11px; font-weight:bold; margin-bottom:5px; color:#666;">å·¦æƒãˆ</div>
                    <input type="text" id="inp-header-left-text" class="prop-input" value="20XXå¹´ï¼ˆä»¤å’ŒXå¹´ï¼‰XXæœˆXXæ—¥"
                        placeholder="å·¦å´ã®ãƒ†ã‚­ã‚¹ãƒˆ" oninput="updateHeaderText('left')" style="margin-bottom:5px;">
                    <div class="prop-row">
                        <select id="inp-header-left-font" class="prop-select" onchange="updateHeaderFont('left')"
                            style="flex:2; margin-bottom:0;">
                            <option value='"Noto Sans JP", sans-serif' selected>Noto Sans JP</option>
                            <option value='"Noto Serif JP", serif'>Noto Serif JP</option>
                            <option value='"BIZ UDMincho", serif'>BIZ UDMincho</option>
                            <option value='"Yuji Syuku", serif'>Yuji Syuku</option>
                        </select>
                        <select id="inp-header-left-weight" class="prop-select" onchange="updateHeaderWeight('left')"
                            style="flex:1; margin-bottom:0;">
                            <option value="400">æ¨™æº–</option>
                            <option value="700" selected>å¤ªå­—</option>
                            <option value="900">æ¥µå¤ª</option>
                        </select>
                    </div>
                    <div class="prop-row">
                        <span style="font-size:10px; flex:0.6;">ã‚µã‚¤ã‚º</span>
                        <input type="number" id="inp-header-left-size" class="prop-input" value="4" min="1" max="20"
                            step="0.5" onchange="updateHeaderSize('left')" style="flex:1; margin-bottom:0;">
                        <span style="font-size:10px; flex:0.6;">å­—é–“</span>
                        <input type="number" id="inp-header-left-spacing" class="prop-input" value="0" min="-2" max="10"
                            step="0.1" onchange="updateHeaderSpacing('left')" style="flex:1; margin-bottom:0;">
                    </div>
                </div>

                <!-- ä¸­å¤®ãƒ˜ãƒƒãƒ€ãƒ¼ -->
                <div style="margin-bottom:12px; padding-bottom:12px; border-bottom:1px solid #ddd;">
                    <div style="font-size:11px; font-weight:bold; margin-bottom:5px; color:#666;">ä¸­å¤®æƒãˆ</div>
                    <input type="text" id="inp-header-center-text" class="prop-input" value="ç©ºæƒ³æ–°è" placeholder="ä¸­å¤®ã®ãƒ†ã‚­ã‚¹ãƒˆ"
                        oninput="updateHeaderText('center')" style="margin-bottom:5px;">
                    <div class="prop-row">
                        <select id="inp-header-center-font" class="prop-select" onchange="updateHeaderFont('center')"
                            style="flex:2; margin-bottom:0;">
                            <option value='"Noto Sans JP", sans-serif'>Noto Sans JP</option>
                            <option value='"Noto Serif JP", serif' selected>Noto Serif JP</option>
                            <option value='"BIZ UDMincho", serif'>BIZ UDMincho</option>
                            <option value='"Yuji Syuku", serif'>Yuji Syuku</option>
                        </select>
                        <select id="inp-header-center-weight" class="prop-select"
                            onchange="updateHeaderWeight('center')" style="flex:1; margin-bottom:0;">
                            <option value="400">æ¨™æº–</option>
                            <option value="700">å¤ªå­—</option>
                            <option value="900" selected>æ¥µå¤ª</option>
                        </select>
                    </div>
                    <div class="prop-row">
                        <span style="font-size:10px; flex:0.6;">ã‚µã‚¤ã‚º</span>
                        <input type="number" id="inp-header-center-size" class="prop-input" value="6" min="1" max="20"
                            step="0.5" onchange="updateHeaderSize('center')" style="flex:1; margin-bottom:0;">
                        <span style="font-size:10px; flex:0.6;">å­—é–“</span>
                        <input type="number" id="inp-header-center-spacing" class="prop-input" value="10" min="-2"
                            max="20" step="0.1" onchange="updateHeaderSpacing('center')"
                            style="flex:1; margin-bottom:0;">
                    </div>
                </div>

                <!-- å³ãƒ˜ãƒƒãƒ€ãƒ¼ -->
                <div>
                    <div style="font-size:11px; font-weight:bold; margin-bottom:5px; color:#666;">å³æƒãˆ</div>
                    <input type="text" id="inp-header-right-text" class="prop-input" value="â—‹â—‹ã«ã¤ã„ã¦æ·±ãçŸ¥ã‚‹ã€‚"
                        placeholder="å³å´ã®ãƒ†ã‚­ã‚¹ãƒˆ" oninput="updateHeaderText('right')" style="margin-bottom:5px;">
                    <div class="prop-row">
                        <select id="inp-header-right-font" class="prop-select" onchange="updateHeaderFont('right')"
                            style="flex:2; margin-bottom:0;">
                            <option value='"Noto Sans JP", sans-serif' selected>Noto Sans JP</option>
                            <option value='"Noto Serif JP", serif'>Noto Serif JP</option>
                            <option value='"BIZ UDMincho", serif'>BIZ UDMincho</option>
                            <option value='"Yuji Syuku", serif'>Yuji Syuku</option>
                        </select>
                        <select id="inp-header-right-weight" class="prop-select" onchange="updateHeaderWeight('right')"
                            style="flex:1; margin-bottom:0;">
                            <option value="400" selected>æ¨™æº–</option>
                            <option value="700">å¤ªå­—</option>
                            <option value="900">æ¥µå¤ª</option>
                        </select>
                    </div>
                    <div class="prop-row">
                        <span style="font-size:10px; flex:0.6;">ã‚µã‚¤ã‚º</span>
                        <input type="number" id="inp-header-right-size" class="prop-input" value="4" min="1" max="20"
                            step="0.5" onchange="updateHeaderSize('right')" style="flex:1; margin-bottom:0;">
                        <span style="font-size:10px; flex:0.6;">å­—é–“</span>
                        <input type="number" id="inp-header-right-spacing" class="prop-input" value="0" min="-2"
                            max="10" step="0.1" onchange="updateHeaderSpacing('right')"
                            style="flex:1; margin-bottom:0;">
                    </div>
                </div>
            </div>

            <div class="prop-label" style="margin-top:20px;">ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆ</div>
            <button class="btn-primary" id="btn-export" onclick="exportCanvas()">ç”»åƒã¨ã—ã¦æ›¸ãå‡ºã—</button>
        </div>

        <!-- è¨­å®šãƒ‘ãƒãƒ«: è¨˜äº‹ -->
        <div class="prop-group" id="prop-panel-text" style="display:none;">
            <div class="prop-label">è¨˜äº‹ãƒœãƒƒã‚¯ã‚¹ç·¨é›†</div>
            <textarea id="inp-text" class="prop-textarea" oninput="updateSelectedText()"></textarea>

            <div id="text-char-info" style="font-size:11px; color:#666; margin-top:5px; margin-bottom:10px;">
                ç¾åœ¨: <span id="char-current">0</span>æ–‡å­— /
                æœ€å¤§: <span id="char-capacity">0</span>æ–‡å­— /
                ã‚ãµã‚Œ: <span id="char-overflow" style="color:#f44336;">0</span>æ–‡å­—
            </div>

            <div class="prop-row">
                <label style="font-size:11px; display:flex; align-items:center; cursor:pointer; width:100%;">
                    <input type="checkbox" id="inp-snap-article-txt" checked onchange="updateSnapMode()"
                        style="margin-right:5px;"> è¨˜äº‹é…ç½®ãƒ¢ãƒ¼ãƒ‰ (æ®µã‚¹ãƒŠãƒƒãƒ—)
                </label>
            </div>

            <div class="prop-label">ãƒ•ã‚©ãƒ³ãƒˆè¨­å®š</div>
            <select id="inp-fontfamily" class="prop-select" onchange="updateSelectedStyle()">
                <option value='"BIZ UDMincho", serif'>BIZ UDMincho (BIZ UDæ˜æœ æ¨™æº–)</option>
                <option value='"Noto Serif JP", serif'>Noto Serif JP</option>
                <option value='"Noto Sans JP", sans-serif'>Noto Sans JP</option>
                <option value='"Yuji Syuku", serif'>Yuji Syuku (ä½‘å­— å®¿ ç­†æ–‡å­—)</option>
            </select>
            <div style="font-size:11px; color:#777; margin-bottom:10px;">
                è¡¨ç¤ºä¸­ã®ãƒ•ã‚©ãƒ³ãƒˆã¯ Google Fonts ã§ã®æ­£å¼åç§° (BIZ UDMincho / Yuji Syuku) ã‚’ãã®ã¾ã¾è¨˜è¼‰ã—ã¦ã„ã¾ã™ã€‚
            </div>

            <div id="text-link-info" style="font-size:11px; color:#9c27b0; margin-bottom:10px; display:none;">
                â€»ã“ã®ãƒœãƒƒã‚¯ã‚¹ã¯ãƒªãƒ³ã‚¯æ¥ç¶šã•ã‚Œã¦ã„ã¾ã™ã€‚<br>æ–‡å­—ã¯å‰ã®ãƒœãƒƒã‚¯ã‚¹ã‹ã‚‰æµã—è¾¼ã¾ã‚Œã¾ã™ã€‚
            </div>

            <button class="btn-primary btn-delete" onclick="deleteSelected()">å‰Šé™¤</button>
        </div>

        <!-- è¨­å®šãƒ‘ãƒãƒ«: è¦‹å‡ºã— -->
        <div class="prop-group" id="prop-panel-heading" style="display:none;">
            <div class="prop-label" style="color:var(--accent);">è¦‹å‡ºã—ç·¨é›†</div>
            <input type="text" id="inp-heading-text" class="prop-input" oninput="updateHeadingProp('text')">

            <div class="prop-row" style="margin-top:10px;">
                <label style="display:flex; align-items:center; font-size:12px; cursor:pointer; flex:1;">
                    <input type="checkbox" id="inp-heading-inverted" onchange="updateHeadingProp('inverted')"
                        style="margin-right:5px;"> ç™½é»’åè»¢ (åº§å¸ƒå›£)
                </label>
            </div>

            <div class="prop-label" style="margin-top:10px;">ãƒ•ã‚©ãƒ³ãƒˆè¨­å®š</div>
            <select id="inp-heading-font" class="prop-select" onchange="updateHeadingProp('fontFamily')">
                <option value='"Noto Sans JP", sans-serif'>Noto Sans JP (ã‚´ã‚·ãƒƒã‚¯)</option>
                <option value='"Noto Serif JP", serif'>Noto Serif JP (æ˜æœ)</option>
                <option value='"BIZ UDMincho", serif'>BIZ UDMincho (BIZ UDæ˜æœ)</option>
                <option value='"Yuji Syuku", serif'>Yuji Syuku (ä½‘å­— å®¿)</option>
            </select>
            <div class="prop-label">ä½™ç™½è¨­å®š (mm)</div>
            <div class="prop-row">
                <span style="font-size:11px; flex:0.8;">å·¦å³</span>
                <input type="range" id="inp-heading-ph-slider" class="heading-slider" min="0" max="50" step="0.5"
                    value="5" oninput="updateHeadingProp('padding', 'h', this.value)" style="flex:2;">
                <input type="number" id="inp-heading-ph" class="prop-input" style="flex:0.8; margin-bottom:0;" value="5"
                    onchange="updateHeadingProp('padding', 'h', this.value)">
            </div>
            <div class="prop-row">
                <span style="font-size:11px; flex:0.8;">å¤©åœ°</span>
                <input type="range" id="inp-heading-pv-slider" class="heading-slider" min="0" max="50" step="0.5"
                    value="5" oninput="updateHeadingProp('padding', 'v', this.value)" style="flex:2;">
                <input type="number" id="inp-heading-pv" class="prop-input" style="flex:0.8; margin-bottom:0;" value="5"
                    onchange="updateHeadingProp('padding', 'v', this.value)">
            </div>
            <div style="font-size:11px; color:#666; margin-top:10px;">
                â€»å·¦å³ã«è¡Œé–“åˆ†ã®ç´™è‰²ã‚·ãƒ£ãƒ‰ã‚¦ãŒã¤ãã¾ã™ã€‚<br>
                â€»æ–‡å­—ã¯å¸¸æ™‚æœ€å¤§å¤ªã•(900)ã§è¡¨ç¤ºã•ã‚Œã¾ã™ã€‚
            </div>
            <button class="btn-primary btn-delete" onclick="deleteSelected()">å‰Šé™¤</button>
        </div>

        <!-- è¨­å®šãƒ‘ãƒãƒ«: é¡Œå­— -->
        <div class="prop-group" id="prop-panel-masthead" style="display:none;">
            <div class="prop-label" style="color:var(--masthead);">é¡Œå­—ç·¨é›†</div>
            <input type="text" id="inp-masthead-text" class="prop-input" value="ç©ºæƒ³æ–°è"
                oninput="updateMastheadProp('text')">

            <div class="prop-row" style="margin-top:10px;">
                <label style="display:flex; align-items:center; font-size:12px; cursor:pointer; flex:1;">
                    <input type="checkbox" id="inp-masthead-inverted" onchange="updateMastheadProp('inverted')"
                        style="margin-right:5px;"> æ–‡å­—è‰²åè»¢ (ç™½æŠœã)
                </label>
            </div>

            <div class="prop-label" style="margin-top:10px;">ãƒ‡ã‚¶ã‚¤ãƒ³è¨­å®š (mm)</div>
            <div class="prop-row">
                <span style="font-size:11px; flex:1;">å¤–æ ã®å¤ªã•</span>
                <input type="range" id="inp-masthead-bo-slider" class="masthead-slider" min="0.5" max="5.0" step="0.1"
                    value="1.0" oninput="updateMastheadProp('borderWidthOuter', this.value)" style="flex:1.5;">
                <input type="number" id="inp-masthead-bo" class="prop-input" style="flex:0.8;" value="1.0"
                    onchange="updateMastheadProp('borderWidthOuter', this.value)">
            </div>
            <div class="prop-row">
                <span style="font-size:11px; flex:1;">å†…æ ã®å¤ªã•</span>
                <input type="range" id="inp-masthead-bi-slider" class="masthead-slider" min="0.1" max="3.0" step="0.1"
                    value="0.3" oninput="updateMastheadProp('borderWidthInner', this.value)" style="flex:1.5;">
                <input type="number" id="inp-masthead-bi" class="prop-input" style="flex:0.8;" value="0.3"
                    onchange="updateMastheadProp('borderWidthInner', this.value)">
            </div>
            <div class="prop-row">
                <span style="font-size:11px; flex:1;">åœ°ç´‹ç·šã®å¤ªã•</span>
                <input type="range" id="inp-masthead-pl-slider" class="masthead-slider" min="0.1" max="1.0" step="0.1"
                    value="0.4" oninput="updateMastheadProp('patternLineHeight', this.value)" style="flex:1.5;">
                <input type="number" id="inp-masthead-pl" class="prop-input" style="flex:0.8;" value="0.4"
                    onchange="updateMastheadProp('patternLineHeight', this.value)">
            </div>

            <div class="prop-row">
                <span style="font-size:11px; flex:1;">æ–‡å­—ç¸å–ã‚Š</span>
                <input type="range" id="inp-masthead-ts-slider" class="masthead-slider" min="0" max="4" step="0.5"
                    value="2" oninput="updateMastheadProp('textStrokeWidth', this.value)" style="flex:1.5;">
                <input type="number" id="inp-masthead-ts" class="prop-input" style="flex:0.8;" min="0" max="4"
                    step="0.5" value="2" onchange="updateMastheadProp('textStrokeWidth', this.value)">
            </div>

            <div class="prop-label">ä½™ç™½è¨­å®š (mm)</div>
            <div class="prop-row">
                <span style="font-size:11px; flex:0.8;">å·¦å³</span>
                <input type="range" id="inp-masthead-ph-slider" class="masthead-slider" min="0" max="50" step="0.5"
                    value="0" oninput="updateMastheadProp('paddingH', this.value)" style="flex:2;">
                <input type="number" id="inp-masthead-ph" class="prop-input" style="flex:0.8; margin-bottom:0;"
                    value="0" onchange="updateMastheadProp('paddingH', this.value)">
            </div>
            <div class="prop-row">
                <span style="font-size:11px; flex:0.8;">å¤©åœ°</span>
                <input type="range" id="inp-masthead-pv-slider" class="masthead-slider" min="0" max="50" step="0.5"
                    value="0" oninput="updateMastheadProp('paddingV', this.value)" style="flex:2;">
                <input type="number" id="inp-masthead-pv" class="prop-input" style="flex:0.8; margin-bottom:0;"
                    value="0" onchange="updateMastheadProp('paddingV', this.value)">
            </div>

            <div class="prop-label">ãƒ•ã‚©ãƒ³ãƒˆè¨­å®š</div>
            <select id="inp-masthead-font" class="prop-select" onchange="updateMastheadProp('fontFamily')">
                <option value='"BIZ UDMincho", serif'>BIZ UDMincho (BIZ UDæ˜æœ æ¨™æº–)</option>
                <option value='"Noto Serif JP", serif'>Noto Serif JP (æ˜æœ)</option>
                <option value='"Yuji Syuku", serif'>Yuji Syuku (ä½‘å­— å®¿ ç­†æ–‡å­—)</option>
                <option value='"Noto Sans JP", sans-serif'>Noto Sans JP (ã‚´ã‚·ãƒƒã‚¯)</option>
            </select>

            <button class="btn-primary btn-delete" onclick="deleteSelected()">å‰Šé™¤</button>
        </div>

        <!-- è¨­å®šãƒ‘ãƒãƒ«: å¡—ã‚Šã¤ã¶ã— -->
        <div class="prop-group" id="prop-panel-rect" style="display:none;">
            <div class="prop-label">å¡—ã‚Šã¤ã¶ã—è¨­å®š</div>
            <div class="prop-row">
                <label style="display:flex; align-items:center; font-size:12px; cursor:pointer; flex:1;">
                    <input type="checkbox" id="inp-rect-ink" onchange="updateRectProp()"> ã‚¤ãƒ³ã‚¯è‰²ã§å¡—ã‚Šã¤ã¶ã™
                </label>
            </div>
            <div style="font-size:11px; color:#666; margin-bottom:10px;">
                â€»OFFã®å ´åˆã¯ç´™è‰²ã§å¡—ã‚Šã¤ã¶ã•ã‚Œã¾ã™ã€‚
            </div>

            <div class="prop-label">æ ç·šè¨­å®š</div>
            <select id="inp-rect-border-style" class="prop-select" onchange="updateRectProp()">
                <option value="none">ãªã—</option>
                <option value="solid">å®Ÿç·š</option>
                <option value="dotted">ç‚¹ç·š</option>
                <option value="double">äºŒé‡ç·š</option>
            </select>

            <div class="prop-row">
                <span style="font-size:11px; flex:0.8;">å¤ªã•(mm)</span>
                <input type="range" id="inp-rect-border-w-slider" min="0.1" max="3.0" step="0.1" value="0.5"
                    oninput="updateRectProp('width', this.value)" style="flex:2;">
                <input type="number" id="inp-rect-border-w" class="prop-input" style="flex:0.8; margin-bottom:0;"
                    value="0.5" onchange="updateRectProp('width', this.value)">
            </div>
            <div style="font-size:11px; color:#666; margin-top:5px;">
                â€»æ ç·šã¯å†…å´ã«æç”»ã•ã‚Œã¾ã™ã€‚ã‚¤ãƒ³ã‚¯å¡—ã‚Šã¤ã¶ã—æ™‚ã¯å¡—ã‚Šã¤ã¶ã—ãŒ1mmå†…å´ã«é…ç½®ã•ã‚Œã€æ ç·šã¯ç™½æŠœãã«ãªã‚Šã¾ã™ã€‚
            </div>

            <button class="btn-primary btn-delete" onclick="deleteSelected()">å‰Šé™¤</button>
        </div>

        <!-- è¨­å®šãƒ‘ãƒãƒ«: ç¸¦ç·š -->
        <div class="prop-group" id="prop-panel-vline" style="display:none;">
            <div class="prop-label">ç¸¦ç·šè¨­å®š</div>

            <div class="prop-row">
                <span style="font-size:11px; flex:0.8;">å¤ªã•(mm)</span>
                <input type="range" id="inp-vline-width-slider" min="0.1" max="5.0" step="0.1" value="0.5"
                    oninput="updateVlineProp(this.value)" style="flex:2;">
                <input type="number" id="inp-vline-width" class="prop-input" style="flex:0.8; margin-bottom:0;"
                    value="0.5" onchange="updateVlineProp(this.value)">
            </div>
            <div style="font-size:11px; color:#666; margin-top:5px;">
                â€»ç¸¦ç·šã¯ãƒœãƒƒã‚¯ã‚¹ã®å·¦å³ä¸­å¤®ã«ã‚¤ãƒ³ã‚¯è‰²ã§æç”»ã•ã‚Œã¾ã™ã€‚
            </div>

            <button class="btn-primary btn-delete" onclick="deleteSelected()">å‰Šé™¤</button>
        </div>

        <div class="prop-group" id="prop-panel-image" style="display:none;">
            <div class="prop-label">ç”»åƒè¨­å®š</div>
            <div class="prop-row" style="flex-direction: column; gap: 8px;">
                <input type="file" id="inp-image-file" accept="image/*" onchange="loadImageFile(this)"
                    style="font-size: 11px;">
                <div id="image-info" style="font-size:11px; color:#666;"></div>
            </div>

            <div class="prop-label" style="margin-top: 15px;">ã‚«ãƒ©ãƒ¼ãƒ¢ãƒ¼ãƒ‰</div>
            <select id="inp-image-colormode" class="prop-input" onchange="updateImageProp('colorMode')">
                <option value="fullcolor">ãƒ•ãƒ«ã‚«ãƒ©ãƒ¼</option>
                <option value="ink">ã‚¤ãƒ³ã‚¯ãƒ¢ãƒ¼ãƒ‰ï¼ˆå…¨ä½“è¨­å®šã®è‰²ã‚’ä½¿ç”¨ï¼‰</option>
            </select>

            <div id="image-ink-settings" style="display:none; margin-top:10px;">
                <div class="prop-label">ã‚³ãƒ³ãƒˆãƒ©ã‚¹ãƒˆ</div>
                <input type="range" id="inp-image-contrast" class="prop-input" min="0" max="200" value="100"
                    oninput="updateImageProp('contrast')">
                <span id="label-image-contrast" style="font-size:11px;">100</span>

                <div class="prop-label" style="margin-top:10px;">æ˜ã‚‹ã•</div>
                <input type="range" id="inp-image-brightness" class="prop-input" min="0" max="200" value="100"
                    oninput="updateImageProp('brightness')">
                <span id="label-image-brightness" style="font-size:11px;">100</span>
            </div>

            <div class="prop-label" style="margin-top: 15px;">ãƒˆãƒªãƒŸãƒ³ã‚°</div>
            <button class="btn-primary" id="btn-crop-mode" onclick="toggleCropMode()"
                style="margin-bottom: 10px;">ãƒˆãƒªãƒŸãƒ³ã‚°èª¿æ•´</button>
            <div style="font-size:11px; color:#666; margin-bottom:10px;">
                â€»ãƒœã‚¿ãƒ³ã‚’æŠ¼ã™ã¨ç”»åƒä¸Šã§ç›´æ¥ãƒ‰ãƒ©ãƒƒã‚°ã—ã¦ãƒˆãƒªãƒŸãƒ³ã‚°ã§ãã¾ã™
            </div>

            <button class="btn-primary btn-delete" onclick="deleteSelected()">å‰Šé™¤</button>
        </div>

        <div class="prop-group" id="prop-panel-freetext" style="display:none;">
            <div class="prop-label">è‡ªç”±ãƒ†ã‚­ã‚¹ãƒˆç·¨é›†</div>
            <textarea id="inp-freetext" class="prop-input" oninput="updateFreeTextProp('text')"
                style="min-height:80px; resize:vertical;"></textarea>

            <div class="prop-label" style="margin-top:10px;">æ–‡å­—æ–¹å‘</div>
            <div class="prop-row">
                <label style="display:flex; align-items:center; font-size:12px; cursor:pointer; flex:1;">
                    <input type="radio" name="freetext-direction" value="vertical"
                        onchange="updateFreeTextProp('direction')" style="margin-right:5px;"> ç¸¦æ›¸ã
                </label>
                <label style="display:flex; align-items:center; font-size:12px; cursor:pointer; flex:1;">
                    <input type="radio" name="freetext-direction" value="horizontal"
                        onchange="updateFreeTextProp('direction')" style="margin-right:5px;"> æ¨ªæ›¸ã
                </label>
            </div>

            <div class="prop-label" style="margin-top:10px;">é…ç½®</div>
            <div class="align-grid" id="freetext-align-grid">
                <!-- å·¦ä¸Š -->
                <button type="button" class="align-grid-btn" data-align="top-left"
                    onclick="setFreetextAlign('top-left')">â– </button>
                <!-- ä¸­ä¸Š -->
                <button type="button" class="align-grid-btn" data-align="top-center"
                    onclick="setFreetextAlign('top-center')">â– </button>
                <!-- å³ä¸Š -->
                <button type="button" class="align-grid-btn" data-align="top-right"
                    onclick="setFreetextAlign('top-right')">â– </button>
                <!-- å·¦ä¸­ -->
                <button type="button" class="align-grid-btn" data-align="middle-left"
                    onclick="setFreetextAlign('middle-left')">â– </button>
                <!-- ä¸­å¤® -->
                <button type="button" class="align-grid-btn" data-align="middle-center"
                    onclick="setFreetextAlign('middle-center')">â– </button>
                <!-- å³ä¸­ -->
                <button type="button" class="align-grid-btn" data-align="middle-right"
                    onclick="setFreetextAlign('middle-right')">â– </button>
                <!-- å·¦ä¸‹ -->
                <button type="button" class="align-grid-btn" data-align="bottom-left"
                    onclick="setFreetextAlign('bottom-left')">â– </button>
                <!-- ä¸­ä¸‹ -->
                <button type="button" class="align-grid-btn" data-align="bottom-center"
                    onclick="setFreetextAlign('bottom-center')">â– </button>
                <!-- å³ä¸‹ -->
                <button type="button" class="align-grid-btn" data-align="bottom-right"
                    onclick="setFreetextAlign('bottom-right')">â– </button>
            </div>
            <div id="freetext-align-hint" style="font-size:11px; color:#666; margin-top:4px;">
                ãƒœã‚¿ãƒ³ã®ä½ç½® = ãƒ†ã‚­ã‚¹ãƒˆã®é…ç½®ä½ç½®
            </div>

            <div class="prop-label" style="margin-top:10px;">ãƒ•ã‚©ãƒ³ãƒˆè¨­å®š</div>
            <select id="inp-freetext-font" class="prop-select" onchange="updateFreeTextProp('fontFamily')">
                <option value='"BIZ UDMincho", serif'>BIZ UDMincho (BIZ UDæ˜æœ æ¨™æº–)</option>
                <option value='"Noto Serif JP", serif'>Noto Serif JP</option>
                <option value='"Noto Sans JP", sans-serif'>Noto Sans JP</option>
                <option value='"Yuji Syuku", serif'>Yuji Syuku (ä½‘å­— å®¿ ç­†æ–‡å­—)</option>
            </select>

            <div class="prop-label" style="margin-top:10px;">æ–‡å­—ã‚µã‚¤ã‚º (mm)</div>
            <div class="prop-row">
                <input type="range" id="inp-freetext-size-slider" min="2" max="50" step="0.5" value="4"
                    oninput="updateFreeTextProp('fontSize')" style="flex:2;">
                <input type="number" id="inp-freetext-size" class="prop-input" style="flex:0.8; margin-bottom:0;"
                    value="4" onchange="updateFreeTextProp('fontSize')">
            </div>

            <div class="prop-label" style="margin-top:10px;">å¤ªã•</div>
            <div class="prop-row">
                <input type="range" id="inp-freetext-weight-slider" min="200" max="900" step="100" value="400"
                    oninput="updateFreeTextProp('fontWeight')" style="flex:2;">
                <input type="number" id="inp-freetext-weight" class="prop-input" style="flex:0.8; margin-bottom:0;"
                    value="400" min="200" max="900" step="100" onchange="updateFreeTextProp('fontWeight')">
            </div>

            <div class="prop-label" style="margin-top:10px;">æ–‡å­—è‰²</div>
            <div class="prop-row color-toggle-row">
                <button type="button" class="color-toggle-btn" data-color-source="ink"
                    onclick="updateFreeTextProp('colorSource', 'ink')">ã‚¤ãƒ³ã‚¯</button>
                <button type="button" class="color-toggle-btn" data-color-source="paper"
                    onclick="updateFreeTextProp('colorSource', 'paper')">ç´™è‰²</button>
            </div>

            <button class="btn-primary btn-delete" onclick="deleteSelected()">å‰Šé™¤</button>
        </div>
    </div>

    <script>
        const PX_PER_MM = 2.834645;
        const CHAR_SCALE_RATIO = 0.85;
        const LEADING_FULLWIDTH_SPACE = 'ã€€';

        const STATE = {
            mode: 'select',
            articleSnapMode: true,
            ipadMode: false, // iPadå¯¾å¿œãƒ¢ãƒ¼ãƒ‰
            canvas: { width: 297, height: 420, margin: { top: 20, bottom: 20, left: 20, right: 20 }, colors: { paper: '#ffffff', ink: '#333333' } },
            grid: { show: true, dan: 6, charsPerDan: 11, totalLines: 25, computed: { charSizeW: 0, charSizeH: 0, lineGap: 0, danHeight: 0, danPitch: 0, pitchX: 0 } },
            view: { x: 0, y: 0, scale: 1.0 },
            activePointerId: null, interactionType: null, selectedId: null, resizeDir: null,
            pointerStart: { x: 0, y: 0 }, elemStart: { x: 0, y: 0, w: 0, h: 0 }, viewStart: { x: 0, y: 0, scale: 1 },
            touchStartDist: 0, pinchStartCanvas: { x: 0, y: 0 }, resizeAnchor: { x: 0, y: 0 },
            elements: [],
            linking: null, // { sourceId, lineEl }
            cropMode: false, // ãƒˆãƒªãƒŸãƒ³ã‚°ãƒ¢ãƒ¼ãƒ‰
            cropEdge: null, // ãƒ‰ãƒ©ãƒƒã‚°ä¸­ã®ãƒˆãƒªãƒŸãƒ³ã‚°è¾º
            // Undo/Redoå±¥æ­´ç®¡ç†
            history: [],
            historyIndex: -1,
            // ãƒ˜ãƒƒãƒ€ãƒ¼ãƒ†ã‚­ã‚¹ãƒˆè¨­å®š
            header: {
                left: { text: '20XXå¹´ï¼ˆä»¤å’ŒXå¹´ï¼‰XXæœˆXXæ—¥', fontFamily: '"Noto Sans JP", sans-serif', fontSize: 4, fontWeight: 700, letterSpacing: 0 },
                center: { text: 'ç©ºæƒ³æ–°è', fontFamily: '"Noto Serif JP", serif', fontSize: 6, fontWeight: 900, letterSpacing: 10 },
                right: { text: 'â—‹â—‹ã«ã¤ã„ã¦æ·±ãçŸ¥ã‚‹ã€‚', fontFamily: '"Noto Sans JP", sans-serif', fontSize: 4, fontWeight: 400, letterSpacing: 0 }
            }
        };

        const SVG_NS = "http://www.w3.org/2000/svg";
        const mainSvg = document.getElementById('main-svg');
        const canvasContainer = document.getElementById('canvas-container');
        const viewport = document.getElementById('viewport');
        const layerPaperGrid = document.getElementById('layer-paper-grid');
        const layerContent = document.getElementById('layer-content');
        const layerUi = document.getElementById('layer-ui');
        const svgStyle = document.getElementById('svg-style');

        function ensureLeadingFullwidthSpace(value) {
            if (typeof value !== 'string' || value.trim() === '') {
                return value;
            }
            if (value.startsWith(LEADING_FULLWIDTH_SPACE)) {
                return value;
            }
            return LEADING_FULLWIDTH_SPACE + value;
        }

        function ensureLeadingFullwidthSpacePerLine(value) {
            if (typeof value !== 'string') return LEADING_FULLWIDTH_SPACE;
            return value.split('\n').map(line => ensureLeadingFullwidthSpace(line)).join('\n');
        }

        function normalizeTextElements(list) {
            if (!Array.isArray(list)) return;
            list.forEach(el => {
                if (el && el.type === 'text') {
                    el.text = ensureLeadingFullwidthSpacePerLine(el.text);
                }
            });
        }

        function enforceTextareaLeadingSpace(textarea) {
            if (!textarea) return ensureLeadingFullwidthSpacePerLine("");
            const rawValue = textarea.value || "";
            const normalized = ensureLeadingFullwidthSpacePerLine(rawValue);
            if (normalized !== rawValue) {
                const selectionStart = textarea.selectionStart;
                const selectionEnd = textarea.selectionEnd;
                textarea.value = normalized;
                if (typeof selectionStart === 'number' && typeof selectionEnd === 'number') {
                    const delta = normalized.length - rawValue.length;
                    const newStart = Math.max(selectionStart + delta, 1);
                    const newEnd = Math.max(selectionEnd + delta, 1);
                    textarea.setSelectionRange(newStart, newEnd);
                }
            }
            return normalized;
        }

        // Init Events
        viewport.addEventListener('pointerdown', onPointerDown);
        viewport.addEventListener('pointermove', onPointerMove);
        viewport.addEventListener('pointerup', onPointerUp);
        viewport.addEventListener('pointercancel', onPointerUp);
        viewport.addEventListener('touchstart', onTouchStart, { passive: false });
        viewport.addEventListener('touchmove', onTouchMove, { passive: false });
        viewport.addEventListener('touchend', onTouchEnd);
        viewport.addEventListener('wheel', onWheel, { passive: false });

        // --- Handlers ---
        function onPointerDown(e) {
            if (!e.isPrimary) return;
            if (STATE.touchStartDist > 0) return;

            STATE.activePointerId = e.pointerId;
            STATE.pointerStart = { x: e.clientX, y: e.clientY };
            STATE.viewStart = { ...STATE.view };

            const target = e.target;
            const pt = getSvgPoint(e.clientX, e.clientY);

            // 0. Link Handle Interaction
            if (target.classList.contains('link-handle-hit')) {
                e.preventDefault();
                const sourceId = STATE.selectedId;
                if (!sourceId) return;
                const data = STATE.elements.find(el => el.id === sourceId);

                if (data.next) {
                    disconnectBlock(sourceId);
                    return;
                }

                STATE.interactionType = 'linking';
                const line = document.createElementNS(SVG_NS, 'line');
                line.setAttribute('x1', data.x + data.width / 2);
                line.setAttribute('y1', data.y + data.height);
                line.setAttribute('x2', pt.x);
                line.setAttribute('y2', pt.y);
                line.setAttribute('class', 'link-line-preview');
                layerUi.appendChild(line);
                STATE.linking = { sourceId: sourceId, lineEl: line };

                showLinkCandidates(sourceId);
                viewport.setPointerCapture(e.pointerId);
                return;
            }

            // 1. Resize Handle
            if (target.classList.contains('resize-handle-hit') || target.parentNode.classList.contains('handle-group')) {
                e.preventDefault();
                const group = target.classList.contains('handle-group') ? target : target.parentNode;
                group.setPointerCapture(e.pointerId);
                STATE.interactionType = 'resize';

                const classes = group.getAttribute('class');
                if (classes.includes('cursor-nw')) STATE.resizeDir = 'nw';
                if (classes.includes('cursor-ne')) STATE.resizeDir = 'ne';
                if (classes.includes('cursor-sw')) STATE.resizeDir = 'sw';
                if (classes.includes('cursor-se')) STATE.resizeDir = 'se';

                const data = STATE.elements.find(el => el.id === STATE.selectedId);
                STATE.elemStart = { x: data.x, y: data.y, w: data.width, h: data.height };

                if (STATE.resizeDir === 'nw') STATE.resizeAnchor = { x: data.x + data.width, y: data.y + data.height };
                if (STATE.resizeDir === 'ne') STATE.resizeAnchor = { x: data.x, y: data.y + data.height };
                if (STATE.resizeDir === 'sw') STATE.resizeAnchor = { x: data.x + data.width, y: data.y };
                if (STATE.resizeDir === 'se') STATE.resizeAnchor = { x: data.x, y: data.y };
                return;
            }

            // 1.5 Image Scale Handle Hit
            if (target.classList.contains('image-scale-handle')) {
                e.preventDefault();
                target.setPointerCapture(e.pointerId);
                STATE.interactionType = 'image-scale';
                STATE.scaleCorner = target.getAttribute('data-scale-corner');
                const data = STATE.elements.find(el => el.id === STATE.selectedId);
                STATE.elemStart = {
                    scale: data.imageScale || 1.0,
                    offsetX: data.imageOffsetX || 0,
                    offsetY: data.imageOffsetY || 0
                };
                return;
            }

            // 1.6 Image Drag Area Hit
            if (target.classList.contains('image-drag-area')) {
                e.preventDefault();
                target.setPointerCapture(e.pointerId);
                STATE.interactionType = 'image-drag';
                const data = STATE.elements.find(el => el.id === STATE.selectedId);
                STATE.elemStart = {
                    offsetX: data.imageOffsetX || 0,
                    offsetY: data.imageOffsetY || 0
                };
                return;
            }

            // 2. Element Hit Logic
            let hitElementId = null;
            if (target.classList.contains('hit-rect')) {
                // hit-rectã®è¦ªè¦ç´ ã®IDã‚’å–å¾—ã€‚è¦ªãŒIDã‚’æŒãŸãªã„å ´åˆã¯ã€ã•ã‚‰ã«è¦ªã‚’æ¢ã™
                let parent = target.parentNode;
                while (parent && !parent.id && parent !== layerContent) {
                    parent = parent.parentNode;
                }
                hitElementId = parent ? parent.id : null;
            }

            // ãƒãƒ³ãƒ‰ãƒ¢ãƒ¼ãƒ‰ã®å ´åˆã¯å¸¸ã«pan
            if (STATE.mode === 'hand') {
                e.preventDefault();
                if (STATE.selectedId) {
                    STATE.selectedId = null;
                    renderUi();
                }
                STATE.interactionType = 'pan';
                viewport.setPointerCapture(e.pointerId);
                return;
            }

            if (hitElementId) {
                e.preventDefault();
                target.setPointerCapture(e.pointerId);

                // ã‚¯ãƒ­ãƒƒãƒ—ãƒ¢ãƒ¼ãƒ‰ä¸­ã¯ç”»åƒã‚’ç§»å‹•
                const data = STATE.elements.find(el => el.id === hitElementId);
                if (!data) {
                    STATE.selectedId = hitElementId;
                    STATE.interactionType = 'drag';
                    renderUi();
                    return;
                }
                if (STATE.cropMode && data.type === 'image') {
                    STATE.selectedId = hitElementId;
                    STATE.interactionType = 'image-drag';
                    STATE.elemStart = {
                        offsetX: data.imageOffsetX || 0,
                        offsetY: data.imageOffsetY || 0
                    };
                    renderUi();
                    return;
                }

                // æ—¢ã«é¸æŠã•ã‚Œã¦ã„ã‚‹è¦ç´ ã®å ´åˆã®ã¿ãƒ‰ãƒ©ãƒƒã‚°å¯èƒ½
                if (STATE.selectedId === hitElementId) {
                    STATE.interactionType = 'drag';
                    STATE.elemStart = { x: data.x, y: data.y };
                    renderUi();
                } else {
                    // æœªé¸æŠã®è¦ç´ ã®å ´åˆ
                    if (STATE.mode === 'select') {
                        // Select mode: ä¸€æ—¦ã‚¯ãƒªãƒƒã‚¯åˆ¤å®šã¨ã—ã¦ä¿ç•™ã€ãƒ‰ãƒ©ãƒƒã‚°ã•ã‚ŒãŸã‚‰ãƒ‰ãƒ©ãƒƒã‚°é–‹å§‹
                        STATE.pendingSelection = hitElementId;
                        STATE.interactionType = 'pending-or-drag';
                        STATE.elemStart = { x: data.x, y: data.y };
                    } else {
                        // Other modes: ãƒ‰ãƒ©ãƒƒã‚°ã•ã‚ŒãŸå ´åˆã¯æ–°è¦è¦ç´ ä½œæˆã¨ã—ã¦æ‰±ã†
                        STATE.pendingSelection = hitElementId;
                        STATE.interactionType = 'pending-or-create';
                        STATE.elemStart = { x: pt.x, y: pt.y };
                    }
                }
            } else {
                // 3. Create new element (only if not in select mode)
                if (STATE.mode === 'select') {
                    // Select mode: deselect if clicking empty space
                    e.preventDefault();
                    if (STATE.selectedId) {
                        STATE.selectedId = null;
                        renderUi();
                    }
                } else {
                    // Other modes: create new element
                    e.preventDefault();
                    if (STATE.selectedId) {
                        STATE.selectedId = null;
                        renderUi();
                    }
                    viewport.setPointerCapture(e.pointerId);
                    STATE.interactionType = 'create';
                    STATE.elemStart = { x: pt.x, y: pt.y };
                }
            }
        }

        function onPointerMove(e) {
            if (e.pointerId !== STATE.activePointerId) return;
            const pt = getSvgPoint(e.clientX, e.clientY);

            // pending-or-create: å°‘ã—ã§ã‚‚ãƒ‰ãƒ©ãƒƒã‚°ã•ã‚ŒãŸã‚‰æ–°è¦ä½œæˆãƒ¢ãƒ¼ãƒ‰ã«ç§»è¡Œ
            if (STATE.interactionType === 'pending-or-create') {
                const dx = Math.abs(e.clientX - STATE.pointerStart.x);
                const dy = Math.abs(e.clientY - STATE.pointerStart.y);
                if (dx > 3 || dy > 3) {
                    // ãƒ‰ãƒ©ãƒƒã‚°åˆ¤å®š: æ–°è¦è¦ç´ ä½œæˆã«ç§»è¡Œ
                    STATE.pendingSelection = null;
                    STATE.interactionType = 'create';
                }
            }

            // pending-or-drag: å°‘ã—ã§ã‚‚ãƒ‰ãƒ©ãƒƒã‚°ã•ã‚ŒãŸã‚‰è¦ç´ ãƒ‰ãƒ©ãƒƒã‚°ã«ç§»è¡Œ
            if (STATE.interactionType === 'pending-or-drag') {
                const dx = Math.abs(e.clientX - STATE.pointerStart.x);
                const dy = Math.abs(e.clientY - STATE.pointerStart.y);
                if (dx > 3 || dy > 3) {
                    // ãƒ‰ãƒ©ãƒƒã‚°åˆ¤å®š: è¦ç´ ã‚’é¸æŠã—ã¦ãƒ‰ãƒ©ãƒƒã‚°é–‹å§‹
                    STATE.selectedId = STATE.pendingSelection;
                    STATE.pendingSelection = null;
                    STATE.interactionType = 'drag';
                    renderUi();
                }
            }

            if (STATE.interactionType === 'pan') {
                const dx = e.clientX - STATE.pointerStart.x;
                const dy = e.clientY - STATE.pointerStart.y;
                STATE.view.x = STATE.viewStart.x + dx;
                STATE.view.y = STATE.viewStart.y + dy;
                updateTransform();

            } else if (STATE.interactionType === 'linking') {
                if (STATE.linking && STATE.linking.lineEl) {
                    STATE.linking.lineEl.setAttribute('x2', pt.x);
                    STATE.linking.lineEl.setAttribute('y2', pt.y);

                    let targetId = null;
                    for (const el of STATE.elements) {
                        if (el.id === STATE.linking.sourceId) continue;
                        if (el.type !== 'text') continue;
                        if (el.next || el.prev) continue;

                        if (pt.x >= el.x && pt.x <= el.x + el.width && pt.y >= el.y && pt.y <= el.y + el.height) {
                            targetId = el.id;
                            break;
                        }
                    }
                    updateLinkHighlight(targetId);
                }
            } else if (STATE.interactionType === 'drag') {
                const dx = (e.clientX - STATE.pointerStart.x) / STATE.view.scale;
                const dy = (e.clientY - STATE.pointerStart.y) / STATE.view.scale;
                const data = STATE.elements.find(el => el.id === STATE.selectedId);
                if (data) {
                    let newX = STATE.elemStart.x + dx;
                    let newY = STATE.elemStart.y + dy;

                    if ((data.type === 'text' || data.type === 'heading' || data.type === 'rect' || data.type === 'vline' || data.type === 'masthead' || data.type === 'image') && STATE.grid.computed.charSizeW > 0) {
                        newX = getClosestColumnLeftEdge(newX);
                        const useSnapMode = data.snapMode !== undefined ? data.snapMode : STATE.articleSnapMode;
                        if ((data.type === 'text' || data.type === 'vline') && useSnapMode) {
                            // ç§»å‹•æ™‚ã‚‚Gapã«å…¥ã‚‰ãªã„ã‚ˆã†ã«å³æ ¼ã‚¹ãƒŠãƒƒãƒ—
                            newY = snapY_StrictGap(newY);
                        } else {
                            // ç”»åƒãƒœãƒƒã‚¯ã‚¹ãƒ»å¡—ã‚Šã¤ã¶ã—ã¯ãƒã‚¹ç›®ã‚¹ãƒŠãƒƒãƒ—
                            newY = snapY(newY, true);
                        }
                    }

                    data.x = newX; data.y = newY;
                    if (data.type === 'text' || data.type === 'rect') {
                        renderElement(data);
                    } else {
                        updateElementTransform(data);
                    }
                    updateUiPositions(data);
                }

            } else if (STATE.interactionType === 'resize') {
                const data = STATE.elements.find(el => el.id === STATE.selectedId);
                if (data) {
                    const anchor = STATE.resizeAnchor;
                    let targetX = pt.x; let targetY = pt.y;
                    let effAnchorX = anchor.x;
                    let effAnchorY = anchor.y;

                    const cGrid = STATE.grid.computed;

                    if ((data.type === 'text' || data.type === 'heading' || data.type === 'rect' || data.type === 'vline' || data.type === 'masthead' || data.type === 'image') && cGrid.charSizeW > 0) {

                        if (STATE.resizeDir.includes('e')) {
                            if (targetX >= anchor.x) {
                                effAnchorX = anchor.x; targetX = getClosestColumnRightEdge(targetX);
                            } else {
                                effAnchorX = anchor.x - cGrid.lineGap; targetX = getClosestColumnLeftEdge(targetX);
                            }
                        } else if (STATE.resizeDir.includes('w')) {
                            if (targetX <= anchor.x) {
                                effAnchorX = anchor.x; targetX = getClosestColumnLeftEdge(targetX);
                            } else {
                                effAnchorX = anchor.x + cGrid.lineGap; targetX = getClosestColumnRightEdge(targetX);
                            }
                        } else {
                            targetX = getClosestColumnLeftEdge(data.x);
                        }

                        const gapY = cGrid.danPitch - cGrid.danHeight;
                        const useSnapMode = data.snapMode !== undefined ? data.snapMode : STATE.articleSnapMode;
                        if (STATE.resizeDir.includes('n')) {
                            if (targetY <= anchor.y) {
                                effAnchorY = anchor.y;
                                // ãƒªã‚µã‚¤ã‚º(Top)æ™‚: è¨˜äº‹ãƒ»ç¸¦ç·šã¯Gapå›é¿ã€ç”»åƒãƒ»å¡—ã‚Šã¤ã¶ã—ã¯ãƒã‚¹ç›®ã‚¹ãƒŠãƒƒãƒ—
                                targetY = ((data.type === 'text' || data.type === 'vline') && useSnapMode) ? snapY_StrictGap(targetY) : snapY(targetY, true);
                            } else {
                                effAnchorY = anchor.y + gapY;
                                targetY = ((data.type === 'text' || data.type === 'vline') && useSnapMode) ? snapY_StrictGap(targetY) : snapY(targetY, false);
                            }
                        } else if (STATE.resizeDir.includes('s')) {
                            if (targetY >= anchor.y) {
                                effAnchorY = anchor.y;
                                // ãƒªã‚µã‚¤ã‚º(Bottom)æ™‚: è¨˜äº‹ãƒ»ç¸¦ç·šã¯æ®µã®ä¸‹ç«¯ã€ç”»åƒãƒ»å¡—ã‚Šã¤ã¶ã—ã¯ãƒã‚¹ç›®ã‚¹ãƒŠãƒƒãƒ—
                                targetY = ((data.type === 'text' || data.type === 'vline') && useSnapMode) ? snapY_StrictGap_Bottom(targetY) : snapY(targetY, false);
                            } else {
                                effAnchorY = anchor.y - gapY;
                                targetY = ((data.type === 'text' || data.type === 'vline') && useSnapMode) ? snapY_StrictGap_Bottom(targetY) : snapY(targetY, true);
                            }
                        }
                    }

                    let newW = Math.abs(targetX - effAnchorX);
                    let newH = Math.abs(targetY - effAnchorY);
                    let newX = Math.min(targetX, effAnchorX);
                    let newY = Math.min(targetY, effAnchorY);
                    if (newW < 1) newW = 1; if (newH < 1) newH = 1;

                    data.x = newX; data.y = newY; data.width = newW; data.height = newH;

                    if (data.type === 'text') {
                        const head = findChainHead(data);
                        updateTextChain(head);
                        updateUiPositions(data);
                    } else if (data.type === 'image') {
                        // ç”»åƒãƒœãƒƒã‚¯ã‚¹ã®ãƒªã‚µã‚¤ã‚ºæ™‚ã€ã‚ªãƒ•ã‚»ãƒƒãƒˆã‚’èª¿æ•´ã—ã¦ä½™ç™½ãŒè¦‹ãˆãªã„ã‚ˆã†ã«ã™ã‚‹
                        if (data._imageAspect) {
                            const boxAspect = data.width / data.height;
                            const imgAspect = data._imageAspect;
                            const scale = data.imageScale || 1.0;
                            let baseW, baseH;
                            if (imgAspect > boxAspect) {
                                baseH = data.height;
                                baseW = baseH * imgAspect;
                            } else {
                                baseW = data.width;
                                baseH = baseW / imgAspect;
                            }

                            const scaledW = baseW * scale;
                            const scaledH = baseH * scale;
                            const maxOffsetX = (scaledW - data.width) / 2;
                            const maxOffsetY = (scaledH - data.height) / 2;

                            // ç¾åœ¨ã®ã‚ªãƒ•ã‚»ãƒƒãƒˆã‚’åˆ¶é™å†…ã«åã‚ã‚‹
                            const currentOffsetX = data.imageOffsetX || 0;
                            const currentOffsetY = data.imageOffsetY || 0;
                            data.imageOffsetX = Math.max(-maxOffsetX, Math.min(maxOffsetX, currentOffsetX));
                            data.imageOffsetY = Math.max(-maxOffsetY, Math.min(maxOffsetY, currentOffsetY));
                        }

                        renderElement(data);
                        updateUiPositions(data);
                    } else {
                        if (data.type === 'heading' || data.type === 'masthead' || data.type === 'rect') {
                            renderElement(data); // Re-render for new size
                        } else {
                            updateElementTransform(data);
                        }
                        updateUiPositions(data);
                    }
                }

            } else if (STATE.interactionType === 'crop') {
                // ... (crop code same)
            } else if (STATE.interactionType === 'image-drag') {
                const data = STATE.elements.find(el => el.id === STATE.selectedId);
                if (data && data.type === 'image' && data._imageAspect) {
                    const dx = (e.clientX - STATE.pointerStart.x) / STATE.view.scale;
                    const dy = (e.clientY - STATE.pointerStart.y) / STATE.view.scale;

                    // ã‚«ãƒãƒ¼ãƒ•ã‚£ãƒƒãƒˆåŸºæº–ã‚µã‚¤ã‚ºã‚’è¨ˆç®—
                    const boxAspect = data.width / data.height;
                    const imgAspect = data._imageAspect;
                    const scale = data.imageScale || 1.0;
                    let baseW, baseH;
                    if (imgAspect > boxAspect) {
                        baseH = data.height;
                        baseW = baseH * imgAspect;
                    } else {
                        baseW = data.width;
                        baseH = baseW / imgAspect;
                    }

                    // ã‚¹ã‚±ãƒ¼ãƒ«é©ç”¨å¾Œã®ç”»åƒã‚µã‚¤ã‚º
                    const scaledW = baseW * scale;
                    const scaledH = baseH * scale;

                    // ã‚ªãƒ•ã‚»ãƒƒãƒˆã®åˆ¶é™ï¼ˆç”»åƒã®ç«¯ãŒã‚¯ãƒªãƒƒãƒ—ã®ç«¯ã«æ¥ã‚‹ã¾ã§ï¼‰
                    const maxOffsetX = (scaledW - data.width) / 2;
                    const maxOffsetY = (scaledH - data.height) / 2;

                    const newOffsetX = STATE.elemStart.offsetX + dx;
                    const newOffsetY = STATE.elemStart.offsetY + dy;

                    data.imageOffsetX = Math.max(-maxOffsetX, Math.min(maxOffsetX, newOffsetX));
                    data.imageOffsetY = Math.max(-maxOffsetY, Math.min(maxOffsetY, newOffsetY));

                    renderElement(data);
                    renderUi();
                }

            } else if (STATE.interactionType === 'image-scale') {
                // ... (image-scale code same)
                const data = STATE.elements.find(el => el.id === STATE.selectedId);
                if (data && data.type === 'image' && data._imageAspect) {
                    const dx = (e.clientX - STATE.pointerStart.x) / STATE.view.scale;
                    const dy = (e.clientY - STATE.pointerStart.y) / STATE.view.scale;

                    // ã‚«ãƒãƒ¼ãƒ•ã‚£ãƒƒãƒˆåŸºæº–ã‚µã‚¤ã‚ºã‚’è¨ˆç®—
                    const boxAspect = data.width / data.height;
                    const imgAspect = data._imageAspect;
                    let baseW, baseH;
                    if (imgAspect > boxAspect) {
                        baseH = data.height;
                        baseW = baseH * imgAspect;
                    } else {
                        baseW = data.width;
                        baseH = baseW / imgAspect;
                    }

                    // ã‚³ãƒ¼ãƒŠãƒ¼ã«å¿œã˜ã¦ã‚¹ã‚±ãƒ¼ãƒ«è¨ˆç®—
                    const corner = STATE.scaleCorner;
                    let scaleChange = 0;

                    if (corner === 'nw') {
                        scaleChange = -(dx + dy) / Math.max(baseW, baseH);
                    } else if (corner === 'ne') {
                        scaleChange = (dx - dy) / Math.max(baseW, baseH);
                    } else if (corner === 'sw') {
                        scaleChange = (-dx + dy) / Math.max(baseW, baseH);
                    } else if (corner === 'se') {
                        scaleChange = (dx + dy) / Math.max(baseW, baseH);
                    }

                    // ç”»åƒã®çŸ­è¾ºãŒã‚¯ãƒªãƒƒãƒ—ã®çŸ­è¾ºä»¥ä¸Šã«ãªã‚‹ã‚ˆã†ã«æœ€å°ã‚¹ã‚±ãƒ¼ãƒ«ã‚’è¨ˆç®—
                    const minScaleX = data.width / baseW;
                    const minScaleY = data.height / baseH;
                    const minScale = Math.max(minScaleX, minScaleY, 0.1);

                    // æ–°ã—ã„ã‚¹ã‚±ãƒ¼ãƒ«ã‚’é©ç”¨
                    data.imageScale = Math.max(minScale, Math.min(10, STATE.elemStart.scale + scaleChange));

                    renderElement(data);
                    renderUi();
                }
            } else if (STATE.interactionType === 'create') {
                // ... (create code same)
                // ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼è¦ç´ ã®æº–å‚™
                let preview = null;

                if (STATE.mode === 'image') {
                    // ç”»åƒãƒ¢ãƒ¼ãƒ‰ç”¨ã®ã‚°ãƒ«ãƒ¼ãƒ—ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼
                    let previewGroup = document.getElementById('creation-preview-group');
                    if (!previewGroup) {
                        previewGroup = document.createElementNS(SVG_NS, 'g');
                        previewGroup.id = 'creation-preview-group';
                        layerUi.appendChild(previewGroup);
                    }
                    // å˜ä¸€ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ãŒã‚ã‚Œã°å‰Šé™¤
                    const singlePreview = document.getElementById('creation-preview');
                    if (singlePreview) singlePreview.remove();
                } else {
                    // é€šå¸¸ãƒ¢ãƒ¼ãƒ‰: å˜ä¸€ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼è¦ç´ 
                    preview = document.getElementById('creation-preview');
                    if (!preview) {
                        preview = document.createElementNS(SVG_NS, 'rect');
                        preview.id = 'creation-preview';
                        preview.setAttribute('class', 'creation-preview-rect');
                        layerUi.appendChild(preview);
                    }
                    // ä¸è¦ãªã‚°ãƒ«ãƒ¼ãƒ—ãŒã‚ã‚Œã°å‰Šé™¤
                    const group = document.getElementById('creation-preview-group');
                    if (group) group.remove();
                }

                let currentX = pt.x; let currentY = pt.y;
                let effStartX = STATE.elemStart.x;
                let effStartY = STATE.elemStart.y;
                const cGrid = STATE.grid.computed;

                if ((STATE.mode === 'text' || STATE.mode === 'heading' || STATE.mode === 'rect' || STATE.mode === 'vline' || STATE.mode === 'masthead' || STATE.mode === 'image') && cGrid.charSizeW > 0) {
                    // ç‰¹æ®Šå‡¦ç†: è¨˜äº‹é…ç½®ãƒ¢ãƒ¼ãƒ‰ã®ã¨ã
                    if (STATE.articleSnapMode && STATE.mode === 'text') {
                        const startLeftEdge = getClosestColumnLeftEdge(STATE.elemStart.x);
                        const startRightEdge = getClosestColumnRightEdge(STATE.elemStart.x);
                        const currentLeftEdge = getClosestColumnLeftEdge(currentX);
                        const currentRightEdge = getClosestColumnRightEdge(currentX);
                        const leftEdgeCandidate = currentX >= STATE.elemStart.x ? startLeftEdge : currentLeftEdge;
                        const rightEdgeCandidate = currentX >= STATE.elemStart.x ? currentRightEdge : startRightEdge;
                        const leftEdge = Math.min(leftEdgeCandidate, rightEdgeCandidate);
                        const rightEdge = Math.max(leftEdgeCandidate, rightEdgeCandidate);
                        const rawTop = Math.min(STATE.elemStart.y, currentY);
                        const rawBottom = Math.max(STATE.elemStart.y, currentY);
                        const snappedTop = snapY_DanTop(rawTop);
                        const snappedBottom = snapY_DanBottom(rawBottom);

                        const x = leftEdge;
                        const width = rightEdge - leftEdge;
                        const y = snappedTop;
                        const height = snappedBottom - snappedTop;

                        if (width < 1 || height < 1) {
                            if (preview) preview.remove();
                            return;
                        }

                        if (preview) {
                            preview.setAttribute('x', x);
                            preview.setAttribute('y', y);
                            preview.setAttribute('width', width);
                            preview.setAttribute('height', height);

                            if (!preview.parentNode) layerUi.appendChild(preview);
                        }
                        return;

                    } else {
                        // é€šå¸¸ãƒ¢ãƒ¼ãƒ‰ï¼ˆå¾“æ¥ãƒ­ã‚¸ãƒƒã‚¯ï¼‰
                        if (currentX >= STATE.elemStart.x) {
                            effStartX = getClosestColumnLeftEdge(STATE.elemStart.x); currentX = getClosestColumnRightEdge(currentX);
                        } else {
                            effStartX = getClosestColumnRightEdge(STATE.elemStart.x); currentX = getClosestColumnLeftEdge(currentX);
                        }
                        if (currentY >= STATE.elemStart.y) {
                            effStartY = (STATE.mode === 'text' && STATE.articleSnapMode) ? snapY_DanTop(STATE.elemStart.y) : snapY(STATE.elemStart.y, true);
                            currentY = (STATE.mode === 'text' && STATE.articleSnapMode) ? snapY_DanBottom(currentY) : snapY(currentY, false);
                        } else {
                            effStartY = (STATE.mode === 'text' && STATE.articleSnapMode) ? snapY_DanBottom(STATE.elemStart.y) : snapY(STATE.elemStart.y, false);
                            currentY = (STATE.mode === 'text' && STATE.articleSnapMode) ? snapY_DanTop(currentY) : snapY(currentY, true);
                        }
                    }
                }

                const w = Math.abs(currentX - effStartX);
                const h = Math.abs(currentY - effStartY);
                const x = Math.min(currentX, effStartX);
                const y = Math.min(currentY, effStartY);

                if (STATE.mode === 'image') {
                    const previewGroup = document.getElementById('creation-preview-group');
                    if (!previewGroup) return;

                    previewGroup.innerHTML = '';

                    const gap = (cGrid.lineGap && cGrid.lineGap > 0) ? cGrid.lineGap : 5;

                    // ãƒœãƒƒã‚¯ã‚¹ã‚·ãƒ£ãƒ‰ã‚¦ï¼ˆå·¦å³ã®ã¿ï¼‰
                    const shadowRect = document.createElementNS(SVG_NS, 'rect');
                    shadowRect.setAttribute('x', x - gap);
                    shadowRect.setAttribute('y', y);
                    shadowRect.setAttribute('width', w + gap * 2);
                    shadowRect.setAttribute('height', h);
                    shadowRect.setAttribute('class', 'paper-fill');
                    shadowRect.setAttribute('opacity', '0.5');
                    previewGroup.appendChild(shadowRect);

                    // ãƒ¡ã‚¤ãƒ³ãƒœãƒƒã‚¯ã‚¹
                    const mainRect = document.createElementNS(SVG_NS, 'rect');
                    mainRect.setAttribute('x', x);
                    mainRect.setAttribute('y', y);
                    mainRect.setAttribute('width', w);
                    mainRect.setAttribute('height', h);
                    mainRect.setAttribute('class', 'creation-preview-rect');
                    previewGroup.appendChild(mainRect);
                } else {
                    if (preview) {
                        preview.setAttribute('x', x); preview.setAttribute('y', y);
                        preview.setAttribute('width', w); preview.setAttribute('height', h);
                        if (!preview.parentNode) layerUi.appendChild(preview);
                    }
                }
            }
        }

        function onPointerUp(e) {
            if (e.pointerId !== STATE.activePointerId) return;
            const wasInteracting = (STATE.interactionType === 'drag' || STATE.interactionType === 'resize');

            // pending-or-create: ãƒ‰ãƒ©ãƒƒã‚°ã›ãšã«ã‚¯ãƒªãƒƒã‚¯ã ã‘ã—ãŸå ´åˆã¯é¸æŠ
            if (STATE.interactionType === 'pending-or-create' && STATE.pendingSelection) {
                STATE.selectedId = STATE.pendingSelection;
                STATE.pendingSelection = null;
                renderUi();
            }

            // pending-or-drag: ãƒ‰ãƒ©ãƒƒã‚°ã›ãšã«ã‚¯ãƒªãƒƒã‚¯ã ã‘ã—ãŸå ´åˆã¯é¸æŠ
            if (STATE.interactionType === 'pending-or-drag' && STATE.pendingSelection) {
                STATE.selectedId = STATE.pendingSelection;
                STATE.pendingSelection = null;
                renderUi();
            }

            if (STATE.interactionType === 'linking') {
                const pt = getSvgPoint(e.clientX, e.clientY);
                let targetId = null;
                for (const el of STATE.elements) {
                    if (el.id === STATE.linking.sourceId) continue;
                    if (el.type !== 'text') continue;
                    if (el.next || el.prev) continue;

                    if (pt.x >= el.x && pt.x <= el.x + el.width && pt.y >= el.y && pt.y <= el.y + el.height) {
                        targetId = el.id;
                        break;
                    }
                }
                if (targetId) {
                    connectBlocks(STATE.linking.sourceId, targetId);
                }
                if (STATE.linking.lineEl) STATE.linking.lineEl.remove();
                STATE.linking = null;

                clearLinkCandidates();
                renderUi();
            }

            if (STATE.interactionType === 'create') {
                const preview = document.getElementById('creation-preview');
                const group = document.getElementById('creation-preview-group');

                let x, y, w, h;

                // ç”»åƒãƒ¢ãƒ¼ãƒ‰ã®å ´åˆã¯ã‚°ãƒ«ãƒ¼ãƒ—ã‹ã‚‰ã€ãã‚Œä»¥å¤–ã¯previewã‹ã‚‰åº§æ¨™å–å¾—
                if (group) {
                    // ã‚°ãƒ«ãƒ¼ãƒ—å†…ã®ãƒ¡ã‚¤ãƒ³ãƒœãƒƒã‚¯ã‚¹ï¼ˆ2ç•ªç›®ã®å­è¦ç´ ï¼‰ã‹ã‚‰åº§æ¨™å–å¾—
                    const mainRect = group.children[1];
                    if (mainRect) {
                        w = parseFloat(mainRect.getAttribute('width'));
                        h = parseFloat(mainRect.getAttribute('height'));
                        x = parseFloat(mainRect.getAttribute('x'));
                        y = parseFloat(mainRect.getAttribute('y'));
                        if (w > 5 && h > 5) createObjectFromRect({ x, y, w, h });
                    }
                    group.remove();
                } else if (preview) {
                    w = parseFloat(preview.getAttribute('width'));
                    h = parseFloat(preview.getAttribute('height'));
                    x = parseFloat(preview.getAttribute('x'));
                    y = parseFloat(preview.getAttribute('y'));
                    if (w > 5 && h > 5) createObjectFromRect({ x, y, w, h });
                    preview.remove();
                }
            }

            STATE.activePointerId = null; STATE.interactionType = null;
            try { e.target.releasePointerCapture(e.pointerId); } catch (err) { }

            if (wasInteracting) {
                const data = STATE.elements.find(el => el.id === STATE.selectedId);
                if (data) {
                    if (data.type === 'text') {
                        const head = findChainHead(data);
                        updateTextChain(head);
                    } else {
                        renderElement(data);
                    }
                    renderUi();
                    saveHistory();
                }
            }
        }

        // --- Link Logic ---
        function connectBlocks(sourceId, targetId) {
            const source = STATE.elements.find(e => e.id === sourceId);
            const target = STATE.elements.find(e => e.id === targetId);
            if (!source || !target || source.type !== 'text' || target.type !== 'text') return;

            if (target.next) return;
            if (target.prev) return;

            let curr = source;
            while (curr) {
                if (curr.id === targetId) return;
                if (curr.prev) curr = STATE.elements.find(e => e.id === curr.prev);
                else break;
            }

            source.next = targetId;
            target.prev = sourceId;

            const head = findChainHead(source);
            updateTextChain(head);
            saveHistory();
        }

        function disconnectBlock(sourceId) {
            const source = STATE.elements.find(e => e.id === sourceId);
            if (!source || !source.next) return;

            const nextId = source.next;
            const nextEl = STATE.elements.find(e => e.id === nextId);

            source.next = null;
            if (nextEl) {
                nextEl.prev = null;
                delete nextEl._renderedText;
                if (!nextEl.text) nextEl.text = ensureLeadingFullwidthSpacePerLine("æ–°è¦è¨˜äº‹");
                renderElement(nextEl);
            }

            const head = findChainHead(source);
            updateTextChain(head);
            renderUi();
            saveHistory();
        }

        function findChainHead(block) {
            let curr = block;
            while (curr.prev) {
                const prev = STATE.elements.find(e => e.id === curr.prev);
                if (!prev) { curr.prev = null; break; }
                curr = prev;
            }
            return curr;
        }

        function updateTextChain(head) {
            if (!head || head.type !== 'text') return;

            let curr = head;
            let remainingText = head.text;

            while (curr) {
                const res = measureCapacity(curr, remainingText);
                curr._renderedText = res.fitted;
                remainingText = res.remaining;

                renderElement(curr);

                if (curr.next) {
                    const next = STATE.elements.find(e => e.id === curr.next);
                    if (!next) { curr.next = null; break; }
                    curr = next;
                } else {
                    curr = null;
                }
            }
        }

        // Internal Column Logic Helper
        function getIntersectingDans(data) {
            const cGrid = STATE.grid.computed;
            if (!STATE.grid.show || !cGrid.danPitch) {
                return [{ yOffset: 0, height: data.height, localY: 0 }];
            }

            const mt = STATE.canvas.margin.top * PX_PER_MM;
            const boxTop = data.y;
            const boxBottom = data.y + data.height;

            const segments = [];
            const epsilon = 1.0;

            for (let i = 0; i < STATE.grid.dan; i++) {
                const danTop = mt + (i * cGrid.danPitch);
                const danBottom = danTop + cGrid.danHeight;

                const start = Math.max(boxTop, danTop - epsilon);
                const end = Math.min(boxBottom, danBottom + epsilon);

                if (end > start + 5) {
                    const localY = danTop - boxTop;
                    segments.push({
                        danIndex: i,
                        danTop: danTop,
                        localY: localY,
                        height: cGrid.danHeight
                    });
                }
            }

            if (segments.length === 0) return [{ yOffset: 0, height: data.height, localY: 0 }];

            return segments;
        }

        function getLayoutMetrics(data, forcedHeight, useSnapMode = false) {
            const cGrid = STATE.grid.computed;
            let fontSize, charHeight, pitchX;

            if (cGrid.charSizeW > 0 && STATE.grid.show) {
                fontSize = cGrid.charSizeW;
                charHeight = cGrid.charSizeH;
                pitchX = cGrid.pitchX;
            } else {
                fontSize = data.fontSize;
                charHeight = data.fontSize;
                pitchX = data.fontSize * data.lineHeight;
            }

            const w = data.width;
            const h = forcedHeight !== undefined ? forcedHeight : data.height;

            const safeCharHeight = charHeight > 0 ? charHeight : 1;
            const safePitchX = pitchX > 0 ? pitchX : 1;
            let charsPerLine = Math.max(1, Math.floor((h / safeCharHeight) + 0.5));
            const maxLines = Math.max(1, Math.floor((w / safePitchX) + 0.5));
            if (useSnapMode && STATE.grid.show && STATE.grid.charsPerDan > 0) {
                charsPerLine = STATE.grid.charsPerDan;
            }

            return { fontSize, charHeight, pitchX, charsPerLine, maxLines };
        }

        function measureCapacity(data, text) {
            if (!text) return { fitted: "", remaining: "" };

            let segments;
            const useSnapMode = data.snapMode !== undefined ? data.snapMode : STATE.articleSnapMode;
            if (useSnapMode) {
                segments = getIntersectingDans(data);
            } else {
                segments = [{ height: data.height, localY: 0 }];
            }

            let processedChars = 0; // å®Ÿéš›ã«å‡¦ç†ã—ãŸå…ƒãƒ†ã‚­ã‚¹ãƒˆã®æ–‡å­—æ•°
            let currentTextPos = 0; // ç¾åœ¨ã®å…ƒãƒ†ã‚­ã‚¹ãƒˆä½ç½®

            for (const seg of segments) {
                const metrics = getLayoutMetrics(data, seg.height, useSnapMode);
                const { charsPerLine, maxLines } = metrics;

                // æ®‹ã‚Šã®ãƒ†ã‚­ã‚¹ãƒˆ
                const remainingText = text.substring(currentTextPos);
                if (!remainingText) break;

                // â˜…æ®µè½å…ˆé ­åˆ¤å®šï¼ˆã‚»ã‚°ãƒ¡ãƒ³ãƒˆå¢ƒç•Œã§èª¤å­—ä¸‹ã’ã—ãªã„ï¼‰
                const paragraphStart =
                    (currentTextPos === 0) ||
                    (text[currentTextPos - 1] === '\n');

                // ãƒˆãƒ¼ã‚¯ãƒ³åŒ–â†’ç¦å‰‡â†’è¡Œé…åˆ—
                const tokens = tokenizeText(remainingText, { paragraphStart });
                const lines = applyKinsoku(tokens, charsPerLine);

                let lineCount = 0;
                let segmentChars = 0; // â˜…å…ƒãƒ†ã‚­ã‚¹ãƒˆã¨ã—ã¦æ¶ˆè²»ã—ãŸæ–‡å­—æ•°ï¼ˆå­—ä¸‹ã’ã¯å«ã‚ãªã„ï¼‰

                for (const line of lines) {
                    if (lineCount >= maxLines) break;

                    for (const token of line) {
                        // â˜…å­—ä¸‹ã’ã¯â€œè¡¨ç¤ºç”¨â€ãªã®ã§å…ƒãƒ†ã‚­ã‚¹ãƒˆæ¶ˆè²»ã«æ•°ãˆãªã„
                        if (token.isLineIndent) continue;

                        if (token.type === 'tcy') {
                            segmentChars += token.char.length;
                        } else {
                            segmentChars += 1;
                        }
                    }
                    lineCount++;
                }

                currentTextPos += segmentChars;
                processedChars = currentTextPos;

                if (processedChars >= text.length) break;
            }

            return {
                fitted: text.substring(0, processedChars),
                remaining: text.substring(processedChars)
            };
        }


        // ç¸¦ä¸­æ¨ªåˆ¤å®šï¼ˆ2æ–‡å­—ä»¥å†…ã®é€£ç¶šæ•°å­—ï¼‰
        function isTateChuYoko(text, index) {
            if (index >= text.length) return null;
            const char = text[index];
            if (!/[0-9ï¼-ï¼™]/.test(char)) return null;

            let count = 1;
            let nextChar = text[index + 1];

            if (nextChar && /[0-9ï¼-ï¼™]/.test(nextChar)) {
                count = 2;
                let thirdChar = text[index + 2];
                if (thirdChar && /[0-9ï¼-ï¼™]/.test(thirdChar)) {
                    return null;
                }
            }

            return count;
        }

        // ç¸¦ä¸­æ¨ªç”¨ã®ã‚°ãƒªãƒ•é…åˆ—ã‚’ç”Ÿæˆï¼ˆè¦‹å‡ºã—ãƒ»é¡Œå­—ãƒ»è‡ªç”±ãƒ†ã‚­ã‚¹ãƒˆç”¨ï¼‰
        function getGlyphsWithTcy(text) {
            const glyphs = [];
            let i = 0;
            while (i < text.length) {
                const tcyCount = isTateChuYoko(text, i);
                if (tcyCount) {
                    glyphs.push({ type: 'tcy', text: text.substr(i, tcyCount) });
                    i += tcyCount;
                } else {
                    glyphs.push({ type: 'char', text: text[i] });
                    i++;
                }
            }
            return glyphs;
        }

        // --- æ—¥æœ¬èªçµ„ç‰ˆå‡¦ç† ---
        // è¡Œé ­ç¦å‰‡æ–‡å­—
        const GYOTO_KINSOKU = [
            // å¥èª­ç‚¹ãƒ»è¨˜å·
            'ã€‚', 'ã€', 'ï¼', 'ï¼Œ', 'ï¼š', 'ï¼›',
            // é–‰ã˜æ‹¬å¼§é¡
            'ï¼‰', ')', 'ï¼½', ']', 'ï½', '}', 'ã€', 'ã€', 'ã€‘', 'ã€‰', 'ã€‹', 'ã€‹', 'ã€•', 'â€º', 'Â»',
            // æ„Ÿå˜†ç¬¦ãƒ»ç–‘å•ç¬¦
            'ï¼', 'ï¼Ÿ', '!', '?', 'â€¼', 'â‡', 'âˆ', 'â‰',
            // é•·éŸ³ãƒ»ä¸­ç‚¹ãªã©
            'ãƒ¼', 'ï¼', 'âˆ’', 'â€', 'â€‘', 'â€’', 'â€“', 'â€”', 'â€•', 'ã€œ', 'ï½',
            'ãƒ»', 'ï½¥', 'ï¼š', 'ï¼›', 'ã‚ ',
            // ç¹°ã‚Šè¿”ã—è¨˜å·
            'ã‚', 'ã‚', 'ãƒ½', 'ãƒ¾', 'ã€…', 'ã€»',
            // å°æ›¸ãä»®å
            'ã', 'ãƒ', 'ã…', 'ã‡', 'ã‰', 'ã£', 'ã‚ƒ', 'ã‚…', 'ã‚‡', 'ã‚',
            'ã‚¡', 'ã‚£', 'ã‚¥', 'ã‚§', 'ã‚©', 'ãƒƒ', 'ãƒ£', 'ãƒ¥', 'ãƒ§', 'ãƒ®', 'ãƒµ', 'ãƒ¶',
            // ãã®ä»–
            'â€¦', 'â€¥', 'Â°', 'â€²', 'â€³', 'â„ƒ', 'ï¿ ', 'Â¢', '%', 'ï¼…', 'â€°'
        ];
        // è¡Œæœ«ç¦å‰‡æ–‡å­—ï¼ˆé–‹ãæ‹¬å¼§ãªã©ï¼‰
        const GYOMATSU_KINSOKU = [
            'ï¼ˆ', '(', 'ï¼»', '[', 'ï½›', '{', 'ã€Œ', 'ã€', 'ã€', 'ã€ˆ', 'ã€Š', 'ã€”', 'â€¹', 'Â«'
        ];

        // ===== tokenizeï¼ˆæ®µè½é ­ã ã‘å­—ä¸‹ã’ï¼‰ =====
        // opts.paragraphStart: true ã®ã¨ãã€ãã®å‘¼ã³å‡ºã—é–‹å§‹æ™‚ç‚¹ã‚’æ®µè½å…ˆé ­ã¨ã—ã¦æ‰±ã†
        function tokenizeText(text, opts = {}) {
            const tokens = [];
            let i = 0;

            // â˜…ã€Œã“ã®å‘¼ã³å‡ºã—é–‹å§‹æ™‚ç‚¹ã§æ®µè½å…ˆé ­ã‹ï¼Ÿã€ï¼ˆã‚»ã‚°ãƒ¡ãƒ³ãƒˆå¢ƒç•Œå¯¾ç­–ï¼‰
            let atParagraphStart = !!opts.paragraphStart;

            while (i < text.length) {
                const ch = text[i];

                // æ”¹è¡Œï¼šã“ã“ã§æ®µè½å…ˆé ­ã«æˆ»ã™
                if (ch === '\n') {
                    tokens.push({ type: 'newline', char: '\n', isLineIndent: false });
                    i++;
                    atParagraphStart = true;
                    continue;
                }

                // â˜…æ®µè½å…ˆé ­ã®ã¨ãã ã‘å­—ä¸‹ã’ï¼ˆ1å›ã ã‘ï¼‰
                if (atParagraphStart) {
                    tokens.push({ type: 'indent', char: '', isLineIndent: true }); // è¡¨ç¤ºç”¨1ãƒã‚¹
                    atParagraphStart = false;
                }

                // ç¸¦ä¸­æ¨ªï¼ˆã‚ãªãŸã®æ—¢å­˜é–¢æ•°ã‚’ä½¿ç”¨ï¼‰
                const tcyCount = isTateChuYoko(text, i);
                if (tcyCount) {
                    const tcyText = text.substr(i, tcyCount);
                    tokens.push({ type: 'tcy', char: tcyText, isLineIndent: false });
                    i += tcyCount;
                    continue;
                }

                // é€šå¸¸æ–‡å­—
                tokens.push({ type: 'char', char: ch, isLineIndent: false });
                i++;
            }

            return tokens;
        }

        // 1è¡Œã®ã€Œãƒã‚¹æ•°ã€(æ”¹è¡Œã¯0ã€ãã‚Œä»¥å¤–ã¯1ãƒã‚¹)
        function getLineGlyphCount(tokens) {
            return tokens.reduce((n, t) => {
                if (t.type === 'newline') return n;
                return n + 1; // char / tcy / indent ã¯ 1ãƒã‚¹
            }, 0);
        }

        function findFirstRenderableToken(tokens) {
            for (const t of tokens) {
                if (t.type === 'newline') continue;
                if (!t.isLineIndent) return t;
            }
            return null;
        }

        function findLastRenderableToken(tokens) {
            for (let i = tokens.length - 1; i >= 0; i--) {
                const t = tokens[i];
                if (t.type === 'newline') continue;
                if (!t.isLineIndent) return t;
            }
            return null;
        }

        function removeFirstRenderableToken(tokens) {
            for (let i = 0; i < tokens.length; i++) {
                const t = tokens[i];
                if (t.type === 'newline') continue;
                if (t.isLineIndent) continue;
                return tokens.splice(i, 1)[0];
            }
            return null;
        }

        function removeLastRenderableToken(tokens, { excludeIndent = true } = {}) {
            for (let i = tokens.length - 1; i >= 0; i--) {
                const t = tokens[i];
                if (t.type === 'newline') continue;
                if (excludeIndent && t.isLineIndent) continue;
                return tokens.splice(i, 1)[0];
            }
            return null;
        }

        // nextLine ã®å…ˆé ­ï¼ˆindentç¾¤ã®å¾Œã‚ï¼‰ã« token ã‚’æŒ¿å…¥
        function insertAfterIndents(nextLine, token) {
            let idx = 0;
            while (idx < nextLine.length) {
                const t = nextLine[idx];
                if (t.type === 'newline') break;
                if (!t.isLineIndent) break;
                idx++;
            }
            nextLine.splice(idx, 0, token);
        }

        function enforceMaxCells(lines, maxCells) {
            for (let i = 0; i < lines.length; i++) {
                while (getLineGlyphCount(lines[i]) > maxCells) {
                    const overflow = removeLastRenderableToken(lines[i], { excludeIndent: true });
                    if (!overflow) break;

                    // æ¬¡ã®è¡ŒãŒãªã‘ã‚Œã°ä½œã‚‹
                    if (!lines[i + 1]) lines[i + 1] = [];

                    // Kinsoku-aware overflow: if the character being pushed is a line-head
                    // prohibited character, pull the one before it as well.
                    let beforeKinsoku = null;
                    if (GYOTO_KINSOKU.includes(overflow.char)) {
                        beforeKinsoku = removeLastRenderableToken(lines[i], { excludeIndent: true });
                    }

                    // Insert in correct order (the one removed last was first on the line)
                    insertAfterIndents(lines[i + 1], overflow);
                    if (beforeKinsoku) {
                        insertAfterIndents(lines[i + 1], beforeKinsoku);
                    }
                }
            }
        }

        function applyKinsoku(tokens, charsPerLine) {
            if (!tokens || tokens.length === 0 || charsPerLine <= 0) return [];

            const maxCells = Math.max(1, charsPerLine);

            // --- 1) ãƒ©ãƒ•æŠ˜ã‚Š ---
            const roughLines = [];
            let currentLine = [];
            let currentCells = 0;

            for (const token of tokens) {
                if (token.type === 'newline') {
                    if (currentLine.length === 0) {
                        roughLines.push([token]);
                    } else {
                        currentLine.push(token);
                        roughLines.push(currentLine);
                    }
                    currentLine = [];
                    currentCells = 0;
                    continue;
                }

                currentLine.push(token);
                currentCells++;

                if (currentCells >= maxCells) {
                    roughLines.push(currentLine);
                    currentLine = [];
                    currentCells = 0;
                }
            }
            if (currentLine.length) roughLines.push(currentLine);

            // --- 2) ç¦å‰‡å‡¦ç†ï¼ˆæ¬¡è¡Œã¸åˆ‡ã‚Šä¸Šã’ï¼‰ ---
            // è¤‡æ•°å›å®Ÿè¡Œã—ã¦ã€ã™ã¹ã¦ã®ç¦å‰‡ã‚’è§£æ±ºã™ã‚‹
            let kinsokuChanged = true;
            let kinsokuIterations = 0;
            const MAX_ITERATIONS = 50;

            while (kinsokuChanged && kinsokuIterations < MAX_ITERATIONS) {
                kinsokuChanged = false;
                kinsokuIterations++;

                for (let i = 0; i < roughLines.length - 1; i++) {
                    const thisLine = roughLines[i];
                    const nextLine = roughLines[i + 1];

                    const last = thisLine[thisLine.length - 1];
                    const thisEndsWithNewline = last && last.type === 'newline';

                    // è¡Œé ­ç¦å‰‡
                    let gyotoLoopCount = 0;
                    while (gyotoLoopCount < 30) {
                        gyotoLoopCount++;
                        const head = findFirstRenderableToken(nextLine);
                        if (!head || !GYOTO_KINSOKU.includes(head.char)) break;
                        if (thisEndsWithNewline) break;

                        const moved1 = removeLastRenderableToken(thisLine, { excludeIndent: true });
                        if (!moved1) break;

                        // Try to move one more character, but not if it creates a line-end violation
                        const newLastToken = findLastRenderableToken(thisLine);
                        const moved2 = (newLastToken && !GYOMATSU_KINSOKU.includes(newLastToken.char))
                            ? removeLastRenderableToken(thisLine, { excludeIndent: true })
                            : null;

                        // Insert in correct order (the one removed last was first on the line)
                        insertAfterIndents(nextLine, moved1);
                        if (moved2) {
                            insertAfterIndents(nextLine, moved2);
                        }
                        kinsokuChanged = true;

                        // æ¬¡ã®è¡ŒãŒæœ€å¤§æ–‡å­—æ•°ã‚’è¶…ãˆãŸå ´åˆã€ã‚ªãƒ¼ãƒãƒ¼ãƒ•ãƒ­ãƒ¼åˆ†ã‚’ã•ã‚‰ã«æ¬¡ã®è¡Œã¸
                        let overflowLoopCount = 0;
                        while (getLineGlyphCount(nextLine) > maxCells && overflowLoopCount < 30) {
                            overflowLoopCount++;

                            // ã•ã‚‰ã«æ¬¡ã®è¡ŒãŒãªã‘ã‚Œã°ä½œã‚‹
                            if (!roughLines[i + 2]) roughLines[i + 2] = [];

                            // æœ«å°¾ã®æ–‡å­—ã‚’å–å¾—
                            const overflow = removeLastRenderableToken(nextLine, { excludeIndent: true });
                            if (!overflow) break;

                            // ã‚ªãƒ¼ãƒãƒ¼ãƒ•ãƒ­ãƒ¼ã™ã‚‹æ–‡å­—ãŒç¦å‰‡æ–‡å­—ã®å ´åˆã€å¿…ãšãã®å‰ã®æ–‡å­—ã‚‚ä¸€ç·’ã«é€ã‚‹
                            if (GYOTO_KINSOKU.includes(overflow.char)) {
                                const beforeKinsoku = removeLastRenderableToken(nextLine, { excludeIndent: true });
                                if (beforeKinsoku) {
                                    // å‰ã®æ–‡å­—ã‚’å…ˆã«é€ã‚‹
                                    insertAfterIndents(roughLines[i + 2], beforeKinsoku);
                                }
                            }

                            // ç¦å‰‡æ–‡å­—ï¼ˆã¾ãŸã¯é€šå¸¸æ–‡å­—ï¼‰ã‚’é€ã‚‹
                            insertAfterIndents(roughLines[i + 2], overflow);
                            kinsokuChanged = true;
                        }
                    }

                    // è¡Œæœ«ç¦å‰‡
                    let gyomatsuLoopCount = 0;
                    while (gyomatsuLoopCount < 30) {
                        gyomatsuLoopCount++;
                        const lastTok = findLastRenderableToken(thisLine);
                        if (!lastTok || !GYOMATSU_KINSOKU.includes(lastTok.char)) break;

                        const moved = removeLastRenderableToken(thisLine, { excludeIndent: false });
                        if (!moved) break;

                        insertAfterIndents(nextLine, moved);
                        kinsokuChanged = true;

                        // æ¬¡ã®è¡ŒãŒæœ€å¤§æ–‡å­—æ•°ã‚’è¶…ãˆãŸå ´åˆã€ã‚ªãƒ¼ãƒãƒ¼ãƒ•ãƒ­ãƒ¼åˆ†ã‚’ã•ã‚‰ã«æ¬¡ã®è¡Œã¸
                        let overflowLoopCount2 = 0;
                        while (getLineGlyphCount(nextLine) > maxCells && overflowLoopCount2 < 30) {
                            overflowLoopCount2++;

                            // ã•ã‚‰ã«æ¬¡ã®è¡ŒãŒãªã‘ã‚Œã°ä½œã‚‹
                            if (!roughLines[i + 2]) roughLines[i + 2] = [];

                            // æœ«å°¾ã®æ–‡å­—ã‚’å–å¾—
                            const overflow = removeLastRenderableToken(nextLine, { excludeIndent: true });
                            if (!overflow) break;

                            // ã‚ªãƒ¼ãƒãƒ¼ãƒ•ãƒ­ãƒ¼ã™ã‚‹æ–‡å­—ãŒç¦å‰‡æ–‡å­—ã®å ´åˆã€å¿…ãšãã®å‰ã®æ–‡å­—ã‚‚ä¸€ç·’ã«é€ã‚‹
                            if (GYOTO_KINSOKU.includes(overflow.char)) {
                                const beforeKinsoku = removeLastRenderableToken(nextLine, { excludeIndent: true });
                                if (beforeKinsoku) {
                                    // å‰ã®æ–‡å­—ã‚’å…ˆã«é€ã‚‹
                                    insertAfterIndents(roughLines[i + 2], beforeKinsoku);
                                }
                            }

                            // ç¦å‰‡æ–‡å­—ï¼ˆã¾ãŸã¯é€šå¸¸æ–‡å­—ï¼‰ã‚’é€ã‚‹
                            insertAfterIndents(roughLines[i + 2], overflow);
                            kinsokuChanged = true;
                        }
                    }
                }
            }

            // â˜…â˜…â˜… ã“ã“ãŒè¿½åŠ ãƒã‚¤ãƒ³ãƒˆ â˜…â˜…â˜…
            // --- 3) æœ€å¤§æ–‡å­—æ•°ã®æœ€çµ‚ä¿è¨¼ ---
            enforceMaxCells(roughLines, maxCells);

            return roughLines.filter(line => line.length > 0);
        }

        // renderElement å´ãŒæ¬²ã—ã„å½¢ã«åˆã‚ã›ã‚‹
        function layoutLines(tokens, charsPerLine) {
            const raw = applyKinsoku(tokens, charsPerLine);
            return raw.map(toks => ({
                tokens: toks,
                usedCells: getLineGlyphCount(toks)
            }));
        }

        // ===== è¡Œã®ã€Œãƒã‚¹é–“è‡ªå‹•èª¿æ•´ã€ã—ã¤ã¤æç”»ï¼ˆâ˜…ç¦å‰‡ã®0.6ã‚ªãƒ•ã‚»ãƒƒãƒˆã¯ç„¡ã—ï¼‰ =====
        function renderLineWithAutoSpacing({
            line,                // { tokens, usedCells }
            lineIndex,           // åˆ—ç•ªå·
            charsPerLine,
            renderCharHeight,
            fontSize,
            pitchX,
            data,
            segGroup,
            segRenderHeight,
        }) {
            const used = line.usedCells;
            if (used <= 0) return; // ãŸã ã— newline-only è¡Œã¯ã“ã“ã‚’é€šã‚‰ãªã„ï¼ˆæ¶ˆè²»ã¯åˆ¥ãƒ­ã‚¸ãƒƒã‚¯ã§ã‚„ã‚‹æƒ³å®šï¼‰

            // ===== å­—é–“èª¿æ•´é‡ =====
            let gapAdjust = 0;
            const gapCount = Math.max(0, used - 1);

            // 1æ–‡å­—ä»¥ä¸‹ã®è¡Œã¯ã€Œå‡ã—ã€ã—ãªã„ï¼ˆè¦‹ãŸç›®ãŒç ´ç¶»ã—ã‚„ã™ã„ï¼‰
            if (used > 1) {
                const ideal = charsPerLine * renderCharHeight;
                const actual = used * renderCharHeight;
                const delta = ideal - actual;
                const gaps = Math.max(1, used - 1);

                gapAdjust = delta / gaps;

                // å®‰å…¨ã‚¬ãƒ¼ãƒ‰ï¼ˆÂ±5%ï¼‰
                const MAX = renderCharHeight * 0.05;
                gapAdjust = Math.max(-MAX, Math.min(MAX, gapAdjust));
            }

            // ===== æç”» =====
            const minY = renderCharHeight / 2;
            const maxY = Math.max(minY, segRenderHeight - renderCharHeight / 2);
            const ratio = charsPerLine > 0 ? used / charsPerLine : 0;
            const shouldEvenSpacing = ratio > 0.8 && gapCount > 0;
            let extraPerGap = 0;
            if (shouldEvenSpacing) {
                const targetSpan = Math.max(0, maxY - minY);
                const usedSpan = gapCount * (renderCharHeight + gapAdjust);
                const extraSpace = Math.max(0, targetSpan - usedSpan);
                extraPerGap = gapCount > 0 ? extraSpace / gapCount : 0;
            }
            let y = minY;

            for (const token of line.tokens) {
                if (token.type === 'newline') continue;

                const columnCenterX =
                    data.width - (fontSize / 2) - (lineIndex * pitchX);

                // åŸºæœ¬ã®Yï¼ˆç¦å‰‡ã‚ªãƒ•ã‚»ãƒƒãƒˆç„¡ã—ï¼‰
                const drawY = Math.min(Math.max(y, minY), maxY);

                // ===== ç¸¦ä¸­æ¨ª =====
                if (token.type === 'tcy') {
                    const chars = String(token.char || '').slice(0, 2).split('');
                    const n = Math.max(1, chars.length);

                    const cellW = fontSize;
                    const slotW = cellW / n;
                    const leftX = columnCenterX - cellW / 2;

                    for (let i = 0; i < n; i++) {
                        const ch = chars[i];
                        const x = leftX + slotW * (i + 0.5);

                        const t = document.createElementNS(SVG_NS, 'text');
                        t.textContent = ch;
                        t.setAttribute('x', x);
                        t.setAttribute('y', drawY);
                        t.setAttribute('font-family', data.fontFamily);
                        t.setAttribute('class', 'ink-fill');
                        t.setAttribute('writing-mode', 'horizontal-tb');
                        t.setAttribute('text-anchor', 'middle');
                        t.setAttribute('dominant-baseline', 'central');
                        t.setAttribute('font-size', renderCharHeight);
                        t.setAttribute('textLength', slotW);
                        t.setAttribute('lengthAdjust', 'spacingAndGlyphs');
                        segGroup.appendChild(t);
                    }

                    y += renderCharHeight + gapAdjust;
                    continue;
                }

                // ===== é€šå¸¸æ–‡å­—ï¼ˆindentå«ã‚€ï¼‰ =====
                const char = token.char || '';

                // iPadã§å›è»¢ã—ã¦ã—ã¾ã†æ–‡å­—ï¼ˆ90åº¦å›è»¢ãŒå¿…è¦ï¼‰
                const needsRotation = /[ï¼‰\)ï¼½\]ï½\}ã€ã€ã€‘ã€‰ã€‹ã€•â€ºÂ»â€¼â‡âˆâ‰ãƒ¼ï¼âˆ’â€â€‘â€’â€“â€”â€•ã€œï½ãƒ»ï½¥ã‚ =ï¼â€¦â€¥Â°â€²â€³ï¼ˆ\(ï¼»\[ï½›\{ã€Œã€ã€ã€ˆã€Šã€”â€¹Â«]/.test(char);

                // å¥èª­ç‚¹ï¼ˆå³0.3ãƒã‚¹ã€ä¸Š0.8ãƒã‚¹ã«ç§»å‹•ï¼‰
                const isPunctuation = /[ã€ã€‚ï¼Œï¼]/.test(char);

                // ã‚³ãƒ­ãƒ³ãƒ»ã‚»ãƒŸã‚³ãƒ­ãƒ³ï¼ˆå¸¸ã«90åº¦å›è»¢ï¼‰
                const isColon = /[ï¼šï¼›]/.test(char);

                const t = document.createElementNS(SVG_NS, 'text');
                t.textContent = char;
                t.setAttribute('font-family', data.fontFamily);
                t.setAttribute('class', 'ink-fill');
                t.setAttribute('text-anchor', 'middle');
                t.setAttribute('dominant-baseline', 'central');
                t.setAttribute('font-size', fontSize);

                // ç¸¦æ›¸ããƒ¢ãƒ¼ãƒ‰åˆ¤å®š
                const isVertical = (data.writingMode === 'vertical-rl' || !data.writingMode);

                if (isVertical && isColon) {
                    // ã‚³ãƒ­ãƒ³ãƒ»ã‚»ãƒŸã‚³ãƒ­ãƒ³ã¯å¸¸ã«90åº¦å›è»¢
                    t.setAttribute('writing-mode', 'horizontal-tb');
                    t.setAttribute('transform', `rotate(90 ${columnCenterX} ${drawY})`);
                    t.setAttribute('x', columnCenterX);
                    t.setAttribute('y', drawY);
                } else if (STATE.ipadMode && isVertical && isPunctuation) {
                    // å¥èª­ç‚¹ã¯å³0.65ãƒã‚¹ã€ä¸Š0.65ãƒã‚¹ç§»å‹•
                    t.setAttribute('writing-mode', data.writingMode || 'vertical-rl');
                    const offsetX = renderCharHeight * 0.65;
                    const offsetY = -renderCharHeight * 0.65;
                    t.setAttribute('x', columnCenterX + offsetX);
                    t.setAttribute('y', drawY + offsetY);
                    t.style.textOrientation = 'upright';
                } else if (STATE.ipadMode && isVertical && needsRotation) {
                    // iPadãƒ¢ãƒ¼ãƒ‰: å›è»¢ã—ã¦ã„ã‚‹æ–‡å­—ã‚’90åº¦å›è»¢ã§ä¿®æ­£
                    t.setAttribute('writing-mode', 'horizontal-tb');
                    t.setAttribute('transform', `rotate(90 ${columnCenterX} ${drawY})`);
                    t.setAttribute('x', columnCenterX);
                    t.setAttribute('y', drawY);
                } else if (isVertical) {
                    // ãã®ä»–ã®æ–‡å­—ã¯é€šå¸¸é€šã‚Š
                    t.setAttribute('x', columnCenterX);
                    t.setAttribute('y', drawY);
                    t.setAttribute('writing-mode', data.writingMode || 'vertical-rl');
                    t.style.textOrientation = 'upright';
                } else {
                    // é€šå¸¸ãƒ¢ãƒ¼ãƒ‰
                    t.setAttribute('x', columnCenterX);
                    t.setAttribute('y', drawY);
                    t.setAttribute('writing-mode', data.writingMode || 'vertical-rl');

                    // Safari/iOSå¯¾ç­–
                    const allSpecialChars = /[ã€ã€‚ï¼Œï¼ãƒ»ï¼šï¼›ï¼ï¼Ÿï¼ˆï¼‰ã€Œã€ã€ã€ã€ã€‘ã€ˆã€‰ã€Šã€‹ã€”ã€•ï¼»ï¼½ï½›ï½]/.test(char);
                    if (allSpecialChars) {
                        t.style.textOrientation = 'upright';
                    }
                }

                segGroup.appendChild(t);

                y += renderCharHeight + gapAdjust + extraPerGap;
            }
        }


        // --- Helper Snaps ---
        function getColumnIndexAt(rawX) {
            const cGrid = STATE.grid.computed;
            const mr = STATE.canvas.margin.right * PX_PER_MM;
            const w_px = STATE.canvas.width * PX_PER_MM;
            const rightEdge = w_px - mr;
            const center0 = rightEdge - (cGrid.charSizeW / 2);
            return Math.round((center0 - rawX) / cGrid.pitchX);
        }

        function getClosestColumnRightEdge(rawX) {
            const cGrid = STATE.grid.computed;
            const col = getColumnIndexAt(rawX);
            const mr = STATE.canvas.margin.right * PX_PER_MM;
            const w_px = STATE.canvas.width * PX_PER_MM;
            const rightEdge = w_px - mr;
            return rightEdge - (col * cGrid.pitchX);
        }

        function getClosestColumnLeftEdge(rawX) {
            const cGrid = STATE.grid.computed;
            return getClosestColumnRightEdge(rawX) - cGrid.charSizeW;
        }

        // å·¦å³ã©ã¡ã‚‰ã‹è¿‘ã„æ–¹ã®åˆ—ã‚°ãƒªãƒƒãƒ‰ç·šã‚’å–å¾—
        function getClosestColumnGridLine(rawX) {
            const cGrid = STATE.grid.computed;
            const col = getColumnIndexAt(rawX);
            const mr = STATE.canvas.margin.right * PX_PER_MM;
            const w_px = STATE.canvas.width * PX_PER_MM;
            const rightEdgeBase = w_px - mr;
            const rEdge = rightEdgeBase - (col * cGrid.pitchX);
            const lEdge = rEdge - cGrid.charSizeW;
            return Math.abs(rawX - rEdge) < Math.abs(rawX - lEdge) ? rEdge : lEdge;
        }

        // ãƒ‰ãƒ©ãƒƒã‚°é€²è¡Œæ–¹å‘ã«ã‚ã‚‹ã€æœ€ã‚‚è¿‘ã„æœ‰åŠ¹ãªåˆ—å¢ƒç•Œç·šã‚’å–å¾—
        function getSnapEdgeX(rawX, diffX) {
            const cGrid = STATE.grid.computed;
            // ... (snap logic used implicitly in resize)
            return getClosestColumnLeftEdge(rawX); // Simplified
        }

        // --- Gapå›é¿ã‚¹ãƒŠãƒƒãƒ—é–¢æ•° (New) ---
        function snapY_StrictGap(rawY) {
            const cGrid = STATE.grid.computed;
            if (!cGrid.danHeight || cGrid.charSizeH <= 0) return rawY;

            const mt = STATE.canvas.margin.top * PX_PER_MM;
            const relY = rawY - mt;

            // ã©ã®æ®µã®ã‚¨ãƒªã‚¢ã«ã„ã‚‹ã‹ï¼ˆGapå«ã‚€ï¼‰
            const danPitch = cGrid.danPitch;
            const danIndex = Math.floor(relY / danPitch);
            const offsetInDan = relY % danPitch; // æ®µTopã‹ã‚‰ã®è·é›¢

            // ç¯„å›²å¤–ï¼ˆä¸Šç«¯ã‚ˆã‚Šä¸Šã€æœ€çµ‚æ®µã‚ˆã‚Šä¸‹ï¼‰ã®ã‚¬ãƒ¼ãƒ‰
            if (danIndex < 0) return mt;
            if (danIndex >= STATE.grid.dan) return mt + (STATE.grid.dan * danPitch) - (danPitch - cGrid.danHeight);

            // Gapåˆ¤å®š
            if (offsetInDan > cGrid.danHeight) {
                // Gapã®ä¸­ã«ã„ã‚‹ -> æ¬¡ã®æ®µã®ä¸Šç«¯ã«ã‚¹ãƒŠãƒƒãƒ—
                return mt + ((danIndex + 1) * danPitch);
            } else {
                // æ®µã®ä¸­ã«ã„ã‚‹ -> ã“ã®æ®µã®ä¸Šç«¯ã«ã‚¹ãƒŠãƒƒãƒ—
                return mt + (danIndex * danPitch);
            }
        }

        // ä¸‹ç«¯ãƒªã‚µã‚¤ã‚ºç”¨: æ®µã®ä¸‹ç«¯ã«ã‚¹ãƒŠãƒƒãƒ—
        function snapY_StrictGap_Bottom(rawY) {
            const cGrid = STATE.grid.computed;
            if (!cGrid.danHeight || cGrid.charSizeH <= 0) return rawY;

            const mt = STATE.canvas.margin.top * PX_PER_MM;
            const relY = rawY - mt;

            // ã©ã®æ®µã®ã‚¨ãƒªã‚¢ã«ã„ã‚‹ã‹ï¼ˆGapå«ã‚€ï¼‰
            const danPitch = cGrid.danPitch;
            const danIndex = Math.floor(relY / danPitch);
            const offsetInDan = relY % danPitch; // æ®µTopã‹ã‚‰ã®è·é›¢

            // ç¯„å›²å¤–ï¼ˆä¸Šç«¯ã‚ˆã‚Šä¸Šã€æœ€çµ‚æ®µã‚ˆã‚Šä¸‹ï¼‰ã®ã‚¬ãƒ¼ãƒ‰
            if (danIndex < 0) return mt;
            if (danIndex >= STATE.grid.dan) return mt + (STATE.grid.dan * danPitch) - (danPitch - cGrid.danHeight);

            // Gapåˆ¤å®š
            if (offsetInDan > cGrid.danHeight) {
                // Gapã®ä¸­ã«ã„ã‚‹ -> æ¬¡ã®æ®µã®ä¸‹ç«¯ã«ã‚¹ãƒŠãƒƒãƒ—
                return mt + ((danIndex + 1) * danPitch) + cGrid.danHeight;
            } else {
                // æ®µã®ä¸­ã«ã„ã‚‹ -> ã“ã®æ®µã®ä¸‹ç«¯ã«ã‚¹ãƒŠãƒƒãƒ—
                return mt + (danIndex * danPitch) + cGrid.danHeight;
            }
        }

        function snapY(rawY, isTopEdge) {
            const cGrid = STATE.grid.computed; if (cGrid.charSizeH <= 0) return rawY;
            const mt = STATE.canvas.margin.top * PX_PER_MM; const relY = rawY - mt;
            const danIndex = Math.floor(relY / cGrid.danPitch); const danStart = mt + (danIndex * cGrid.danPitch);
            const charIndex = Math.round((rawY - danStart) / cGrid.charSizeH);
            return danStart + (charIndex * cGrid.charSizeH);
        }

        function snapY_Dan(rawY) { return snapY_DanTop(rawY); }

        function snapY_DanTop(rawY) {
            const cGrid = STATE.grid.computed;
            if (!cGrid.danHeight) return rawY;
            const mt = STATE.canvas.margin.top * PX_PER_MM;
            let candidates = [];
            for (let i = 0; i < STATE.grid.dan; i++) {
                candidates.push(mt + (i * cGrid.danPitch));
            }
            return candidates.reduce((prev, curr) => Math.abs(curr - rawY) < Math.abs(prev - rawY) ? curr : prev);
        }

        function snapY_DanBottom(rawY) {
            const cGrid = STATE.grid.computed;
            if (!cGrid.danHeight) return rawY;
            const mt = STATE.canvas.margin.top * PX_PER_MM;
            let candidates = [];
            for (let i = 0; i < STATE.grid.dan; i++) {
                candidates.push(mt + (i * cGrid.danPitch) + cGrid.danHeight);
            }
            return candidates.reduce((prev, curr) => Math.abs(curr - rawY) < Math.abs(prev - rawY) ? curr : prev);
        }

        // --- Touch (Pinch Zoom) ---
        function onTouchStart(e) {
            if (e.touches.length === 2) {
                e.preventDefault(); STATE.activePointerId = null; STATE.interactionType = null;
                const dx = e.touches[0].clientX - e.touches[1].clientX;
                const dy = e.touches[0].clientY - e.touches[1].clientY;
                STATE.touchStartDist = Math.sqrt(dx * dx + dy * dy);
                const cx = (e.touches[0].clientX + e.touches[1].clientX) / 2;
                const cy = (e.touches[0].clientY + e.touches[1].clientY) / 2;
                STATE.viewStart = { ...STATE.view };
                const rect = viewport.getBoundingClientRect();
                const vx = cx - rect.left; const vy = cy - rect.top;
                STATE.pinchStartCanvas = { x: (vx - STATE.viewStart.x) / STATE.viewStart.scale, y: (vy - STATE.viewStart.y) / STATE.viewStart.scale };
            }
        }
        function onTouchMove(e) {
            if (e.touches.length === 2 && STATE.touchStartDist > 0) {
                e.preventDefault();
                const dx = e.touches[0].clientX - e.touches[1].clientX;
                const dy = e.touches[0].clientY - e.touches[1].clientY;
                const zoomFactor = Math.sqrt(dx * dx + dy * dy) / STATE.touchStartDist;
                let newScale = Math.max(0.1, Math.min(STATE.viewStart.scale * zoomFactor, 10.0));
                const rect = viewport.getBoundingClientRect();
                const cx = (e.touches[0].clientX + e.touches[1].clientX) / 2;
                const cy = (e.touches[0].clientY + e.touches[1].clientY) / 2;
                const vx = cx - rect.left; const vy = cy - rect.top;
                STATE.view.scale = newScale;
                STATE.view.x = vx - (STATE.pinchStartCanvas.x * newScale);
                STATE.view.y = vy - (STATE.pinchStartCanvas.y * newScale);
                updateTransform();
            }
        }
        function onTouchEnd(e) { if (e.touches.length < 2) STATE.touchStartDist = 0; }
        function onWheel(e) {
            e.preventDefault();
            if (e.altKey || e.ctrlKey) {
                const delta = -Math.sign(e.deltaY);
                let newScale = Math.max(0.1, Math.min(STATE.view.scale * (1 + delta * 0.05), 10.0));
                const rect = viewport.getBoundingClientRect();
                const mouseX = e.clientX - rect.left; const mouseY = e.clientY - rect.top;
                STATE.view.x = mouseX - (mouseX - STATE.view.x) * (newScale / STATE.view.scale);
                STATE.view.y = mouseY - (mouseY - STATE.view.y) * (newScale / STATE.view.scale);
                STATE.view.scale = newScale;
            } else { STATE.view.x -= e.deltaX; STATE.view.y -= e.deltaY; }
            updateTransform();
        }

        // --- Core Logic ---
        function setMode(mode) {
            STATE.mode = mode;
            document.querySelectorAll('.tool-btn').forEach(b => b.classList.remove('active'));
            if (mode === 'select') document.getElementById('btn-select').classList.add('active');
            if (mode === 'hand') document.getElementById('btn-hand').classList.add('active');
            if (mode === 'text') document.getElementById('btn-text').classList.add('active');
            if (mode === 'heading') document.getElementById('btn-heading').classList.add('active');
            if (mode === 'masthead') document.getElementById('btn-masthead').classList.add('active');
            if (mode === 'rect') document.getElementById('btn-rect').classList.add('active');
            if (mode === 'vline') document.getElementById('btn-vline').classList.add('active');
            if (mode === 'image') document.getElementById('btn-image').classList.add('active');
            if (mode === 'freetext') document.getElementById('btn-freetext').classList.add('active');

            viewport.className = 'viewport';
            // ãƒ¢ãƒ¼ãƒ‰åˆ¥ã®ã‚¯ãƒ©ã‚¹ä»˜ä¸
            if (mode === 'select') viewport.classList.add('mode-select');
            else if (mode === 'hand') viewport.classList.add('mode-hand');
            else viewport.classList.add('mode-create');
        }

        function updateSnapMode() {
            const cbNone = document.getElementById('inp-snap-article');
            const cbText = document.getElementById('inp-snap-article-txt');

            // é¸æŠä¸­ã®è¨˜äº‹ãƒœãƒƒã‚¯ã‚¹ãŒã‚ã‚‹å ´åˆã¯ã€ãã®ãƒœãƒƒã‚¯ã‚¹ã®snapModeã‚’æ›´æ–°
            if (STATE.selectedId) {
                const data = STATE.elements.find(el => el.id === STATE.selectedId);
                if (data && data.type === 'text') {
                    if (document.activeElement === cbText) {
                        data.snapMode = cbText.checked;
                        cbNone.checked = cbText.checked; // åŒæœŸ
                        STATE.articleSnapMode = cbText.checked; // ã‚°ãƒ­ãƒ¼ãƒãƒ«ã‚‚æ›´æ–°
                    }

                    // é¸æŠä¸­ã®ãƒœãƒƒã‚¯ã‚¹ã®ãƒã‚§ãƒ¼ãƒ³ã‚’å†è¨ˆç®—
                    const head = findChainHead(data);
                    updateTextChain(head);
                    renderUi();
                    return;
                }
            }

            // é¸æŠä¸­ã®ãƒœãƒƒã‚¯ã‚¹ãŒãªã„å ´åˆã¯ã€ã‚°ãƒ­ãƒ¼ãƒãƒ«è¨­å®šã®ã¿æ›´æ–°
            if (document.activeElement === cbNone) {
                STATE.articleSnapMode = cbNone.checked;
                cbText.checked = STATE.articleSnapMode;
            } else if (document.activeElement === cbText) {
                STATE.articleSnapMode = cbText.checked;
                cbNone.checked = STATE.articleSnapMode;
            } else {
                STATE.articleSnapMode = cbNone.checked;
            }
        }

        function createObjectFromRect(rect) {
            const id = 'el_' + Math.random().toString(36).substr(2, 9);
            const cGrid = STATE.grid.computed;
            const initFontSize = cGrid.charSizeW > 0 ? cGrid.charSizeW : 24;
            const initLineHeight = cGrid.charSizeW > 0 ? (cGrid.lineGap / cGrid.charSizeW) + 1 : 1.5;
            let data;

            if (STATE.mode === 'text') {
                data = {
                    id, type: 'text', x: rect.x, y: rect.y, width: rect.w, height: rect.h,
                    text: "æ–°è¦è¨˜äº‹", fontSize: initFontSize, lineHeight: initLineHeight,
                    writingMode: 'vertical-rl', fontFamily: '"BIZ UDMincho", serif', charScale: 85, showGrid: false,
                    snapMode: STATE.articleSnapMode // å€‹åˆ¥ã®è¨˜äº‹é…ç½®ãƒ¢ãƒ¼ãƒ‰è¨­å®š
                };
            } else if (STATE.mode === 'heading') {
                data = {
                    id, type: 'heading', x: rect.x, y: rect.y, width: rect.w, height: rect.h,
                    text: "è¦‹å‡ºã—", paddingV: 5, paddingH: 5, fontFamily: '"Noto Sans JP", sans-serif',
                    inverted: false,
                    textStrokeWidth: 2
                };
            } else if (STATE.mode === 'masthead') {
                data = {
                    id, type: 'masthead', x: rect.x, y: rect.y, width: rect.w, height: rect.h,
                    text: "ç©ºæƒ³æ–°è", fontFamily: '"Noto Serif JP", serif',
                    borderWidthOuter: 1.0, borderWidthInner: 0.3, patternLineHeight: 0.4,
                    paddingH: 0, paddingV: 0, textStrokeWidth: 2, inverted: false
                };
            } else if (STATE.mode === 'image') {
                data = {
                    id, type: 'image', x: rect.x, y: rect.y, width: rect.w, height: rect.h,
                    imageUrl: null,
                    imageScale: 1.0,
                    imageOffsetX: 0,
                    imageOffsetY: 0,
                    colorMode: 'fullcolor',
                    contrast: 100,
                    brightness: 100
                };
            } else if (STATE.mode === 'freetext') {
                data = {
                    id, type: 'freetext', x: rect.x, y: rect.y, width: rect.w, height: rect.h,
                    text: "è‡ªç”±ãƒ†ã‚­ã‚¹ãƒˆ",
                    direction: 'vertical',
                    align: 'top-left',
                    fontFamily: '"BIZ UDMincho", serif',
                    fontSize: 4,
                    fontWeight: 400,
                    colorSource: 'ink'
                };
            } else if (STATE.mode === 'vline') {
                data = {
                    id, type: 'vline', x: rect.x, y: rect.y, width: rect.w, height: rect.h,
                    lineWidth: 0.5
                };
            } else {
                data = {
                    id, type: 'rect', x: rect.x, y: rect.y, width: rect.w, height: rect.h,
                    fillMode: 'paper',
                    borderStyle: 'none',
                    borderWidth: 0.5
                };
            }
            STATE.elements.push(data);
            renderElement(data);
            selectElement(id);
            saveHistory();
        }

        function updateElementTransform(data) {
            const group = document.getElementById(data.id);
            if (!group) return;

            let trans = `translate(${data.x}, ${data.y})`;
            if (data.type === 'text') {
                const scaleVal = (data.charScale || 85) / 100;
                trans += (data.writingMode === 'vertical-rl') ? ` scale(1, ${scaleVal})` : ` scale(${scaleVal}, 1)`;
            }
            if (data.type === 'heading' || data.type === 'masthead') {
                renderElement(data);
                return;
            }
            group.setAttribute('transform', trans);
            const hitRect = group.querySelector('.hit-rect');
            if (hitRect) {
                let effW = data.width; let effH = data.height;
                if (data.type === 'text' && data.writingMode === 'vertical-rl') effH = data.height / ((data.charScale || 85) / 100);
                hitRect.setAttribute('width', effW); hitRect.setAttribute('height', effH);
            }
        }

        function computeImageCoverLayout(data) {
            const boxAspect = data.width > 0 && data.height > 0 ? data.width / data.height : 1;
            const imgAspect = data._imageAspect || 1;
            let baseW, baseH;
            let baseX = 0;
            let baseY = 0;

            if (imgAspect > boxAspect) {
                baseH = data.height;
                baseW = baseH * imgAspect;
                baseX = (data.width - baseW) / 2;
            } else {
                baseW = data.width;
                baseH = baseW / imgAspect;
                baseY = (data.height - baseH) / 2;
            }

            return { baseW, baseH, baseX, baseY };
        }

        function renderElement(data) {
            let group = document.getElementById(data.id);
            if (!group) {
                group = document.createElementNS(SVG_NS, 'g');
                group.id = data.id;
                layerContent.appendChild(group);
            }
            group.innerHTML = '';

            // ============================
            // TEXTï¼ˆè¨˜äº‹ï¼‰
            // ============================
            if (data.type === 'text') {
                const scaleVal = (data.charScale || 85) / 100;

                // transform
                let trans = `translate(${data.x}, ${data.y})`;
                trans += (data.writingMode === 'vertical-rl')
                    ? ` scale(1, ${scaleVal})`
                    : ` scale(${scaleVal}, 1)`;
                group.setAttribute('transform', trans);

                // ãƒã‚§ãƒ¼ãƒ³å¯¾å¿œã®æœ¬æ–‡
                const contentToRender =
                    (data.prev !== undefined && data.prev !== null)
                        ? (data._renderedText || '')
                        : (data._renderedText !== undefined ? data._renderedText : (data.text || ''));

                // æ®µï¼ˆã‚»ã‚°ãƒ¡ãƒ³ãƒˆï¼‰
                const useSnapMode =
                    (data.snapMode !== undefined) ? data.snapMode : STATE.articleSnapMode;
                const segments = useSnapMode
                    ? getIntersectingDans(data)
                    : [{ height: data.height, localY: 0 }];

                let charCursor = 0;
                const gap =
                    (STATE.grid.computed.lineGap && STATE.grid.computed.lineGap > 0)
                        ? STATE.grid.computed.lineGap
                        : 5;

                for (const seg of segments) {
                    if (charCursor >= contentToRender.length) break;

                    let segRenderHeight = seg.height;
                    if (data.writingMode === 'vertical-rl') {
                        segRenderHeight = seg.height / scaleVal;
                    }

                    const segGroup = document.createElementNS(SVG_NS, 'g');
                    segGroup.setAttribute(
                        'transform',
                        `translate(0, ${seg.localY / scaleVal})`
                    );

                    // èƒŒæ™¯ï¼ˆå·¦å³ã«è¡Œé–“å¹…ã®ç´™è‰²èƒŒæ™¯ï¼‰- Free modeã®ã¿
                    if (!useSnapMode) {
                        const bg = document.createElementNS(SVG_NS, 'rect');
                        bg.setAttribute('x', -gap);
                        bg.setAttribute('y', 0);
                        bg.setAttribute('width', data.width + gap * 2);
                        bg.setAttribute('height', segRenderHeight);
                        bg.setAttribute('class', 'paper-fill');
                        segGroup.appendChild(bg);
                    }

                    // hit rectï¼ˆæ å…¨ä½“ã‚’é¸æŠå¯èƒ½ã«ã™ã‚‹ãŸã‚ã€ã‚®ãƒ£ãƒƒãƒ—ã‚’å«ã‚€ï¼‰
                    const hit = document.createElementNS(SVG_NS, 'rect');
                    hit.setAttribute('class', 'hit-rect');
                    hit.setAttribute('x', -gap);
                    hit.setAttribute('y', 0);
                    hit.setAttribute('width', data.width + gap * 2);
                    hit.setAttribute('height', segRenderHeight);
                    segGroup.appendChild(hit);

                    // ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆæƒ…å ±
                    const metrics = getLayoutMetrics(data, seg.height, useSnapMode);
                    const { fontSize, charHeight, pitchX, charsPerLine, maxLines } = metrics;
                    const renderCharHeight = charHeight / scaleVal;

                    const remainingText = contentToRender.substring(charCursor);

                    // æ®µè½åˆ¤å®šï¼ˆãƒã‚§ãƒ¼ãƒ³å…ˆã§ã¯å…ˆé ­å­—ä¸‹ã’ã—ãªã„ï¼‰
                    const isChained = (data.prev !== undefined && data.prev !== null);
                    const paragraphStart =
                        (!isChained && charCursor === 0) ||
                        (charCursor > 0 && contentToRender[charCursor - 1] === '\n');

                    const tokens = tokenizeText(remainingText, { paragraphStart });
                    const lines = layoutLines(tokens, charsPerLine);

                    let consumedRaw = 0;

                    lines.forEach((line, lineIndex) => {
                        if (lineIndex >= maxLines) return;

                        // ==== è¡Œæç”»ï¼ˆå­—é–“è‡ªå‹•èª¿æ•´ã¤ãï¼‰====
                        renderLineWithAutoSpacing({
                            line,
                            lineIndex,
                            charsPerLine,
                            renderCharHeight,
                            fontSize,
                            pitchX,
                            data,
                            segGroup,
                            segRenderHeight,
                        });

                        // ==== æ¶ˆè²»æ–‡å­—æ•°ã‚«ã‚¦ãƒ³ãƒˆï¼ˆè«–ç†ï¼‰====
                        for (const token of line.tokens) {
                            if (token.type === 'newline') {
                                consumedRaw += 1;
                            } else if (token.type === 'tcy') {
                                consumedRaw += token.rawLength ?? String(token.char || '').length;
                            } else if (!token.isLineIndent) {
                                consumedRaw += token.rawLength ?? 1;
                            }
                        }
                    });

                    // â˜…ã“ã®ã‚»ã‚°ãƒ¡ãƒ³ãƒˆã§æ¶ˆè²»ã—ãŸåˆ†ã ã‘é€²ã‚ã‚‹
                    charCursor += consumedRaw;

                    group.appendChild(segGroup);
                }

                // å…¨ä½“ã‚’ã‚«ãƒãƒ¼ã™ã‚‹hit-rectï¼ˆå·¦å³ã«ã‚®ãƒ£ãƒƒãƒ—ã‚’å«ã‚€ï¼‰
                const overallHit = document.createElementNS(SVG_NS, 'rect');
                overallHit.setAttribute('class', 'hit-rect');
                overallHit.setAttribute('x', -gap);
                overallHit.setAttribute('y', 0);
                overallHit.setAttribute('width', data.width + gap * 2);
                overallHit.setAttribute('height', data.height);
                group.appendChild(overallHit);

                return;
            }

            // ============================
            // HEADINGï¼ˆè¦‹å‡ºã—ï¼‰
            // ============================
            if (data.type === 'heading') {
                group.setAttribute('transform', `translate(${data.x}, ${data.y})`);

                const gap = (STATE.grid.computed.lineGap && STATE.grid.computed.lineGap > 0) ? STATE.grid.computed.lineGap : 5;
                const shadowRect = document.createElementNS(SVG_NS, 'rect');
                shadowRect.setAttribute('x', -gap);
                shadowRect.setAttribute('y', 0);
                shadowRect.setAttribute('width', data.width + gap * 2);
                shadowRect.setAttribute('height', data.height);
                shadowRect.setAttribute('class', 'paper-fill');
                group.appendChild(shadowRect);

                const bgRect = document.createElementNS(SVG_NS, 'rect');
                bgRect.setAttribute('x', 0); bgRect.setAttribute('y', 0);
                bgRect.setAttribute('width', data.width); bgRect.setAttribute('height', data.height);
                bgRect.setAttribute('class', data.inverted ? 'ink-fill' : 'paper-fill');
                group.appendChild(bgRect);

                const isVertical = data.height > data.width;
                const glyphs = getGlyphsWithTcy(data.text || '');
                const glyphCount = glyphs.length;
                const content = getHeadingContentBounds(data);

                if (content.width > 0 && content.height > 0 && glyphCount > 0) {
                    const columns = isVertical ? 1 : glyphCount;
                    const rows = isVertical ? glyphCount : 1;
                    const cellWidth = columns > 0 ? content.width / columns : content.width;
                    const cellHeight = rows > 0 ? content.height / rows : content.height;

                    const baseFontSize = Math.min(cellWidth, cellHeight) * 0.9;
                    const scaleX = (cellWidth * 0.9) / baseFontSize;
                    const scaleY = (cellHeight * 0.9) / baseFontSize;

                    for (let idx = 0; idx < glyphCount; idx++) {
                        const glyph = glyphs[idx];
                        const cellX = content.offsetX + (isVertical ? 0 : idx * cellWidth);
                        const cellY = content.offsetY + (isVertical ? idx * cellHeight : 0);
                        const centerX = cellX + cellWidth / 2;
                        const centerY = cellY + cellHeight / 2;

                        const verticalOffset = -baseFontSize * 0.075;
                        const adjustedY = isVertical ? centerY : centerY + verticalOffset;

                        const textEl = document.createElementNS(SVG_NS, 'text');
                        textEl.textContent = glyph.text;
                        textEl.setAttribute('font-family', data.fontFamily);
                        textEl.setAttribute('font-weight', '900');
                        textEl.setAttribute('font-size', baseFontSize);
                        textEl.setAttribute('x', centerX);
                        textEl.setAttribute('y', adjustedY);
                        textEl.setAttribute('dominant-baseline', 'central');
                        textEl.setAttribute('text-anchor', 'middle');

                        // iPadãƒ¢ãƒ¼ãƒ‰å¯¾å¿œ
                        const char = glyph.text || '';
                        // iPadã§å›è»¢ã—ã¦ã—ã¾ã†æ–‡å­—ï¼ˆ90åº¦å›è»¢ãŒå¿…è¦ï¼‰
                        const needsRotation = /[ï¼‰\)ï¼½\]ï½\}ã€ã€ã€‘ã€‰ã€‹ã€•â€ºÂ»â€¼â‡âˆâ‰ãƒ¼ï¼âˆ’â€â€‘â€’â€“â€”â€•ã€œï½ãƒ»ï½¥ã‚ =ï¼â€¦â€¥Â°â€²â€³ï¼ˆ\(ï¼»\[ï½›\{ã€Œã€ã€ã€ˆã€Šã€”â€¹Â«]/.test(char);
                        // å¥èª­ç‚¹ï¼ˆå³0.3ãƒã‚¹ã€ä¸Š0.8ãƒã‚¹ã«ç§»å‹•ï¼‰
                        const isPunctuation = /[ã€ã€‚ï¼Œï¼]/.test(char);
                        // ã‚³ãƒ­ãƒ³ãƒ»ã‚»ãƒŸã‚³ãƒ­ãƒ³ï¼ˆå¸¸ã«90åº¦å›è»¢ï¼‰
                        const isColon = /[ï¼šï¼›]/.test(char);

                        if (glyph.type === 'tcy' && isVertical) {
                            textEl.setAttribute('writing-mode', 'horizontal-tb');
                        } else if (isVertical && isColon) {
                            // ã‚³ãƒ­ãƒ³ãƒ»ã‚»ãƒŸã‚³ãƒ­ãƒ³ã¯å¸¸ã«90åº¦å›è»¢
                            textEl.setAttribute('writing-mode', 'horizontal-tb');
                            textEl.setAttribute('x', centerX);
                            textEl.setAttribute('y', adjustedY);
                            textEl.setAttribute('transform', `rotate(90 ${centerX} ${adjustedY}) scale(${scaleX}, ${scaleY})`);
                            textEl.setAttribute('transform-origin', `${centerX} ${adjustedY}`);
                        } else if (STATE.ipadMode && isVertical && isPunctuation) {
                            // å¥èª­ç‚¹ã¯å³0.65ãƒã‚¹ã€ä¸Š0.65ãƒã‚¹ç§»å‹•
                            textEl.setAttribute('writing-mode', 'vertical-rl');
                            const offsetX = cellWidth * 0.65 * scaleX;
                            const offsetY = -cellHeight * 0.65 * scaleY;
                            textEl.setAttribute('x', centerX + offsetX);
                            textEl.setAttribute('y', adjustedY + offsetY);
                            textEl.style.textOrientation = 'upright';
                            textEl.setAttribute('transform', `scale(${scaleX}, ${scaleY})`);
                            textEl.setAttribute('transform-origin', `${centerX} ${centerY}`);
                        } else if (STATE.ipadMode && isVertical && needsRotation) {
                            // iPadãƒ¢ãƒ¼ãƒ‰: å›è»¢ã—ã¦ã„ã‚‹æ–‡å­—ã‚’90åº¦å›è»¢ã§ä¿®æ­£
                            textEl.setAttribute('writing-mode', 'horizontal-tb');
                            textEl.setAttribute('x', centerX);
                            textEl.setAttribute('y', adjustedY);
                            textEl.setAttribute('transform', `rotate(90 ${centerX} ${adjustedY}) scale(${scaleX}, ${scaleY})`);
                            textEl.setAttribute('transform-origin', `${centerX} ${adjustedY}`);
                        } else {
                            textEl.setAttribute('writing-mode', isVertical ? 'vertical-rl' : 'horizontal-tb');
                            if (isVertical && glyph.type !== 'tcy') {
                                textEl.style.textOrientation = 'upright';
                            }
                            textEl.setAttribute('transform', `scale(${scaleX}, ${scaleY})`);
                            textEl.setAttribute('transform-origin', `${centerX} ${centerY}`);
                        }
                        textEl.setAttribute('class', data.inverted ? 'paper-fill' : 'ink-fill');
                        const textStrokeWidth = ((data.textStrokeWidth !== undefined ? data.textStrokeWidth : 2)) * PX_PER_MM;
                        if (data.inverted && textStrokeWidth > 0) {
                            textEl.setAttribute('paint-order', 'stroke');
                            const inkColor = STATE.canvas.colors?.ink || '#333333';
                            textEl.setAttribute('stroke', inkColor);
                            textEl.setAttribute('stroke-width', textStrokeWidth);
                        }
                        textEl.style.fontFamily = data.fontFamily;

                        group.appendChild(textEl);
                    }
                }

                const hitRect = document.createElementNS(SVG_NS, 'rect');
                hitRect.setAttribute('class', 'hit-rect');
                hitRect.setAttribute('width', data.width); hitRect.setAttribute('height', data.height);
                group.appendChild(hitRect);
                return;
            }

            // ============================
            // MASTHEADï¼ˆé¡Œå­—ï¼‰
            // ============================
            if (data.type === 'masthead') {
                group.setAttribute('transform', `translate(${data.x}, ${data.y})`);

                const bo = parseFloat(data.borderWidthOuter) * PX_PER_MM;
                const gap = bo;
                const bi = parseFloat(data.borderWidthInner) * PX_PER_MM;
                const pl = parseFloat(data.patternLineHeight) * PX_PER_MM;

                // è¡Œé–“å¹…ã‚’å–å¾—
                const lineGap = (STATE.grid.computed.lineGap && STATE.grid.computed.lineGap > 0) ? STATE.grid.computed.lineGap : 5;

                // èƒŒæ™¯ï¼ˆå·¦å³ã«è¡Œé–“å¹…ã®ç´™è‰²èƒŒæ™¯ï¼‰
                const shadowRect = document.createElementNS(SVG_NS, 'rect');
                shadowRect.setAttribute('x', -lineGap);
                shadowRect.setAttribute('y', 0);
                shadowRect.setAttribute('width', data.width + lineGap * 2);
                shadowRect.setAttribute('height', data.height);
                shadowRect.setAttribute('class', 'paper-fill');
                group.appendChild(shadowRect);

                const bg = document.createElementNS(SVG_NS, 'rect');
                bg.setAttribute('width', data.width);
                bg.setAttribute('height', data.height);
                bg.setAttribute('class', 'paper-fill');
                group.appendChild(bg);

                // å¤–æ 
                const outerRect = document.createElementNS(SVG_NS, 'rect');
                const oOffset = bo / 2;
                outerRect.setAttribute('x', oOffset);
                outerRect.setAttribute('y', oOffset);
                outerRect.setAttribute('width', Math.max(0, data.width - bo));
                outerRect.setAttribute('height', Math.max(0, data.height - bo));
                outerRect.setAttribute('fill', 'none');
                outerRect.setAttribute('class', 'ink-stroke');
                outerRect.setAttribute('stroke-width', bo);
                outerRect.setAttribute('stroke-linejoin', 'miter');
                group.appendChild(outerRect);

                // å†…æ 
                const innerRect = document.createElementNS(SVG_NS, 'rect');
                const iOffset = bo + gap + (bi / 2);
                innerRect.setAttribute('x', iOffset);
                innerRect.setAttribute('y', iOffset);
                innerRect.setAttribute('width', Math.max(0, data.width - iOffset * 2));
                innerRect.setAttribute('height', Math.max(0, data.height - iOffset * 2));
                innerRect.setAttribute('fill', 'none');
                innerRect.setAttribute('class', 'ink-stroke');
                innerRect.setAttribute('stroke-width', bi);
                innerRect.setAttribute('stroke-linejoin', 'round');
                group.appendChild(innerRect);

                // åœ°ç´‹ãƒ‘ã‚¿ãƒ¼ãƒ³ï¼ˆæ°´å¹³ç·šï¼‰
                const patternId = 'pat-' + data.id;
                const patternSize = pl * 4; // ç·šã®å¤ªã• + é–“éš”(ç·šã®3å€) = 4å€

                let defs = mainSvg.querySelector('defs');
                if (!defs) {
                    defs = document.createElementNS(SVG_NS, 'defs');
                    mainSvg.insertBefore(defs, mainSvg.firstChild);
                }
                let pattern = document.getElementById(patternId);
                if (pattern) pattern.remove();

                pattern = document.createElementNS(SVG_NS, 'pattern');
                pattern.setAttribute('id', patternId);
                pattern.setAttribute('patternUnits', 'userSpaceOnUse');
                pattern.setAttribute('width', patternSize);
                pattern.setAttribute('height', patternSize);

                // æ°´å¹³ç·š
                const line = document.createElementNS(SVG_NS, 'line');
                line.setAttribute('x1', 0);
                line.setAttribute('y1', pl / 2);
                line.setAttribute('x2', patternSize);
                line.setAttribute('y2', pl / 2);
                line.setAttribute('class', 'ink-stroke');
                line.setAttribute('stroke-width', pl);
                pattern.appendChild(line);
                defs.appendChild(pattern);

                // åœ°ç´‹é ˜åŸŸ
                const fillRect = document.createElementNS(SVG_NS, 'rect');
                const fillOffset = bo + gap + bi + gap;
                fillRect.setAttribute('x', fillOffset);
                fillRect.setAttribute('y', fillOffset);
                fillRect.setAttribute('width', Math.max(0, data.width - fillOffset * 2));
                fillRect.setAttribute('height', Math.max(0, data.height - fillOffset * 2));
                fillRect.setAttribute('fill', `url(#${patternId})`);
                group.appendChild(fillRect);

                // ãƒ†ã‚­ã‚¹ãƒˆæç”»ï¼ˆè¦‹å‡ºã—ã¨åŒæ§˜ã«1æ–‡å­—ãšã¤ã‚»ãƒ«åˆ†å‰²ï¼‰
                const isVertical = data.height > data.width;
                const glyphs = getGlyphsWithTcy(data.text || '');
                const glyphCount = glyphs.length;

                // ãƒ†ã‚­ã‚¹ãƒˆæç”»é ˜åŸŸã‚’è¨ˆç®—ï¼ˆæ ã¨ãƒ‘ãƒ‡ã‚£ãƒ³ã‚°ã‚’è€ƒæ…®ï¼‰
                const textPadding = fillOffset + gap * 2;
                const contentWidth = Math.max(0, data.width - textPadding * 2);
                const contentHeight = Math.max(0, data.height - textPadding * 2);
                const contentOffsetX = textPadding;
                const contentOffsetY = textPadding;

                if (contentWidth > 0 && contentHeight > 0 && glyphCount > 0) {
                    const columns = isVertical ? 1 : glyphCount;
                    const rows = isVertical ? glyphCount : 1;
                    const cellWidth = columns > 0 ? contentWidth / columns : contentWidth;
                    const cellHeight = rows > 0 ? contentHeight / rows : contentHeight;

                    const baseFontSize = Math.min(cellWidth, cellHeight) * 0.9;
                    const scaleX = (cellWidth * 0.9) / baseFontSize;
                    const scaleY = (cellHeight * 0.9) / baseFontSize;

                    for (let idx = 0; idx < glyphCount; idx++) {
                        const glyph = glyphs[idx];
                        const cellX = contentOffsetX + (isVertical ? 0 : idx * cellWidth);
                        const cellY = contentOffsetY + (isVertical ? idx * cellHeight : 0);
                        const centerX = cellX + cellWidth / 2;
                        const centerY = cellY + cellHeight / 2;

                        const verticalOffset = -baseFontSize * 0.075;
                        const adjustedY = isVertical ? centerY : centerY + verticalOffset;

                        const textEl = document.createElementNS(SVG_NS, 'text');
                        textEl.textContent = glyph.text;
                        textEl.setAttribute('font-family', data.fontFamily);
                        textEl.setAttribute('font-weight', '900');
                        textEl.setAttribute('font-size', baseFontSize);
                        textEl.setAttribute('x', centerX);
                        textEl.setAttribute('y', adjustedY);
                        textEl.setAttribute('dominant-baseline', 'central');
                        textEl.setAttribute('text-anchor', 'middle');

                        // iPadãƒ¢ãƒ¼ãƒ‰å¯¾å¿œ
                        const char = glyph.text || '';
                        // iPadã§å›è»¢ã—ã¦ã—ã¾ã†æ–‡å­—ï¼ˆ90åº¦å›è»¢ãŒå¿…è¦ï¼‰
                        const needsRotation = /[ï¼‰\)ï¼½\]ï½\}ã€ã€ã€‘ã€‰ã€‹ã€•â€ºÂ»â€¼â‡âˆâ‰ãƒ¼ï¼âˆ’â€â€‘â€’â€“â€”â€•ã€œï½ãƒ»ï½¥ã‚ =ï¼â€¦â€¥Â°â€²â€³ï¼ˆ\(ï¼»\[ï½›\{ã€Œã€ã€ã€ˆã€Šã€”â€¹Â«]/.test(char);
                        // å¥èª­ç‚¹ï¼ˆå³0.3ãƒã‚¹ã€ä¸Š0.8ãƒã‚¹ã«ç§»å‹•ï¼‰
                        const isPunctuation = /[ã€ã€‚ï¼Œï¼]/.test(char);
                        // ã‚³ãƒ­ãƒ³ãƒ»ã‚»ãƒŸã‚³ãƒ­ãƒ³ï¼ˆå¸¸ã«90åº¦å›è»¢ï¼‰
                        const isColon = /[ï¼šï¼›]/.test(char);

                        if (glyph.type === 'tcy' && isVertical) {
                            textEl.setAttribute('writing-mode', 'horizontal-tb');
                        } else if (isVertical && isColon) {
                            // ã‚³ãƒ­ãƒ³ãƒ»ã‚»ãƒŸã‚³ãƒ­ãƒ³ã¯å¸¸ã«90åº¦å›è»¢
                            textEl.setAttribute('writing-mode', 'horizontal-tb');
                            textEl.setAttribute('x', centerX);
                            textEl.setAttribute('y', adjustedY);
                            textEl.setAttribute('transform', `rotate(90 ${centerX} ${adjustedY}) scale(${scaleX}, ${scaleY})`);
                            textEl.setAttribute('transform-origin', `${centerX} ${adjustedY}`);
                        } else if (isVertical && isPunctuation) {
                            // å¥èª­ç‚¹ã¯å³0.65ãƒã‚¹ã€ä¸Š0.65ãƒã‚¹ç§»å‹•
                            textEl.setAttribute('writing-mode', 'vertical-rl');
                            const offsetX = cellWidth * 0.65 * scaleX;
                            const offsetY = -cellHeight * 0.65 * scaleY;
                            textEl.setAttribute('x', centerX + offsetX);
                            textEl.setAttribute('y', adjustedY + offsetY);
                            textEl.style.textOrientation = 'upright';
                            textEl.setAttribute('transform', `scale(${scaleX}, ${scaleY})`);
                            textEl.setAttribute('transform-origin', `${centerX} ${centerY}`);
                        } else if (STATE.ipadMode && isVertical && needsRotation) {
                            // iPadãƒ¢ãƒ¼ãƒ‰: å›è»¢ã—ã¦ã„ã‚‹æ–‡å­—ã‚’90åº¦å›è»¢ã§ä¿®æ­£
                            textEl.setAttribute('writing-mode', 'horizontal-tb');
                            textEl.setAttribute('x', centerX);
                            textEl.setAttribute('y', adjustedY);
                            textEl.setAttribute('transform', `rotate(90 ${centerX} ${adjustedY}) scale(${scaleX}, ${scaleY})`);
                            textEl.setAttribute('transform-origin', `${centerX} ${adjustedY}`);
                        } else {
                            textEl.setAttribute('writing-mode', isVertical ? 'vertical-rl' : 'horizontal-tb');
                            if (isVertical && glyph.type !== 'tcy') {
                                textEl.style.textOrientation = 'upright';
                            }
                            textEl.setAttribute('transform', `scale(${scaleX}, ${scaleY})`);
                            textEl.setAttribute('transform-origin', `${centerX} ${centerY}`);
                        }
                        textEl.setAttribute('class', data.inverted ? 'paper-fill' : 'ink-fill');
                        textEl.style.fontFamily = data.fontFamily;

                        // ç™½ãƒ•ãƒï¼ˆinverted=falseã®æ™‚ã®ã¿ï¼‰
                        const textStrokeWidth = (data.textStrokeWidth !== undefined ? data.textStrokeWidth : 2) * PX_PER_MM;
                        if (textStrokeWidth > 0) {
                            textEl.setAttribute('paint-order', 'stroke');
                            if (data.inverted) {
                                const inkColor = STATE.canvas.colors?.ink || '#333333';
                                textEl.setAttribute('stroke', inkColor);
                            } else {
                                textEl.setAttribute('stroke', '#fff');
                            }
                            textEl.setAttribute('stroke-width', textStrokeWidth);
                        }

                        group.appendChild(textEl);
                    }
                }

                // ãƒ’ãƒƒãƒˆé ˜åŸŸ
                const hitRect = document.createElementNS(SVG_NS, 'rect');
                hitRect.setAttribute('class', 'hit-rect');
                hitRect.setAttribute('width', data.width);
                hitRect.setAttribute('height', data.height);
                group.appendChild(hitRect);
                return;
            }

            // ============================
            // RECTï¼ˆå¡—ã‚Šï¼‰
            // ============================
            if (data.type === 'rect') {
                group.setAttribute('transform', `translate(${data.x}, ${data.y})`);

                const isInkFill = data.fillMode === 'ink';
                const borderStyle = data.borderStyle || 'none';
                const borderWidth = (data.borderWidth || 0.5) * PX_PER_MM;

                const lineGap = (STATE.grid.computed.lineGap && STATE.grid.computed.lineGap > 0)
                    ? STATE.grid.computed.lineGap
                    : 5;
                const shadowRect = document.createElementNS(SVG_NS, 'rect');
                shadowRect.setAttribute('x', -lineGap);
                shadowRect.setAttribute('y', 0);
                shadowRect.setAttribute('width', data.width + lineGap * 2);
                shadowRect.setAttribute('height', data.height);
                shadowRect.setAttribute('class', 'paper-fill');
                group.appendChild(shadowRect);

                // å¡—ã‚Šã¤ã¶ã—é¢ï¼ˆãƒœãƒƒã‚¯ã‚¹å…¨ä½“ã‚’è¦†ã†ï¼‰
                const fillRect = document.createElementNS(SVG_NS, 'rect');
                fillRect.setAttribute('x', 0);
                fillRect.setAttribute('y', 0);
                fillRect.setAttribute('width', data.width);
                fillRect.setAttribute('height', data.height);
                if (isInkFill) fillRect.setAttribute('class', 'ink-fill');
                else fillRect.setAttribute('class', 'paper-fill');
                group.appendChild(fillRect);

                // æ ç·šï¼ˆå†…å´ã«æç”»ï¼‰
                if (borderStyle !== 'none') {
                    // ã‚¤ãƒ³ã‚¯è‰²å¡—ã‚Šã¤ã¶ã—ã®å ´åˆã¯1mmå†…å´ã«æ ç·šã‚’é…ç½®
                    const baseInset = isInkFill ? 1 * PX_PER_MM : 0;
                    // æ ç·šã‚’å†…å´ã«æç”»ã™ã‚‹ãŸã‚ã€æ ç·šå¹…ã®åŠåˆ†ã ã‘ã•ã‚‰ã«å†…å´ã«ãšã‚‰ã™
                    const borderInset = borderWidth / 2;
                    const totalInset = baseInset + borderInset;

                    const borderRect = document.createElementNS(SVG_NS, 'rect');
                    borderRect.setAttribute('x', totalInset);
                    borderRect.setAttribute('y', totalInset);
                    borderRect.setAttribute('width', data.width - (totalInset * 2));
                    borderRect.setAttribute('height', data.height - (totalInset * 2));
                    borderRect.setAttribute('fill', 'none');

                    // æ ç·šã®è‰²
                    const inkColor = STATE.canvas.colors.ink || '#333333';
                    const paperColor = STATE.canvas.colors.paper || '#ffffff';
                    const borderStrokeColor = isInkFill ? paperColor : inkColor;
                    borderRect.setAttribute('stroke', borderStrokeColor);
                    borderRect.setAttribute('stroke-width', borderWidth);

                    // æ ç·šã®ã‚¹ã‚¿ã‚¤ãƒ«
                    if (borderStyle === 'dotted') {
                        borderRect.setAttribute('stroke-dasharray', `${borderWidth * 0.5}, ${borderWidth * 1.5}`);
                    } else if (borderStyle === 'double') {
                        borderRect.setAttribute('stroke-dasharray', 'none');
                    } else {
                        // solid
                        borderRect.setAttribute('stroke-dasharray', 'none');
                    }
                    group.appendChild(borderRect);

                    // äºŒé‡ç·šã®å ´åˆã¯å†…å´ã«ã‚‚ã†ä¸€æœ¬ç·šã‚’æç”»
                    if (borderStyle === 'double') {
                        const innerRect = document.createElementNS(SVG_NS, 'rect');
                        const gap = borderWidth * 2; // 2æœ¬ã®ç·šã®é–“éš”
                        const innerInset = totalInset + gap;
                        innerRect.setAttribute('x', innerInset);
                        innerRect.setAttribute('y', innerInset);
                        innerRect.setAttribute('width', data.width - (innerInset * 2));
                        innerRect.setAttribute('height', data.height - (innerInset * 2));
                        innerRect.setAttribute('fill', 'none');
                        innerRect.setAttribute('stroke', borderStrokeColor);
                        innerRect.setAttribute('stroke-width', borderWidth);
                        group.appendChild(innerRect);
                    }
                }

                const hitRect = document.createElementNS(SVG_NS, 'rect');
                hitRect.setAttribute('class', 'hit-rect');
                hitRect.setAttribute('width', data.width);
                hitRect.setAttribute('height', data.height);
                group.appendChild(hitRect);
                return;
            }

            // ============================
            // VLINEï¼ˆç¸¦ç·šï¼‰
            // ============================
            if (data.type === 'vline') {
                group.setAttribute('transform', `translate(${data.x}, ${data.y})`);

                // è¡Œé–“å¹…ã‚’å–å¾—
                const lineGap = (STATE.grid.computed.lineGap && STATE.grid.computed.lineGap > 0) ? STATE.grid.computed.lineGap : 5;

                // èƒŒæ™¯ï¼ˆå·¦å³ã«è¡Œé–“å¹…ã®ç´™è‰²èƒŒæ™¯ï¼‰
                const shadowRect = document.createElementNS(SVG_NS, 'rect');
                shadowRect.setAttribute('x', -lineGap);
                shadowRect.setAttribute('y', 0);
                shadowRect.setAttribute('width', data.width + lineGap * 2);
                shadowRect.setAttribute('height', data.height);
                shadowRect.setAttribute('class', 'paper-fill');
                group.appendChild(shadowRect);

                const line = document.createElementNS(SVG_NS, 'line');
                line.setAttribute('x1', data.width / 2);
                line.setAttribute('y1', 0);
                line.setAttribute('x2', data.width / 2);
                line.setAttribute('y2', data.height);
                line.setAttribute('class', 'ink-stroke');
                line.setAttribute('stroke-width', (data.lineWidth || 0.5) * PX_PER_MM);
                group.appendChild(line);

                const hitRect = document.createElementNS(SVG_NS, 'rect');
                hitRect.setAttribute('x', -lineGap);
                hitRect.setAttribute('y', 0);
                hitRect.setAttribute('width', data.width + lineGap * 2);
                hitRect.setAttribute('height', data.height);
                hitRect.setAttribute('class', 'hit-rect');
                group.appendChild(hitRect);
                return;
            }

            // ============================
            // FREETEXTï¼ˆè‡ªç”±ãƒ†ã‚­ã‚¹ãƒˆï¼‰
            // ============================
            if (data.type === 'freetext') {
                group.setAttribute('transform', `translate(${data.x}, ${data.y})`);

                const hitRect = document.createElementNS(SVG_NS, 'rect');
                hitRect.setAttribute('class', 'hit-rect');
                hitRect.setAttribute('width', data.width);
                hitRect.setAttribute('height', data.height);
                group.appendChild(hitRect);

                const fo = document.createElementNS(SVG_NS, 'foreignObject');
                fo.setAttribute('x', 0);
                fo.setAttribute('y', 0);
                fo.setAttribute('width', data.width);
                fo.setAttribute('height', data.height);
                fo.setAttribute('pointer-events', 'none');

                const div = document.createElement('div');
                div.setAttribute('xmlns', 'http://www.w3.org/1999/xhtml');
                div.style.width = '100%';
                div.style.height = '100%';
                div.style.display = 'flex';
                div.style.padding = '0';
                div.style.margin = '0';
                div.style.whiteSpace = 'pre-wrap';
                div.style.wordBreak = 'break-word';
                div.style.overflow = 'hidden';
                div.style.fontFamily = data.fontFamily || '"BIZ UDMincho", serif';
                div.style.fontSize = `${(data.fontSize || 4) * PX_PER_MM}px`;
                const colorSource = data.colorSource === 'paper' ? 'paper' : 'ink';
                const freetextColor = colorSource === 'paper'
                    ? (STATE.canvas.colors.paper || '#ffffff')
                    : (STATE.canvas.colors.ink || '#333333');
                div.style.color = freetextColor;
                div.style.fontWeight = (data.fontWeight !== undefined ? data.fontWeight : 400).toString();

                const direction = data.direction || 'vertical';
                const align = data.align || 'top-left';
                const [vAlign, hAlign] = align.split('-');

                if (direction === 'vertical') {
                    div.style.writingMode = 'vertical-rl';
                    div.style.textOrientation = 'upright';

                    // ä¸Šä¸‹ (justify-content)
                    const vPosMap = { top: 'flex-start', middle: 'center', bottom: 'flex-end' };
                    div.style.justifyContent = vPosMap[vAlign] || 'flex-start';

                    // å·¦å³ (align-items) - ç¸¦æ›¸ãã§ã¯ flex-end ãŒå·¦æƒãˆã«ãªã‚‹
                    const hPosMap = { left: 'flex-end', center: 'center', right: 'flex-start' };
                    div.style.alignItems = hPosMap[hAlign] || 'flex-start';

                } else { // horizontal
                    div.style.writingMode = 'horizontal-tb';
                    div.style.flexDirection = 'column'; // æ¨ªæ›¸ãã®æ™‚ã ã‘ column ã«ã™ã‚‹
                    div.style.justifyContent = { top: 'flex-start', middle: 'center', bottom: 'flex-end' }[vAlign] || 'flex-start';
                    div.style.alignItems = { left: 'flex-start', center: 'center', right: 'flex-end' }[hAlign] || 'flex-start';
                    div.style.textAlign = { left: 'left', center: 'center', right: 'right' }[hAlign] || 'left';
                }

                div.textContent = data.text || '';
                fo.appendChild(div);
                group.appendChild(fo);
                return;
            }

            // ============================
            // IMAGEï¼ˆç”»åƒï¼‰
            // ============================
            if (data.type === 'image') {
                group.setAttribute('transform', `translate(${data.x}, ${data.y})`);

                // ã‚¯ãƒªãƒƒãƒ—ãƒ‘ã‚¹ã‚’ä½œæˆ
                const clipId = `clip-${data.id}`;
                const defs = document.createElementNS(SVG_NS, 'defs');
                const clipPath = document.createElementNS(SVG_NS, 'clipPath');
                clipPath.setAttribute('id', clipId);
                const clipRect = document.createElementNS(SVG_NS, 'rect');
                clipRect.setAttribute('x', 0);
                clipRect.setAttribute('y', 0);
                clipRect.setAttribute('width', data.width);
                clipRect.setAttribute('height', data.height);
                clipPath.appendChild(clipRect);
                const isCropPreviewActive = STATE.cropMode && STATE.selectedId === data.id;
                let previewMaskId;
                if (isCropPreviewActive) {
                    previewMaskId = `crop-preview-${data.id}`;
                    const previewMask = document.createElementNS(SVG_NS, 'mask');
                    previewMask.setAttribute('id', previewMaskId);
                    previewMask.setAttribute('maskUnits', 'userSpaceOnUse');
                    const outerRect = document.createElementNS(SVG_NS, 'rect');
                    outerRect.setAttribute('x', -1000);
                    outerRect.setAttribute('y', -1000);
                    outerRect.setAttribute('width', data.width + 2000);
                    outerRect.setAttribute('height', data.height + 2000);
                    outerRect.setAttribute('fill', 'white');
                    const innerRect = document.createElementNS(SVG_NS, 'rect');
                    innerRect.setAttribute('x', 0);
                    innerRect.setAttribute('y', 0);
                    innerRect.setAttribute('width', data.width);
                    innerRect.setAttribute('height', data.height);
                    innerRect.setAttribute('fill', 'black');
                    previewMask.appendChild(outerRect);
                    previewMask.appendChild(innerRect);
                    defs.appendChild(previewMask);
                }
                defs.appendChild(clipPath);
                group.appendChild(defs);

                const layout = computeImageCoverLayout(data);
                const scale = data.imageScale || 1.0;
                const offsetX = data.imageOffsetX || 0;
                const offsetY = data.imageOffsetY || 0;
                const imgW = layout.baseW * scale;
                const imgH = layout.baseH * scale;
                const imgX = layout.baseX + (layout.baseW - imgW) / 2 + offsetX;
                const imgY = layout.baseY + (layout.baseH - imgH) / 2 + offsetY;

                if (isCropPreviewActive && data.imageUrl) {
                    const previewImg = document.createElementNS(SVG_NS, 'image');
                    previewImg.setAttributeNS('http://www.w3.org/1999/xlink', 'href', data.imageUrl);
                    previewImg.setAttribute('x', imgX);
                    previewImg.setAttribute('y', imgY);
                    previewImg.setAttribute('width', imgW);
                    previewImg.setAttribute('height', imgH);
                    previewImg.setAttribute('preserveAspectRatio', 'xMidYMid slice');
                    previewImg.setAttribute('opacity', '0.45');
                    previewImg.setAttribute('mask', `url(#${previewMaskId})`);
                    previewImg.setAttribute('pointer-events', 'none');
                    group.appendChild(previewImg);
                }

                const bg = document.createElementNS(SVG_NS, 'rect');
                bg.setAttribute('x', 0);
                bg.setAttribute('y', 0);
                bg.setAttribute('width', data.width);
                bg.setAttribute('height', data.height);
                bg.setAttribute('class', 'paper-fill');
                group.appendChild(bg);

                if (data.imageUrl) {
                    const img = document.createElementNS(SVG_NS, 'image');
                    img.setAttributeNS('http://www.w3.org/1999/xlink', 'href', data.imageUrl);
                    img.setAttribute('x', imgX);
                    img.setAttribute('y', imgY);
                    img.setAttribute('width', imgW);
                    img.setAttribute('height', imgH);
                    img.setAttribute('preserveAspectRatio', 'xMidYMid slice');
                    img.setAttribute('clip-path', `url(#${clipId})`);
                    group.appendChild(img);
                }

                const hitRect = document.createElementNS(SVG_NS, 'rect');
                hitRect.setAttribute('class', 'hit-rect');
                hitRect.setAttribute('width', data.width);
                hitRect.setAttribute('height', data.height);
                group.appendChild(hitRect);
                return;
            }


        }
        // --- Heading Helpers ---
        function getHeadingContentBounds(data) {
            // ãƒœãƒ¼ãƒ€ãƒ¼ã¨ãƒ‘ãƒ‡ã‚£ãƒ³ã‚°ã‚’è€ƒæ…®ã—ãŸæç”»é ˜åŸŸã‚’è¨ˆç®—
            let extraP = 0;
            if (data.type === 'masthead') {
                const bo = parseFloat(data.borderWidthOuter) * PX_PER_MM;
                const gap = bo;
                const bi = parseFloat(data.borderWidthInner) * PX_PER_MM;
                extraP = bo + gap + bi + (2 * PX_PER_MM);
            }

            // ãƒ‘ãƒ‡ã‚£ãƒ³ã‚°ã‚’è¿½åŠ 
            const paddingH = parseFloat(data.paddingH || 0) * PX_PER_MM;
            const paddingV = parseFloat(data.paddingV || 0) * PX_PER_MM;

            const totalOffsetX = extraP + paddingH;
            const totalOffsetY = extraP + paddingV;

            const contentW = Math.max(0, data.width - (totalOffsetX * 2));
            const contentH = Math.max(0, data.height - (totalOffsetY * 2));

            return {
                offsetX: totalOffsetX,
                offsetY: totalOffsetY,
                width: contentW,
                height: contentH
            };
        }

        // --- Border Rendering ---
        function renderBorder() {
            const layerBorder = document.getElementById('layer-border');
            if (!layerBorder) return;
            layerBorder.innerHTML = '';

            const m = STATE.canvas.margin;
            const w = STATE.canvas.width;
            const h = STATE.canvas.height;
            const offset = 3; // mm

            // ç‰ˆé¢ã‚µã‚¤ã‚º
            const contentX = m.left;
            const contentY = m.top;
            const contentW = w - m.left - m.right;
            const contentH = h - m.top - m.bottom;

            // æ ç·šåº§æ¨™ (ç‰ˆé¢ã‹ã‚‰å¤–å´ã¸3mm)
            const x = (contentX - offset) * PX_PER_MM;
            const y = (contentY - offset) * PX_PER_MM;
            const width = (contentW + offset * 2) * PX_PER_MM;
            const height = (contentH + offset * 2) * PX_PER_MM;

            const rect = document.createElementNS(SVG_NS, 'rect');
            rect.setAttribute('x', x);
            rect.setAttribute('y', y);
            rect.setAttribute('width', width);
            rect.setAttribute('height', height);
            rect.setAttribute('fill', 'none');
            rect.setAttribute('class', 'ink-stroke');
            const strokeWidth = 0.4 * PX_PER_MM; // æ ç·šã®å¤ªã•
            rect.setAttribute('stroke-width', strokeWidth);
            rect.setAttribute('stroke-linejoin', 'miter');
            rect.setAttribute('pointer-events', 'none');

            layerBorder.appendChild(rect);

            // --- ãƒ˜ãƒƒãƒ€ãƒ¼ãƒ†ã‚­ã‚¹ãƒˆã®æç”» ---
            renderHeaderTexts();

            // --- ã‚«ãƒ©ãƒ¼ãƒ‘ãƒƒãƒã®æç”» ---
            renderColorPatches();
        }

        function renderColorPatches() {
            const layerBorder = document.getElementById('layer-border');
            if (!layerBorder) return;

            // KWYMCKK ã®è‰²å®šç¾©ï¼ˆKã¯å¸¸æ™‚çœŸã£é»’ï¼‰
            const colors = [
                { name: 'K', color: '#000000' },  // Black (Key) - å¸¸æ™‚çœŸã£é»’
                { name: 'W', color: '#FFFFFF' },  // White
                { name: 'Y', color: '#FFFF00' },  // Yellow
                { name: 'M', color: '#FF00FF' },  // Magenta
                { name: 'C', color: '#00FFFF' },  // Cyan
                { name: 'K', color: '#000000' },  // Black - å¸¸æ™‚çœŸã£é»’
                { name: 'K', color: '#000000' }   // Black - å¸¸æ™‚çœŸã£é»’
            ];

            const patchSize = 1; // mm (ãƒ€ã‚¤ãƒ¤ã®å¯¾è§’ç·š)
            const spacing = 3; // mm
            const offsetBelow = 5; // mm (å¤–æ ä¸‹è¾ºã‹ã‚‰ä¸‹ã«5mm)

            const m = STATE.canvas.margin;
            const w = STATE.canvas.width;
            const h = STATE.canvas.height;
            const offset = 3; // å¤–æ ã®ã‚ªãƒ•ã‚»ãƒƒãƒˆ

            // å¤–æ ã®ä¸‹è¾ºä½ç½®
            const contentX = m.left;
            const contentY = m.top;
            const contentW = w - m.left - m.right;
            const contentH = h - m.top - m.bottom;
            const borderBottom = (contentY + contentH + offset) * PX_PER_MM;

            // ãƒ‘ãƒƒãƒã®ç·å¹…ã‚’è¨ˆç®—
            const totalWidth = (colors.length * patchSize + (colors.length - 1) * spacing);
            const centerX = (w / 2) * PX_PER_MM;
            const startX = centerX - (totalWidth * PX_PER_MM / 2);
            const patchY = borderBottom + (offsetBelow * PX_PER_MM);

            // å„ã‚«ãƒ©ãƒ¼ãƒ‘ãƒƒãƒã‚’æç”»
            colors.forEach((colorDef, index) => {
                const patchX = startX + (index * (patchSize + spacing) * PX_PER_MM);

                // ãƒ€ã‚¤ãƒ¤å½¢ï¼ˆ45åº¦å›è»¢ã—ãŸæ­£æ–¹å½¢ï¼‰
                const diamond = document.createElementNS(SVG_NS, 'rect');
                const size = patchSize * PX_PER_MM;

                diamond.setAttribute('x', patchX);
                diamond.setAttribute('y', patchY);
                diamond.setAttribute('width', size);
                diamond.setAttribute('height', size);
                diamond.setAttribute('fill', colorDef.color);
                diamond.setAttribute('transform', `rotate(45 ${patchX + size / 2} ${patchY + size / 2})`);
                diamond.setAttribute('style', 'mix-blend-mode: multiply;');
                diamond.setAttribute('pointer-events', 'none');

                layerBorder.appendChild(diamond);
            });
        }

        function renderHeaderTexts() {
            const layerBorder = document.getElementById('layer-border');
            if (!layerBorder) return;

            const m = STATE.canvas.margin;
            const w = STATE.canvas.width;
            const contentX = m.left;
            const contentY = m.top;
            const contentW = w - m.left - m.right;

            // ãƒ˜ãƒƒãƒ€ãƒ¼ã®Yä½ç½®ï¼ˆç‰ˆé¢ä¸Šç«¯ã®5mmä¸Šï¼‰
            const headerY = (contentY - 8) * PX_PER_MM;

            // å·¦æƒãˆ
            if (STATE.header.left.text) {
                const textEl = document.createElementNS(SVG_NS, 'text');
                textEl.textContent = STATE.header.left.text;
                textEl.setAttribute('x', contentX * PX_PER_MM);
                textEl.setAttribute('y', headerY);
                textEl.setAttribute('font-family', STATE.header.left.fontFamily);
                textEl.setAttribute('font-size', STATE.header.left.fontSize * PX_PER_MM);
                textEl.setAttribute('font-weight', STATE.header.left.fontWeight);
                textEl.setAttribute('text-anchor', 'start');
                textEl.setAttribute('dominant-baseline', 'middle');
                textEl.setAttribute('class', 'ink-fill');
                textEl.style.fontFamily = STATE.header.left.fontFamily;
                if (STATE.header.left.letterSpacing !== 0) {
                    textEl.setAttribute('letter-spacing', STATE.header.left.letterSpacing * PX_PER_MM);
                }
                const leftLineHeight = STATE.header.left.lineHeight;
                if (leftLineHeight !== undefined && leftLineHeight !== null) {
                    textEl.style.lineHeight = `${leftLineHeight * PX_PER_MM}px`;
                }
                layerBorder.appendChild(textEl);
            }

            // ä¸­å¤®æƒãˆ
            if (STATE.header.center.text) {
                const textEl = document.createElementNS(SVG_NS, 'text');
                textEl.textContent = STATE.header.center.text;
                textEl.setAttribute('x', (contentX + contentW / 2) * PX_PER_MM);
                textEl.setAttribute('y', headerY);
                textEl.setAttribute('font-family', STATE.header.center.fontFamily);
                textEl.setAttribute('font-size', STATE.header.center.fontSize * PX_PER_MM);
                textEl.setAttribute('font-weight', STATE.header.center.fontWeight);
                textEl.setAttribute('text-anchor', 'middle');
                textEl.setAttribute('dominant-baseline', 'middle');
                textEl.setAttribute('class', 'ink-fill');
                textEl.style.fontFamily = STATE.header.center.fontFamily;
                if (STATE.header.center.letterSpacing !== 0) {
                    textEl.setAttribute('letter-spacing', STATE.header.center.letterSpacing * PX_PER_MM);
                }
                const centerLineHeight = STATE.header.center.lineHeight;
                if (centerLineHeight !== undefined && centerLineHeight !== null) {
                    textEl.style.lineHeight = `${centerLineHeight * PX_PER_MM}px`;
                }
                layerBorder.appendChild(textEl);
            }

            // å³æƒãˆ
            if (STATE.header.right.text) {
                const textEl = document.createElementNS(SVG_NS, 'text');
                textEl.textContent = STATE.header.right.text;
                textEl.setAttribute('x', (contentX + contentW) * PX_PER_MM);
                textEl.setAttribute('y', headerY);
                textEl.setAttribute('font-family', STATE.header.right.fontFamily);
                textEl.setAttribute('font-size', STATE.header.right.fontSize * PX_PER_MM);
                textEl.setAttribute('font-weight', STATE.header.right.fontWeight);
                textEl.setAttribute('text-anchor', 'end');
                textEl.setAttribute('dominant-baseline', 'middle');
                textEl.setAttribute('class', 'ink-fill');
                textEl.style.fontFamily = STATE.header.right.fontFamily;
                if (STATE.header.right.letterSpacing !== 0) {
                    textEl.setAttribute('letter-spacing', STATE.header.right.letterSpacing * PX_PER_MM);
                }
                const rightLineHeight = STATE.header.right.lineHeight;
                if (rightLineHeight !== undefined && rightLineHeight !== null) {
                    textEl.style.lineHeight = `${rightLineHeight * PX_PER_MM}px`;
                }
                layerBorder.appendChild(textEl);
            }
        }

        // --- Character Count Info ---
        function calculateMaxCapacity(data) {
            const useSnapMode = data.snapMode !== undefined ? data.snapMode : STATE.articleSnapMode;
            let segments;
            if (useSnapMode) {
                segments = getIntersectingDans(data);
            } else {
                segments = [{ height: data.height, localY: 0 }];
            }

            let totalCapacity = 0;
            for (const seg of segments) {
                const metrics = getLayoutMetrics(data, seg.height, useSnapMode);
                const { charsPerLine, maxLines } = metrics;
                const baseCapacity = charsPerLine * maxLines;
                totalCapacity += baseCapacity;
            }
            return totalCapacity;
        }

        function updateCharInfo(data) {
            if (data.type !== 'text') return;

            const charCurrentEl = document.getElementById('char-current');
            const charCapacityEl = document.getElementById('char-capacity');
            const charOverflowEl = document.getElementById('char-overflow');

            const head = findChainHead(data);
            const fullText = head.text || "";
            const currentCount = fullText.length;

            let totalCapacity = 0;
            let curr = head;
            while (curr) {
                totalCapacity += calculateMaxCapacity(curr);
                curr = curr.next ? STATE.elements.find(el => el.id === curr.next) : null;
            }

            const overflow = Math.max(0, currentCount - totalCapacity);

            charCurrentEl.textContent = currentCount;
            charCapacityEl.textContent = totalCapacity;
            charOverflowEl.textContent = overflow;

            if (overflow > 0) {
                charOverflowEl.style.color = '#f44336';
                charOverflowEl.style.fontWeight = 'bold';
            } else {
                charOverflowEl.style.color = '#666';
                charOverflowEl.style.fontWeight = 'normal';
            }
        }

        // --- UI/Updates ---
        function renderUi() {
            if (STATE.interactionType === 'resize' || STATE.interactionType === 'drag') {
                if (STATE.selectedId) {
                    const data = STATE.elements.find(e => e.id === STATE.selectedId);
                    if (data) updateUiPositions(data);
                }
                return;
            }
            layerUi.innerHTML = ''; renderMarginGuide();
            document.getElementById('prop-panel-none').style.display = 'none';
            document.getElementById('prop-panel-text').style.display = 'none';
            document.getElementById('prop-panel-heading').style.display = 'none';
            document.getElementById('prop-panel-masthead').style.display = 'none';
            document.getElementById('prop-panel-rect').style.display = 'none';
            document.getElementById('prop-panel-image').style.display = 'none';
            document.getElementById('prop-panel-freetext').style.display = 'none';

            if (!STATE.selectedId) { document.getElementById('prop-panel-none').style.display = 'block'; return; }
            const data = STATE.elements.find(e => e.id === STATE.selectedId);
            if (!data) return;

            if (data.type === 'text') {
                document.getElementById('prop-panel-text').style.display = 'block';

                const isChild = (data.prev !== undefined && data.prev !== null);
                const infoEl = document.getElementById('text-link-info');
                const txtArea = document.getElementById('inp-text');

                if (isChild) {
                    infoEl.style.display = 'block';
                    txtArea.disabled = true;
                    txtArea.value = "(ãƒªãƒ³ã‚¯å…ƒã®ãƒ†ã‚­ã‚¹ãƒˆã‚’è¡¨ç¤ºä¸­)";
                } else {
                    infoEl.style.display = 'none';
                    txtArea.disabled = false;
                    if (document.activeElement.id !== 'inp-text') txtArea.value = data.text;
                }

                document.getElementById('inp-fontfamily').value = data.fontFamily;
                document.getElementById('inp-snap-article-txt').checked = data.snapMode !== undefined ? data.snapMode : STATE.articleSnapMode;

                updateCharInfo(data);
            } else if (data.type === 'heading') {
                document.getElementById('prop-panel-heading').style.display = 'block';
                if (document.activeElement.id !== 'inp-heading-text') document.getElementById('inp-heading-text').value = data.text;
                document.getElementById('inp-heading-font').value = data.fontFamily;
                document.getElementById('inp-heading-pv').value = data.paddingV;
                document.getElementById('inp-heading-pv-slider').value = data.paddingV;
                document.getElementById('inp-heading-ph').value = data.paddingH;
                document.getElementById('inp-heading-ph-slider').value = data.paddingH;
                document.getElementById('inp-heading-inverted').checked = data.inverted || false;
            } else if (data.type === 'masthead') {
                document.getElementById('prop-panel-masthead').style.display = 'block';
                if (document.activeElement.id !== 'inp-masthead-text') document.getElementById('inp-masthead-text').value = data.text;
                document.getElementById('inp-masthead-font').value = data.fontFamily;
                document.getElementById('inp-masthead-inverted').checked = data.inverted || false;

                document.getElementById('inp-masthead-bo').value = data.borderWidthOuter;
                document.getElementById('inp-masthead-bo-slider').value = data.borderWidthOuter;

                document.getElementById('inp-masthead-bi').value = data.borderWidthInner;
                document.getElementById('inp-masthead-bi-slider').value = data.borderWidthInner;

                document.getElementById('inp-masthead-pl').value = data.patternLineHeight;
                document.getElementById('inp-masthead-pl-slider').value = data.patternLineHeight;

                document.getElementById('inp-masthead-ph').value = data.paddingH;
                document.getElementById('inp-masthead-ph-slider').value = data.paddingH;

                document.getElementById('inp-masthead-pv').value = data.paddingV;
                document.getElementById('inp-masthead-pv-slider').value = data.paddingV;

                document.getElementById('inp-masthead-ts').value = data.textStrokeWidth;
                document.getElementById('inp-masthead-ts-slider').value = data.textStrokeWidth;
            } else if (data.type === 'rect') {
                document.getElementById('prop-panel-rect').style.display = 'block';
                document.getElementById('inp-rect-ink').checked = (data.fillMode === 'ink');
                document.getElementById('inp-rect-border-style').value = data.borderStyle || 'none';
                document.getElementById('inp-rect-border-w').value = data.borderWidth || 0.5;
                document.getElementById('inp-rect-border-w-slider').value = data.borderWidth || 0.5;
            } else if (data.type === 'vline') {
                document.getElementById('prop-panel-vline').style.display = 'block';
                document.getElementById('inp-vline-width').value = data.lineWidth || 0.5;
                document.getElementById('inp-vline-width-slider').value = data.lineWidth || 0.5;
            } else if (data.type === 'image') {
                document.getElementById('prop-panel-image').style.display = 'block';

                const infoEl = document.getElementById('image-info');
                if (data.imageUrl) {
                    const widthPx = Math.ceil(data.width);
                    const heightPx = Math.ceil(data.height);
                    infoEl.textContent = `ç”»åƒãŒè¨­å®šã•ã‚Œã¦ã„ã¾ã™ (${widthPx}pxÃ—${heightPx}px)`;
                } else {
                    infoEl.textContent = 'ç”»åƒã‚’é¸æŠã—ã¦ãã ã•ã„';
                }

                // ã‚«ãƒ©ãƒ¼ãƒ¢ãƒ¼ãƒ‰è¨­å®šã‚’æ›´æ–°
                const colorMode = data.colorMode || 'fullcolor';
                document.getElementById('inp-image-colormode').value = colorMode;

                // ã‚¤ãƒ³ã‚¯ãƒ¢ãƒ¼ãƒ‰è¨­å®šã®è¡¨ç¤º/éè¡¨ç¤º
                const inkSettings = document.getElementById('image-ink-settings');
                if (colorMode === 'ink') {
                    inkSettings.style.display = 'block';
                    document.getElementById('inp-image-contrast').value = data.contrast || 100;
                    document.getElementById('label-image-contrast').textContent = data.contrast || 100;
                    document.getElementById('inp-image-brightness').value = data.brightness || 100;
                    document.getElementById('label-image-brightness').textContent = data.brightness || 100;
                } else {
                    inkSettings.style.display = 'none';
                }

                if (STATE.cropMode && data.imageUrl && data._imageAspect) {
                    const boxAspect = data.width / data.height;
                    const imgAspect = data._imageAspect;

                    let baseW, baseH, baseX, baseY;
                    if (imgAspect > boxAspect) {
                        baseH = data.height;
                        baseW = baseH * imgAspect;
                        baseX = (data.width - baseW) / 2;
                        baseY = 0;
                    } else {
                        baseW = data.width;
                        baseH = baseW / imgAspect;
                        baseX = 0;
                        baseY = (data.height - baseH) / 2;
                    }

                    const scale = data.imageScale || 1.0;
                    const offsetX = data.imageOffsetX || 0;
                    const offsetY = data.imageOffsetY || 0;

                    const imgW = baseW * scale;
                    const imgH = baseH * scale;
                    const imgX = data.x + baseX + (baseW - imgW) / 2 + offsetX;
                    const imgY = data.y + baseY + (baseH - imgH) / 2 + offsetY;

                    const boxFrame = document.createElementNS(SVG_NS, 'rect');
                    boxFrame.setAttribute('x', data.x);
                    boxFrame.setAttribute('y', data.y);
                    boxFrame.setAttribute('width', data.width);
                    boxFrame.setAttribute('height', data.height);
                    boxFrame.setAttribute('fill', 'none');
                    boxFrame.setAttribute('stroke', '#00ff00');
                    boxFrame.setAttribute('stroke-width', '2');
                    boxFrame.setAttribute('stroke-dasharray', '5,5');
                    layerUi.appendChild(boxFrame);

                    const imgFrame = document.createElementNS(SVG_NS, 'rect');
                    imgFrame.setAttribute('x', imgX);
                    imgFrame.setAttribute('y', imgY);
                    imgFrame.setAttribute('width', imgW);
                    imgFrame.setAttribute('height', imgH);
                    imgFrame.setAttribute('fill', 'none');
                    imgFrame.setAttribute('stroke', '#ff00ff');
                    imgFrame.setAttribute('stroke-width', '2');
                    imgFrame.setAttribute('cursor', 'move');
                    imgFrame.classList.add('image-drag-area');
                    layerUi.appendChild(imgFrame);

                    const handleSize = 10;
                    const createScaleHandle = (x, y, corner) => {
                        const handle = document.createElementNS(SVG_NS, 'rect');
                        handle.setAttribute('x', x - handleSize / 2);
                        handle.setAttribute('y', y - handleSize / 2);
                        handle.setAttribute('width', handleSize);
                        handle.setAttribute('height', handleSize);
                        handle.setAttribute('fill', '#ff00ff');
                        handle.setAttribute('stroke', 'white');
                        handle.setAttribute('stroke-width', '1');
                        handle.setAttribute('cursor', corner === 'nw' || corner === 'se' ? 'nwse-resize' : 'nesw-resize');
                        handle.setAttribute('data-scale-corner', corner);
                        handle.classList.add('image-scale-handle');
                        layerUi.appendChild(handle);
                    };

                    createScaleHandle(imgX, imgY, 'nw');
                    createScaleHandle(imgX + imgW, imgY, 'ne');
                    createScaleHandle(imgX, imgY + imgH, 'sw');
                    createScaleHandle(imgX + imgW, imgY + imgH, 'se');

                    return;
                }
            } else if (data.type === 'freetext') {
                document.getElementById('prop-panel-freetext').style.display = 'block';
                if (document.activeElement.id !== 'inp-freetext') document.getElementById('inp-freetext').value = data.text;
                document.getElementById('inp-freetext-font').value = data.fontFamily;
                document.getElementById('inp-freetext-size').value = data.fontSize;
                document.getElementById('inp-freetext-size-slider').value = data.fontSize;

                const directionRadios = document.getElementsByName('freetext-direction');
                for (const radio of directionRadios) {
                    radio.checked = (radio.value === data.direction);
                }

                updateFreetextAlignDirectionIndicators(data.direction);
                updateFreetextAlignButtons(data);
                document.getElementById('inp-freetext-weight').value = data.fontWeight || 400;
                document.getElementById('inp-freetext-weight-slider').value = data.fontWeight || 400;
                updateFreetextColorButtons(data);
            }

            const rect = document.createElementNS(SVG_NS, 'rect');
            rect.id = 'ui-selection-rect';
            rect.setAttribute('x', data.x - 2); rect.setAttribute('y', data.y - 2);
            rect.setAttribute('width', data.width + 4); rect.setAttribute('height', data.height + 4);

            let selClass = 'selection-rect';
            if (data.type === 'heading') selClass += ' heading-select';
            if (data.type === 'masthead') selClass += ' masthead-select';
            rect.setAttribute('class', selClass);
            layerUi.appendChild(rect);

            const isHeading = (data.type === 'heading');
            const isMasthead = (data.type === 'masthead');
            createHandle(data.x, data.y, 'nw', isHeading, isMasthead);
            createHandle(data.x + data.width, data.y, 'ne', isHeading, isMasthead);
            createHandle(data.x, data.y + data.height, 'sw', isHeading, isMasthead);
            createHandle(data.x + data.width, data.y + data.height, 'se', isHeading, isMasthead);

            if (data.type === 'text') {
                createLinkHandle(data);
            }
        }

        function createLinkHandle(data) {
            const size = 10;
            const x = data.x + data.width / 2 - size / 2;
            const y = data.y + data.height; // Bottom center

            const g = document.createElementNS(SVG_NS, 'g');

            const rect = document.createElementNS(SVG_NS, 'rect');
            rect.setAttribute('x', x); rect.setAttribute('y', y);
            rect.setAttribute('width', size); rect.setAttribute('height', size);
            rect.setAttribute('class', 'link-handle-rect' + (data.next ? ' connected' : ''));

            const hit = document.createElementNS(SVG_NS, 'rect');
            hit.setAttribute('x', x - 5); hit.setAttribute('y', y - 5);
            hit.setAttribute('width', size + 10); hit.setAttribute('height', size + 10);
            hit.setAttribute('class', 'link-handle-hit');

            g.appendChild(rect);
            g.appendChild(hit);
            layerUi.appendChild(g);
        }

        // æ¥ç¶šå¯èƒ½ãªå€™è£œã‚’å…¨ã¦ç·šæ è¡¨ç¤ºã™ã‚‹
        function showLinkCandidates(sourceId) {
            STATE.elements.forEach(el => {
                if (el.id === sourceId) return;
                if (el.type !== 'text') return;
                if (el.next || el.prev) return;

                const group = document.getElementById(el.id);
                if (group) group.classList.add('link-candidate');
            });
        }

        function clearLinkCandidates() {
            document.querySelectorAll('.link-candidate').forEach(el => el.classList.remove('link-candidate'));
            document.querySelectorAll('.highlight-target').forEach(el => el.classList.remove('highlight-target'));
        }

        function updateLinkHighlight(targetId) {
            const highlights = document.querySelectorAll('.highlight-target');
            highlights.forEach(el => el.classList.remove('highlight-target'));

            if (targetId) {
                const group = document.getElementById(targetId);
                if (group) group.classList.add('highlight-target');
            }
        }

        function updateUiPositions(data) {
            const rect = document.getElementById('ui-selection-rect');
            if (rect) {
                rect.setAttribute('x', data.x - 2); rect.setAttribute('y', data.y - 2);
                rect.setAttribute('width', data.width + 4); rect.setAttribute('height', data.height + 4);
            }
            const setPos = (sel, x, y) => {
                const group = layerUi.querySelector(sel);
                if (group) group.querySelectorAll('circle').forEach(c => { c.setAttribute('cx', x); c.setAttribute('cy', y); });
            };
            setPos('.cursor-nw', data.x, data.y); setPos('.cursor-ne', data.x + data.width, data.y);
            setPos('.cursor-sw', data.x, data.y + data.height); setPos('.cursor-se', data.x + data.width, data.y + data.height);

            const linkHandle = layerUi.querySelector('.link-handle-rect');
            const linkHit = layerUi.querySelector('.link-handle-hit');
            if (linkHandle && linkHit) {
                const size = 10;
                const lx = data.x + data.width / 2 - size / 2;
                const ly = data.y + data.height;
                linkHandle.setAttribute('x', lx); linkHandle.setAttribute('y', ly);
                linkHit.setAttribute('x', lx - 5); linkHit.setAttribute('y', ly - 5);
            }
        }

        function createHandle(x, y, dir, isHeading, isMasthead) {
            const group = document.createElementNS(SVG_NS, 'g');
            let classes = `handle-group cursor-${dir}`;
            if (isHeading) classes += ' heading-handle';
            if (isMasthead) classes += ' masthead-handle';

            group.setAttribute('class', classes);
            const hitArea = document.createElementNS(SVG_NS, 'circle');
            hitArea.setAttribute('cx', x); hitArea.setAttribute('cy', y); hitArea.setAttribute('r', 30);
            hitArea.setAttribute('class', 'resize-handle-hit');
            const visible = document.createElementNS(SVG_NS, 'circle');
            visible.setAttribute('cx', x); visible.setAttribute('cy', y); visible.setAttribute('r', 6);
            visible.setAttribute('class', 'resize-handle-visual');
            group.appendChild(visible); group.appendChild(hitArea);
            layerUi.appendChild(group);
        }

        function selectElement(id) { STATE.selectedId = id; renderUi(); }
        function deleteSelected() {
            if (!STATE.selectedId) return;
            const id = STATE.selectedId;
            const data = STATE.elements.find(e => e.id === id);
            if (data && data.type === 'text') {
                if (data.next) {
                    const next = STATE.elements.find(e => e.id === data.next);
                    if (next) {
                        next.prev = null;
                        delete next._renderedText;
                        if (!next.text) next.text = ensureLeadingFullwidthSpacePerLine("æ–°è¦è¨˜äº‹");
                        renderElement(next);
                    }
                }
                if (data.prev) {
                    const prev = STATE.elements.find(e => e.id === data.prev);
                    if (prev) {
                        prev.next = null;
                        const head = findChainHead(prev);
                        updateTextChain(head);
                    }
                }
            }

            const pattern = document.getElementById('pat-' + id);
            if (pattern) pattern.remove();
            const clip = document.getElementById('clip-' + id);
            if (clip) clip.remove();

            document.getElementById(id).remove();
            STATE.elements = STATE.elements.filter(e => e.id !== id);
            STATE.selectedId = null; renderUi();
        }

        function updateSelectedText() {
            const data = STATE.elements.find(e => e.id === STATE.selectedId);
            if (data && data.type === 'text') {
                if (!data.prev) {
                    const textarea = document.getElementById('inp-text');
                    data.text = textarea.value;
                    updateTextChain(data);
                    updateCharInfo(data);
                }
            }
        }
        function updateSelectedStyle() {
            const data = STATE.elements.find(e => e.id === STATE.selectedId);
            if (data && data.type === 'text') {
                data.fontFamily = document.getElementById('inp-fontfamily').value;
                const head = findChainHead(data);
                updateTextChain(head);
                updateUiPositions(data);
            }
        }

        function updateHeadingProp(key, subKey, val) {
            const data = STATE.elements.find(e => e.id === STATE.selectedId);
            if (!data || data.type !== 'heading') return;

            if (key === 'text') data.text = document.getElementById('inp-heading-text').value;
            if (key === 'fontFamily') data.fontFamily = document.getElementById('inp-heading-font').value;
            if (key === 'inverted') data.inverted = document.getElementById('inp-heading-inverted').checked;

            if (key === 'padding') {
                const numVal = parseFloat(val);
                if (subKey === 'h') {
                    data.paddingH = numVal;
                    document.getElementById('inp-heading-ph').value = numVal;
                    document.getElementById('inp-heading-ph-slider').value = numVal;
                } else if (subKey === 'v') {
                    data.paddingV = numVal;
                    document.getElementById('inp-heading-pv').value = numVal;
                    document.getElementById('inp-heading-pv-slider').value = numVal;
                }
            }
            renderElement(data);
        }

        function updateMastheadProp(key, val) {
            const data = STATE.elements.find(e => e.id === STATE.selectedId);
            if (!data || data.type !== 'masthead') return;

            if (key === 'text') data.text = document.getElementById('inp-masthead-text').value;
            if (key === 'fontFamily') data.fontFamily = document.getElementById('inp-masthead-font').value;
            if (key === 'inverted') data.inverted = document.getElementById('inp-masthead-inverted').checked;

            if (key === 'borderWidthOuter') {
                data.borderWidthOuter = val;
                document.getElementById('inp-masthead-bo').value = val;
                document.getElementById('inp-masthead-bo-slider').value = val;
            }
            if (key === 'borderWidthInner') {
                data.borderWidthInner = val;
                document.getElementById('inp-masthead-bi').value = val;
                document.getElementById('inp-masthead-bi-slider').value = val;
            }
            if (key === 'patternLineHeight') {
                data.patternLineHeight = val;
                document.getElementById('inp-masthead-pl').value = val;
                document.getElementById('inp-masthead-pl-slider').value = val;
            }

            if (key === 'paddingH') {
                data.paddingH = val;
                document.getElementById('inp-masthead-ph').value = val;
                document.getElementById('inp-masthead-ph-slider').value = val;
            }
            if (key === 'paddingV') {
                data.paddingV = val;
                document.getElementById('inp-masthead-pv').value = val;
                document.getElementById('inp-masthead-pv-slider').value = val;
            }
            if (key === 'textStrokeWidth') {
                data.textStrokeWidth = val;
                document.getElementById('inp-masthead-ts').value = val;
                document.getElementById('inp-masthead-ts-slider').value = val;
            }

            renderElement(data);
        }

        function updateRectProp(key, val) {
            const data = STATE.elements.find(e => e.id === STATE.selectedId);
            if (!data || data.type !== 'rect') return;

            const isInk = document.getElementById('inp-rect-ink').checked;
            data.fillMode = isInk ? 'ink' : 'paper';

            data.borderStyle = document.getElementById('inp-rect-border-style').value;

            if (key === 'width') {
                const w = parseFloat(val);
                data.borderWidth = w;
                document.getElementById('inp-rect-border-w').value = w;
                document.getElementById('inp-rect-border-w-slider').value = w;
            }

            renderElement(data);
        }

        function updateVlineProp(val) {
            const data = STATE.elements.find(e => e.id === STATE.selectedId);
            if (!data || data.type !== 'vline') return;

            const w = parseFloat(val);
            data.lineWidth = w;
            document.getElementById('inp-vline-width').value = w;
            document.getElementById('inp-vline-width-slider').value = w;

            renderElement(data);
        }

        async function updateImageProp(key) {
            const data = STATE.elements.find(e => e.id === STATE.selectedId);
            if (!data || data.type !== 'image') return;

            if (key === 'colorMode') {
                const colorMode = document.getElementById('inp-image-colormode').value;
                data.colorMode = colorMode;

                // ã‚¤ãƒ³ã‚¯ãƒ¢ãƒ¼ãƒ‰è¨­å®šã®è¡¨ç¤º/éè¡¨ç¤º
                const inkSettings = document.getElementById('image-ink-settings');
                if (colorMode === 'ink') {
                    inkSettings.style.display = 'block';
                } else {
                    inkSettings.style.display = 'none';
                }
            } else if (key === 'contrast') {
                const val = parseInt(document.getElementById('inp-image-contrast').value);
                data.contrast = val;
                document.getElementById('label-image-contrast').textContent = val;
            } else if (key === 'brightness') {
                const val = parseInt(document.getElementById('inp-image-brightness').value);
                data.brightness = val;
                document.getElementById('label-image-brightness').textContent = val;
            }

            // ã‚«ãƒ©ãƒ¼ãƒ¢ãƒ¼ãƒ‰ã‚’å†é©ç”¨
            await applyImageColorMode(data);
            renderElement(data);
        }

        function updateFreeTextProp(prop, value) {
            const data = STATE.elements.find(e => e.id === STATE.selectedId);
            if (!data || data.type !== 'freetext') return;

            let shouldRefreshPanel = false;
            if (prop === 'text') {
                data.text = document.getElementById('inp-freetext').value;
            } else if (prop === 'direction') {
                const directionRadios = document.getElementsByName('freetext-direction');
                for (const radio of directionRadios) {
                    if (radio.checked) {
                        data.direction = radio.value;
                        shouldRefreshPanel = true;
                        break;
                    }
                }
            } else if (prop === 'fontFamily') {
                data.fontFamily = document.getElementById('inp-freetext-font').value;
            } else if (prop === 'fontSize') {
                const size = parseFloat(document.activeElement.value);
                data.fontSize = size;
                document.getElementById('inp-freetext-size').value = size;
                document.getElementById('inp-freetext-size-slider').value = size;
            } else if (prop === 'fontWeight') {
                const rawValue = value !== undefined ? value : document.activeElement.value;
                const weight = parseInt(rawValue, 10) || 400;
                data.fontWeight = weight;
                document.getElementById('inp-freetext-weight').value = weight;
                document.getElementById('inp-freetext-weight-slider').value = weight;
            } else if (prop === 'colorSource') {
                data.colorSource = value || 'ink';
                updateFreetextColorButtons(data);
            }

            renderElement(data);
            if (shouldRefreshPanel) renderUi();
        }

        function setFreetextAlign(align) {
            const data = STATE.elements.find(e => e.id === STATE.selectedId);
            if (!data || data.type !== 'freetext') return;
            data.align = align;
            renderElement(data);
            updateFreetextAlignButtons(data);
        }

        function updateFreetextAlignButtons(data) {
            if (!data) return;
            const currentAlign = data.align || 'start-start';
            document.querySelectorAll('#freetext-align-grid .align-grid-btn').forEach(btn => {
                btn.classList.toggle('active', btn.dataset.align === currentAlign);
            });
        }

        function updateFreetextAlignDirectionIndicators(direction) {
            // ä¸è¦ã«ãªã£ãŸãŒäº’æ›æ€§ã®ãŸã‚æ®‹ã™
        }

        function updateFreetextColorButtons(data) {
            const activeSource = data?.colorSource || 'ink';
            document.querySelectorAll('#prop-panel-freetext .color-toggle-btn').forEach(btn => {
                const source = btn.dataset.colorSource;
                btn.classList.toggle('active', source === activeSource);
            });
        }

        function toggleCropMode() {
            STATE.cropMode = !STATE.cropMode;
            const btn = document.getElementById('btn-crop-mode');
            if (STATE.cropMode) {
                btn.textContent = 'ãƒˆãƒªãƒŸãƒ³ã‚°å®Œäº†';
                btn.style.backgroundColor = '#4CAF50';
            } else {
                btn.textContent = 'ãƒˆãƒªãƒŸãƒ³ã‚°èª¿æ•´';
                btn.style.backgroundColor = '';
            }
            renderUi();
            const data = STATE.elements.find(e => e.id === STATE.selectedId);
            if (data && data.type === 'image') {
                renderElement(data);
            }
        }

        function loadImageFile(input) {
            const data = STATE.elements.find(e => e.id === STATE.selectedId);
            if (!data || data.type !== 'image') return;

            const file = input.files[0];
            if (!file) return;

            loadImageToElement(file, data);
        }

        // --- Export & Utils ---
        function fitView() {
            const vw = viewport.clientWidth; const vh = viewport.clientHeight;
            const w_px = STATE.canvas.width * PX_PER_MM; const h_px = STATE.canvas.height * PX_PER_MM;
            const margin = 40;
            const scale = Math.min((vw - margin * 2) / w_px, (vh - margin * 2) / h_px);
            STATE.view.scale = Math.max(0.1, Math.min(scale, 5.0));
            STATE.view.x = (vw - w_px * STATE.view.scale) / 2; STATE.view.y = (vh - h_px * STATE.view.scale) / 2;
            updateTransform();
        }
        function updateTransform() { canvasContainer.style.transform = `translate(${STATE.view.x}px, ${STATE.view.y}px) scale(${STATE.view.scale})`; }

        function updateCanvasSize() {
            const w = parseFloat(document.getElementById('inp-canvas-w').value);
            const h = parseFloat(document.getElementById('inp-canvas-h').value);
            STATE.canvas.width = w; STATE.canvas.height = h;

            // ä½™ç™½ã®å€¤ã‚’STATEã«åæ˜ 
            STATE.canvas.margin.top = parseFloat(document.getElementById('inp-margin-t').value) || 20;
            STATE.canvas.margin.bottom = parseFloat(document.getElementById('inp-margin-b').value) || 20;
            STATE.canvas.margin.left = parseFloat(document.getElementById('inp-margin-l').value) || 20;
            STATE.canvas.margin.right = parseFloat(document.getElementById('inp-margin-r').value) || 20;

            mainSvg.setAttribute('width', w * PX_PER_MM); mainSvg.setAttribute('height', h * PX_PER_MM);
            mainSvg.setAttribute('viewBox', `0 0 ${w * PX_PER_MM} ${h * PX_PER_MM}`);
            updateGridSettings(); renderMarginGuide(); renderBorder();
        }
        function updateGridSettings() {
            STATE.grid.show = document.getElementById('inp-layout-show').checked;
            STATE.grid.dan = parseInt(document.getElementById('inp-layout-dan').value);
            STATE.grid.charsPerDan = parseInt(document.getElementById('inp-layout-chars').value);
            STATE.grid.totalLines = parseInt(document.getElementById('inp-layout-lines').value);
            renderPaperGrid();
        }
        function renderMarginGuide() {
            const old = document.getElementById('margin-guide-rect'); if (old) old.remove();
            const mt = STATE.canvas.margin.top * PX_PER_MM;
            const ml = STATE.canvas.margin.left * PX_PER_MM;
            const w = STATE.canvas.width * PX_PER_MM;
            const h = STATE.canvas.height * PX_PER_MM;
            const rect = document.createElementNS(SVG_NS, 'rect');
            rect.id = 'margin-guide-rect';
            rect.setAttribute('x', ml); rect.setAttribute('y', mt);
            rect.setAttribute('width', w - ml - STATE.canvas.margin.right * PX_PER_MM);
            rect.setAttribute('height', h - mt - STATE.canvas.margin.bottom * PX_PER_MM);
            rect.setAttribute('class', 'margin-guide');
            layerUi.appendChild(rect);
        }
        function renderPaperGrid() {
            layerPaperGrid.innerHTML = '';

            // ã‚°ãƒªãƒƒãƒ‰è¨ˆç®—ã¯å¸¸ã«å®Ÿè¡Œï¼ˆæ®µé–“ç½«ç·šã®ãŸã‚ã«å¿…è¦ï¼‰
            const mt = STATE.canvas.margin.top * PX_PER_MM;
            const w_px = STATE.canvas.width * PX_PER_MM; const h_px = STATE.canvas.height * PX_PER_MM;
            const validH = h_px - mt - STATE.canvas.margin.bottom * PX_PER_MM;
            const validW = w_px - STATE.canvas.margin.left * PX_PER_MM - STATE.canvas.margin.right * PX_PER_MM;
            const totalHUnits = (STATE.grid.charsPerDan * STATE.grid.dan) + (STATE.grid.dan - 1);
            const unitH = validH / totalHUnits;
            const danPitch = (STATE.grid.charsPerDan * unitH) + unitH;
            const fontSizeW = unitH / CHAR_SCALE_RATIO;
            const pitchX = fontSizeW + (STATE.grid.totalLines > 1 ? (validW - fontSizeW * STATE.grid.totalLines) / (STATE.grid.totalLines - 1) : 0);
            STATE.grid.computed = { charSizeW: fontSizeW, charSizeH: unitH, danHeight: unitH * STATE.grid.charsPerDan, danPitch, pitchX, lineGap: (pitchX - fontSizeW) };
            document.getElementById('grid-info').innerHTML = `æ–‡å­—ã‚µã‚¤ã‚º: ${(fontSizeW / PX_PER_MM).toFixed(2)}mm`;

            // æ®µé–“ç½«ç·šã‚’æç”»ï¼ˆã‚°ãƒªãƒƒãƒ‰è¡¨ç¤ºã®ON/OFFã«é–¢ä¿‚ãªãï¼‰
            renderDanLines();

            // ã‚°ãƒªãƒƒãƒ‰è¡¨ç¤ºãŒOFFãªã‚‰ã“ã“ã§çµ‚äº†
            if (!STATE.grid.show) return;

            // ã‚°ãƒªãƒƒãƒ‰æç”»
            const mr = STATE.canvas.margin.right * PX_PER_MM;
            for (let l = 0; l < STATE.grid.totalLines; l++) {
                const lineX = (w_px - mr) - fontSizeW - (l * STATE.grid.computed.pitchX);
                for (let d = 0; d < STATE.grid.dan; d++) {
                    const startY = mt + (d * danPitch);
                    for (let c = 0; c < STATE.grid.charsPerDan; c++) {
                        const rect = document.createElementNS(SVG_NS, 'rect');
                        rect.setAttribute('x', lineX); rect.setAttribute('y', startY + (c * unitH));
                        rect.setAttribute('width', fontSizeW); rect.setAttribute('height', unitH);
                        rect.setAttribute('class', 'grid-rect');
                        layerPaperGrid.appendChild(rect);
                    }
                }
            }
        }

        // æ®µé–“ç½«ç·šã®æç”»
        function renderDanLines() {
            console.log('[renderDanLines] å‘¼ã³å‡ºã—');
            const layerDanLines = document.getElementById('layer-dan-lines');
            if (!layerDanLines) {
                console.log('[renderDanLines] layer-dan-lines ãŒè¦‹ã¤ã‹ã‚‰ãªã„');
                return;
            }
            layerDanLines.innerHTML = '';

            console.log('[renderDanLines] STATE.grid:', {
                dan: STATE.grid.dan,
                computed: STATE.grid.computed,
                hasDanPitch: STATE.grid.computed?.danPitch
            });

            // æ®µæ•°ãŒ1ä»¥ä¸‹ã®å ´åˆã‚„è¨ˆç®—å€¤ãŒãªã„å ´åˆã¯æç”»ã—ãªã„
            if (STATE.grid.dan <= 1) {
                console.log('[renderDanLines] æ®µæ•°ãŒ1ä»¥ä¸‹ã§ã‚¹ã‚­ãƒƒãƒ—');
                return;
            }
            if (!STATE.grid.computed || !STATE.grid.computed.danPitch) {
                console.log('[renderDanLines] computedæœªè¨ˆç®—ã§ã‚¹ã‚­ãƒƒãƒ—');
                return;
            }
            console.log('[renderDanLines] æç”»å®Ÿè¡Œ');

            const danPitch = STATE.grid.computed.danPitch;
            const danHeight = STATE.grid.computed.danHeight;
            const mt = STATE.canvas.margin.top * PX_PER_MM;
            const ml = STATE.canvas.margin.left * PX_PER_MM;
            const w_px = STATE.canvas.width * PX_PER_MM;
            const validW = w_px - ml - STATE.canvas.margin.right * PX_PER_MM;

            const gap = danPitch - danHeight;
            const lineX1 = ml;
            const lineX2 = ml + validW;
            const strokeWidth = 0.4 * PX_PER_MM;

            // æ®µé–“ç½«ç·šã‚’æç”»ï¼ˆæ®µæ•°-1æœ¬ï¼‰
            for (let i = 0; i < STATE.grid.dan - 1; i++) {
                const lineY = mt + (i + 1) * danHeight + (i + 0.5) * gap;

                const line = document.createElementNS(SVG_NS, 'line');
                line.setAttribute('x1', lineX1);
                line.setAttribute('y1', lineY);
                line.setAttribute('x2', lineX2);
                line.setAttribute('y2', lineY);
                line.setAttribute('class', 'ink-stroke');
                line.setAttribute('stroke-width', strokeWidth);
                line.setAttribute('fill', 'none');
                line.setAttribute('pointer-events', 'none');
                layerDanLines.appendChild(line);
            }

            // ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚’æ˜ç¤ºçš„ã«å¯è¦–åŒ–
            layerDanLines.style.visibility = 'visible';
            layerDanLines.style.opacity = '1';
            layerDanLines.style.display = '';
        }
        async function updateColors() {
            const paperC = document.getElementById('inp-paper-color').value;
            const inkC = document.getElementById('inp-ink-color').value;
            STATE.canvas.colors.paper = paperC; STATE.canvas.colors.ink = inkC;
            svgStyle.textContent = `
            .hit-rect { fill: #ffffff; fill-opacity: 0; pointer-events: all; }
            .ink-fill { fill: ${inkC}; } .ink-stroke { stroke: ${inkC}; }
            .paper-fill { fill: ${paperC}; } .paper-stroke { stroke: ${paperC}; }
            text { fill: ${inkC}; }
        `;
            renderBorder();

            // å…¨è¦ç´ ã‚’å†æç”»ï¼ˆç”»åƒã¯å¿…è¦ãªã‚‰ã‚¤ãƒ³ã‚¯å‡¦ç†ã‚‚å†å®Ÿè¡Œï¼‰
            for (const data of STATE.elements) {
                if (data.type === 'image' && data.colorMode === 'ink' && data._originalImageUrl) {
                    await applyImageColorMode(data);
                }
                renderElement(data);
            }
        }

        // --- ãƒ˜ãƒƒãƒ€ãƒ¼ãƒ†ã‚­ã‚¹ãƒˆæ›´æ–°é–¢æ•° ---
        function updateHeaderText(position) {
            STATE.header[position].text = document.getElementById(`inp-header-${position}-text`).value;
            renderBorder();
        }

        function updateHeaderFont(position) {
            STATE.header[position].fontFamily = document.getElementById(`inp-header-${position}-font`).value;
            renderBorder();
        }

        function updateHeaderWeight(position) {
            STATE.header[position].fontWeight = parseInt(document.getElementById(`inp-header-${position}-weight`).value);
            renderBorder();
        }

        function updateHeaderSize(position) {
            STATE.header[position].fontSize = parseFloat(document.getElementById(`inp-header-${position}-size`).value);
            renderBorder();
        }

        function updateHeaderSpacing(position) {
            STATE.header[position].letterSpacing = parseFloat(document.getElementById(`inp-header-${position}-spacing`).value);
            renderBorder();
        }

        async function urlToBase64(url) {
            try {
                const res = await fetch(url); const blob = await res.blob();
                return new Promise(r => { const reader = new FileReader(); reader.onloadend = () => r(reader.result); reader.readAsDataURL(blob); });
            } catch { return null; }
        }
        async function getEmbeddableFontCss(cssUrl) {
            try {
                const res = await fetch(cssUrl); let cssText = await res.text();
                const urlRegex = /url\((['"]?)(https:\/\/[^'"\)]+)\1\)/g; let match; const replacements = [];
                while ((match = urlRegex.exec(cssText)) !== null) replacements.push({ original: match[0], url: match[2] });
                const uniqueUrls = [...new Set(replacements.map(r => r.url))];
                const base64Map = {};
                await Promise.all(uniqueUrls.map(async (url) => { const b64 = await urlToBase64(url); if (b64) base64Map[url] = b64; }));
                for (const rep of replacements) if (base64Map[rep.url]) cssText = cssText.split(rep.original).join(`url("${base64Map[rep.url]}")`);
                return cssText;
            } catch { return ''; }
        }
        async function exportCanvas(isRetry = false) {
            const btn = document.getElementById('btn-export');
            const originalText = btn.textContent;
            btn.textContent = "å‡¦ç†ä¸­..."; btn.disabled = true;
            layerUi.style.display = 'none'; layerPaperGrid.style.display = 'none';

            try {
                // ã‚¯ãƒ­ãƒ¼ãƒ³ã‚’ä½œæˆã—ã€ä¸è¦ãªUIè¦ç´ ã‚’å‰Šé™¤
                const svgClone = mainSvg.cloneNode(true);
                svgClone.querySelectorAll('.hit-rect, #margin-guide-rect').forEach(el => el.remove());

                // font-familyå±æ€§ã‚’ç°¡ç´ åŒ–ï¼ˆã‚¯ã‚©ãƒ¼ãƒˆå‰Šé™¤ï¼‰
                svgClone.querySelectorAll('[font-family]').forEach(el => {
                    let ff = el.getAttribute('font-family');
                    if (ff) {
                        ff = ff.replace(/['"]/g, '').split(',')[0].trim();
                        el.setAttribute('font-family', ff);
                        // styleå±æ€§ã‚‚ã‚ã‚Œã°æ›´æ–°
                        if (el.style.fontFamily) {
                            el.style.fontFamily = ff;
                        }
                    }
                });

                // textè¦ç´ ã®styleå±æ€§ï¼ˆwriting-mode, text-orientationãªã©ï¼‰ã‚’ä¿æŒ
                svgClone.querySelectorAll('text').forEach(el => {
                    const writingMode = el.getAttribute('writing-mode');
                    const textOrientation = el.style.textOrientation;

                    // writing-modeãŒè¨­å®šã•ã‚Œã¦ã„ã‚‹å ´åˆã¯ä¿æŒ
                    if (writingMode) {
                        el.style.writingMode = writingMode;
                    }

                    // text-orientationãŒè¨­å®šã•ã‚Œã¦ã„ã‚‹å ´åˆã¯ä¿æŒ
                    if (textOrientation && textOrientation !== 'mixed') {
                        el.style.textOrientation = textOrientation;
                    }
                });

                // å‹•çš„ãªã‚¹ã‚¿ã‚¤ãƒ«ï¼ˆè‰²ãªã©ï¼‰ã‚’ã‚¤ãƒ³ãƒ©ã‚¤ãƒ³ã§åŸ‹ã‚è¾¼ã‚€
                const inkC = STATE.canvas.colors.ink;
                const paperC = STATE.canvas.colors.paper;
                const dynamicCss = `
                .ink-fill { fill: ${inkC} !important; }
                .ink-stroke { stroke: ${inkC} !important; }
                .paper-fill { fill: ${paperC} !important; }
                .paper-stroke { stroke: ${paperC} !important; }
                text { fill: ${inkC} !important; }
            `;
                const dynamicStyleEl = document.createElementNS(SVG_NS, 'style');
                dynamicStyleEl.textContent = dynamicCss;
                svgClone.querySelector('defs').appendChild(dynamicStyleEl);

                const svgData = new XMLSerializer().serializeToString(svgClone);
                const svgDataUri = 'data:image/svg+xml;charset=utf-8,' + encodeURIComponent(svgData);

                const img = new Image();
                img.crossOrigin = 'anonymous';
                img.onload = () => {
                    // åˆå›ã¯æ›¸ãå‡ºã—ã‚’ã‚¹ã‚­ãƒƒãƒ—ã—ã¦ã€2å›ç›®ã‚’è‡ªå‹•å®Ÿè¡Œ
                    if (!isRetry) {
                        // å°‘ã—å¾…ã£ã¦ã‹ã‚‰2å›ç›®ã‚’å®Ÿè¡Œ
                        setTimeout(() => {
                            exportCanvas(true);
                        }, 100);
                        return;
                    }

                    // 2å›ç›®ã¯å®Ÿéš›ã«æ›¸ãå‡ºã—
                    const currentW = parseFloat(mainSvg.getAttribute('width'));
                    const currentH = parseFloat(mainSvg.getAttribute('height'));
                    const canvas = document.createElement('canvas');
                    const scale = 4; // é«˜è§£åƒåº¦åŒ–
                    canvas.width = currentW * scale;
                    canvas.height = currentH * scale;
                    const ctx = canvas.getContext('2d');
                    ctx.scale(scale, scale);
                    ctx.drawImage(img, 0, 0);

                    const a = document.createElement('a');
                    a.href = canvas.toDataURL('image/png');
                    a.download = 'newspaper.png';
                    a.click();

                    btn.textContent = originalText;
                    btn.disabled = false;
                    layerUi.style.display = 'block';
                    layerPaperGrid.style.display = 'block';
                };
                img.onerror = () => {
                    console.error("Image loading for export failed.");
                    btn.textContent = "ã‚¨ãƒ©ãƒ¼";
                    setTimeout(() => {
                        btn.textContent = originalText;
                        btn.disabled = false;
                    }, 2000);
                    layerUi.style.display = 'block';
                    layerPaperGrid.style.display = 'block';
                };
                img.src = svgDataUri;

            } catch (e) {
                console.error("Export failed:", e);
                btn.textContent = originalText;
                btn.disabled = false;
                layerUi.style.display = 'block';
                layerPaperGrid.style.display = 'block';
            }
        }

        function setCanvasPreset(w, h) { document.getElementById('inp-canvas-w').value = w; document.getElementById('inp-canvas-h').value = h; updateCanvasSize(); fitView(); }
        function swapCanvasSize() { const w = document.getElementById('inp-canvas-w'); const h = document.getElementById('inp-canvas-h');[w.value, h.value] = [h.value, w.value]; updateCanvasSize(); }
        function getSvgPoint(clientX, clientY) {
            const vpRect = viewport.getBoundingClientRect();
            return { x: (clientX - vpRect.left - STATE.view.x) / STATE.view.scale, y: (clientY - vpRect.top - STATE.view.y) / STATE.view.scale };
        }

        // --- åˆæœŸåŒ–å‡¦ç† ---
        window.addEventListener('load', async () => {
            const loadingScreen = document.getElementById('loading-screen');
            const loadingText = loadingScreen.querySelector('.loading-text');
            const loadingSubtext = loadingScreen.querySelector('.loading-subtext');

            try {
                // åŸºæœ¬UIã®åˆæœŸåŒ–
                loadingText.textContent = 'åˆæœŸåŒ–ä¸­...';
                loadingSubtext.textContent = 'ã‚­ãƒ£ãƒ³ãƒã‚¹ã‚’æº–å‚™ã—ã¦ã„ã¾ã™';
                updateCanvasSize();
                updateGridSettings();
                updateColors();
                fitView();

                // ãƒ•ã‚©ãƒ³ãƒˆã‚’éåŒæœŸã§å–å¾—ã—ã€SVGã«åŸ‹ã‚è¾¼ã‚€
                loadingText.textContent = 'èª­ã¿è¾¼ã¿ä¸­...';
                loadingSubtext.textContent = 'ãƒ•ã‚©ãƒ³ãƒˆãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—ã—ã¦ã„ã¾ã™';

                const fontCssUrl = 'https://fonts.googleapis.com/css2?family=BIZ+UDMincho&family=Noto+Sans+JP:wght@400;700;900&family=Noto+Serif+JP:wght@400;700;900&family=Yuji+Syuku&display=block';
                const embeddedCss = await getEmbeddableFontCss(fontCssUrl);

                if (embeddedCss) {
                    // æ—¢å­˜ã®ã‚¹ã‚¿ã‚¤ãƒ«ã«è¿½è¨˜ã™ã‚‹
                    loadingSubtext.textContent = 'ãƒ•ã‚©ãƒ³ãƒˆã‚’åŸ‹ã‚è¾¼ã‚“ã§ã„ã¾ã™';
                    svgStyle.textContent += '\n' + embeddedCss;
                }

                // ãƒ•ã‚©ãƒ³ãƒˆã®æº–å‚™ãŒã§ããŸå¾Œã«è¦ç´ ã‚’ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°
                loadingText.textContent = 'ã‚‚ã†ã™ãå®Œäº†...';
                loadingSubtext.textContent = 'ãƒ•ã‚©ãƒ³ãƒˆã®èª­ã¿è¾¼ã¿ã‚’å¾…æ©Ÿä¸­';

                if (document.fonts) {
                    await document.fonts.ready;
                }

                loadingSubtext.textContent = 'è¦ç´ ã‚’ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°ä¸­';
                STATE.elements.forEach(renderElement);
                if (STATE.selectedId) renderUi();

                setupImageDragAndDrop();

                // iPad/iOSãƒ‡ãƒã‚¤ã‚¹ã®è‡ªå‹•æ¤œå‡º
                if (detectIpadDevice()) {
                    setIpadMode(true);
                }

                // Undo/Redoãƒœã‚¿ãƒ³ã®åˆæœŸçŠ¶æ…‹ã‚’æ›´æ–°
                updateHistoryButtons();

                // ãƒ­ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ç”»é¢ã‚’ãƒ•ã‚§ãƒ¼ãƒ‰ã‚¢ã‚¦ãƒˆ
                loadingScreen.classList.add('hidden');
                setTimeout(() => {
                    loadingScreen.style.display = 'none';

                    // ãƒ‡ãƒãƒƒã‚°: æ®µé–“ç½«ç·šã®çŠ¶æ…‹ã‚’ç¢ºèª
                    const danLines = document.getElementById('layer-dan-lines');
                    console.log('[åˆæœŸåŒ–å®Œäº†] æ®µé–“ç½«ç·šã®çŠ¶æ…‹:', {
                        exists: !!danLines,
                        childCount: danLines ? danLines.children.length : 0,
                        visibility: danLines ? danLines.style.visibility : 'N/A',
                        opacity: danLines ? danLines.style.opacity : 'N/A'
                    });
                }, 300);

            } catch (e) {
                console.error("Initialization failed:", e);
                loadingText.textContent = 'ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ';
                loadingSubtext.textContent = e.message || 'åˆæœŸåŒ–ã«å¤±æ•—ã—ã¾ã—ãŸ';
            }
        });

        // ç”»åƒãƒ‰ãƒ©ãƒƒã‚°&ãƒ‰ãƒ­ãƒƒãƒ—ã®ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—
        function setupImageDragAndDrop() {
            // SVGã‚­ãƒ£ãƒ³ãƒã‚¹ã¸ã®ãƒ‰ãƒ­ãƒƒãƒ—
            const canvasContainer = document.getElementById('canvas-container');
            canvasContainer.addEventListener('dragover', (e) => {
                e.preventDefault();
                e.dataTransfer.dropEffect = 'copy';
            });

            canvasContainer.addEventListener('drop', (e) => {
                e.preventDefault();
                const file = e.dataTransfer.files[0];
                if (!file || !file.type.startsWith('image/')) return;

                // ãƒã‚¦ã‚¹åº§æ¨™ã‹ã‚‰SVGåº§æ¨™ã‚’å–å¾—
                const rect = mainSvg.getBoundingClientRect();
                const svgX = (e.clientX - rect.left) / STATE.view.scale;
                const svgY = (e.clientY - rect.top) / STATE.view.scale;

                // ãã®ä½ç½®ã«ã‚ã‚‹ç”»åƒãƒœãƒƒã‚¯ã‚¹ã‚’æ¢ã™
                let targetImage = null;
                for (let i = STATE.elements.length - 1; i >= 0; i--) {
                    const el = STATE.elements[i];
                    if (el.type === 'image' &&
                        svgX >= el.x && svgX <= el.x + el.width &&
                        svgY >= el.y && svgY <= el.y + el.height) {
                        targetImage = el;
                        break;
                    }
                }

                if (targetImage) {
                    loadImageToElement(file, targetImage);
                }
            });

            // ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ãƒ‘ãƒãƒ«ã¸ã®ãƒ‰ãƒ­ãƒƒãƒ—
            const propPanel = document.getElementById('prop-panel-image');
            propPanel.addEventListener('dragover', (e) => {
                e.preventDefault();
                e.dataTransfer.dropEffect = 'copy';
            });

            propPanel.addEventListener('drop', (e) => {
                e.preventDefault();
                const file = e.dataTransfer.files[0];
                if (!file || !file.type.startsWith('image/')) return;

                const data = STATE.elements.find(el => el.id === STATE.selectedId);
                if (data && data.type === 'image') {
                    loadImageToElement(file, data);
                }
            });
        }

        // === ç”»åƒã‚«ãƒ©ãƒ¼ãƒ¢ãƒ¼ãƒ‰å¤‰æ›é–¢æ•° ===

        // ç”»åƒã«é€éãƒ”ã‚¯ã‚»ãƒ«ï¼ˆã‚¢ãƒ«ãƒ•ã‚¡<255ï¼‰ãŒå«ã¾ã‚Œã¦ã„ã‚‹ã‹ãƒã‚§ãƒƒã‚¯
        function hasTransparency(imgElement) {
            const canvas = document.createElement('canvas');
            canvas.width = imgElement.width;
            canvas.height = imgElement.height;
            const ctx = canvas.getContext('2d');
            ctx.drawImage(imgElement, 0, 0);

            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;

            // ã‚¢ãƒ«ãƒ•ã‚¡ãƒãƒ£ãƒ³ãƒãƒ«ã‚’ãƒã‚§ãƒƒã‚¯ï¼ˆ4ãƒã‚¤ãƒˆç›®ã”ã¨ï¼‰
            for (let i = 3; i < data.length; i += 4) {
                if (data[i] < 255) {
                    return true; // é€éãƒ”ã‚¯ã‚»ãƒ«ãŒè¦‹ã¤ã‹ã£ãŸ
                }
            }
            return false; // é€éãƒ”ã‚¯ã‚»ãƒ«ãªã—
        }

        // RGBè‰²ã‚’è¼åº¦å€¤ï¼ˆ0.0ï½1.0ï¼‰ã«å¤‰æ›
        function getLuminance(r, g, b) {
            return 0.299 * r + 0.587 * g + 0.114 * b;
        }

        // 16é€²æ•°ã‚«ãƒ©ãƒ¼ã‚³ãƒ¼ãƒ‰ã‚’RGBé…åˆ—ã«å¤‰æ›
        function hexToRgb(hex) {
            const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
            return result ? [
                parseInt(result[1], 16),
                parseInt(result[2], 16),
                parseInt(result[3], 16)
            ] : [0, 0, 0];
        }

        // 2è‰²ã®ç·šå½¢è£œé–“
        function lerpColor(color1, color2, t) {
            return [
                Math.round(color1[0] + (color2[0] - color1[0]) * t),
                Math.round(color1[1] + (color2[1] - color1[1]) * t),
                Math.round(color1[2] + (color2[2] - color1[2]) * t)
            ];
        }

        // ç”»åƒã‚’åœ§ç¸®ï¼ˆæœ€å¤§è¾º2400pxã€JPEGå“è³ª0.9ï¼‰
        function compressImage(imgElement, maxSize = 2400, quality = 0.9) {
            return new Promise((resolve) => {
                const canvas = document.createElement('canvas');
                let width = imgElement.width;
                let height = imgElement.height;

                const maxDim = Math.max(width, height);
                if (maxDim > maxSize) {
                    const scale = maxSize / maxDim;
                    width *= scale;
                    height *= scale;
                }

                canvas.width = width;
                canvas.height = height;
                const ctx = canvas.getContext('2d');
                ctx.drawImage(imgElement, 0, 0, width, height);

                canvas.toBlob(blob => {
                    const reader = new FileReader();
                    reader.onload = e => resolve(e.target.result);
                    reader.readAsDataURL(blob);
                }, 'image/jpeg', quality);
            });
        }

        // ã‚¤ãƒ³ã‚¯ãƒ¢ãƒ¼ãƒ‰å¤‰æ›ï¼šç”»åƒãƒ‡ãƒ¼ã‚¿ã‚’æŒ‡å®šã—ãŸã‚¤ãƒ³ã‚¯è‰²ã¨ç´™è‰²ã§å†æ§‹æˆ
        function convertImageToInk(imgElement, inkColor, paperColor, contrast = 1.0, brightness = 1.0) {
            return new Promise((resolve) => {
                const canvas = document.createElement('canvas');
                canvas.width = imgElement.width;
                canvas.height = imgElement.height;
                const ctx = canvas.getContext('2d');
                ctx.drawImage(imgElement, 0, 0);

                const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                const data = imageData.data;

                const ink = hexToRgb(inkColor);
                const paper = hexToRgb(paperColor);

                // ã‚¤ãƒ³ã‚¯ã¨ç´™ã€ã©ã¡ã‚‰ãŒæ˜ã‚‹ã„ã‹ã‚’åˆ¤å®š
                const inkLum = getLuminance(ink[0], ink[1], ink[2]) / 255;
                const paperLum = getLuminance(paper[0], paper[1], paper[2]) / 255;
                const inkIsDarker = inkLum < paperLum;

                // ãƒ”ã‚¯ã‚»ãƒ«ã”ã¨ã«å‡¦ç†
                for (let i = 0; i < data.length; i += 4) {
                    const r = data[i];
                    const g = data[i + 1];
                    const b = data[i + 2];

                    // è¼åº¦ã‚’è¨ˆç®—ï¼ˆ0.0ï½1.0ï¼‰
                    let lum = getLuminance(r, g, b) / 255;

                    // ã‚³ãƒ³ãƒˆãƒ©ã‚¹ãƒˆã¨æ˜ã‚‹ã•ã®è£œæ­£
                    lum = (lum - 0.5) * contrast + 0.5;
                    lum = lum * brightness;
                    lum = Math.max(0, Math.min(1, lum));

                    // ã‚¤ãƒ³ã‚¯ãŒæš—ã„å ´åˆï¼šé»’â†’ã‚¤ãƒ³ã‚¯ã€ç™½â†’ç´™
                    // ã‚¤ãƒ³ã‚¯ãŒæ˜ã‚‹ã„å ´åˆï¼šé»’â†’ç´™ã€ç™½â†’ã‚¤ãƒ³ã‚¯ï¼ˆåè»¢ï¼‰
                    let col;
                    if (inkIsDarker) {
                        col = lerpColor(ink, paper, lum);
                    } else {
                        col = lerpColor(paper, ink, lum);
                    }

                    data[i] = col[0];
                    data[i + 1] = col[1];
                    data[i + 2] = col[2];
                }

                ctx.putImageData(imageData, 0, 0);
                resolve(canvas.toDataURL('image/jpeg', 0.9));
            });
        }

        // ç”»åƒãƒ•ã‚¡ã‚¤ãƒ«ã‚’è¦ç´ ã«èª­ã¿è¾¼ã‚€å…±é€šé–¢æ•°
        function loadImageToElement(file, data) {
            const reader = new FileReader();
            reader.onload = function (e) {
                const img = new Image();
                img.onload = async function () {
                    data._imageAspect = img.width / img.height;

                    // é€éãƒã‚§ãƒƒã‚¯
                    data._hasTransparency = hasTransparency(img);

                    // åœ§ç¸®å‡¦ç†
                    const compressed = await compressImage(img);
                    data._originalImageUrl = compressed;

                    // ã‚«ãƒ©ãƒ¼ãƒ¢ãƒ¼ãƒ‰ã«å¿œã˜ã¦å‡¦ç†
                    await applyImageColorMode(data);

                    renderElement(data);
                    if (STATE.selectedId === data.id) {
                        renderUi();
                    }
                };
                img.src = e.target.result;
            };
            reader.readAsDataURL(file);
        }

        // ã‚«ãƒ©ãƒ¼ãƒ¢ãƒ¼ãƒ‰ã‚’é©ç”¨
        async function applyImageColorMode(data) {
            if (!data._originalImageUrl) {
                data.imageUrl = null;
                return;
            }

            const colorMode = data.colorMode || 'fullcolor';

            if (colorMode === 'fullcolor') {
                data.imageUrl = data._originalImageUrl;
            } else if (colorMode === 'ink') {
                // å…¨ä½“è¨­å®šã®ã‚¤ãƒ³ã‚¯è‰²ãƒ»ç´™è‰²ã‚’ä½¿ç”¨
                const inkColor = STATE.canvas.colors.ink || '#333333';
                const paperColor = STATE.canvas.colors.paper || '#ffffff';
                const contrast = (data.contrast || 100) / 100;
                const brightness = (data.brightness || 100) / 100;

                const img = new Image();
                await new Promise(resolve => {
                    img.onload = resolve;
                    img.src = data._originalImageUrl;
                });

                data.imageUrl = await convertImageToInk(img, inkColor, paperColor, contrast, brightness);
            }
        }

        // ===== Undo/Redoå±¥æ­´ç®¡ç† =====
        function saveHistory() {
            // ç¾åœ¨ã®ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ä»¥é™ã®å±¥æ­´ã‚’å‰Šé™¤
            STATE.history = STATE.history.slice(0, STATE.historyIndex + 1);

            // ç¾åœ¨ã®çŠ¶æ…‹ã‚’æ·±ãã‚³ãƒ”ãƒ¼ã—ã¦ä¿å­˜
            const snapshot = JSON.parse(JSON.stringify(STATE.elements));
            STATE.history.push(snapshot);
            STATE.historyIndex++;

            // å±¥æ­´ã¯æœ€å¤§50ä»¶ã¾ã§
            if (STATE.history.length > 50) {
                STATE.history.shift();
                STATE.historyIndex--;
            }

            // ãƒœã‚¿ãƒ³ã®çŠ¶æ…‹ã‚’æ›´æ–°
            updateHistoryButtons();

            // æ“ä½œãŒç¢ºå®šã—ãŸã®ã§ã‚ªãƒ¼ãƒˆã‚»ãƒ¼ãƒ–ã‚’å®Ÿè¡Œ
            autoSave(false);
        }

        function undo() {
            if (STATE.historyIndex <= 0) return;

            STATE.historyIndex--;
            const snapshot = STATE.history[STATE.historyIndex];
            STATE.elements = JSON.parse(JSON.stringify(snapshot));

            // å…¨è¦ç´ ã‚’å†æç”»
            document.querySelectorAll('.element-group').forEach(el => el.remove());
            STATE.elements.forEach(data => renderElement(data));

            // é¸æŠã‚’ã‚¯ãƒªã‚¢
            selectElement(null);

            // ãƒœã‚¿ãƒ³ã®çŠ¶æ…‹ã‚’æ›´æ–°
            updateHistoryButtons();
        }

        function redo() {
            if (STATE.historyIndex >= STATE.history.length - 1) return;

            STATE.historyIndex++;
            const snapshot = STATE.history[STATE.historyIndex];
            STATE.elements = JSON.parse(JSON.stringify(snapshot));

            // å…¨è¦ç´ ã‚’å†æç”»
            document.querySelectorAll('.element-group').forEach(el => el.remove());
            STATE.elements.forEach(data => renderElement(data));

            // é¸æŠã‚’ã‚¯ãƒªã‚¢
            selectElement(null);

            // ãƒœã‚¿ãƒ³ã®çŠ¶æ…‹ã‚’æ›´æ–°
            updateHistoryButtons();
        }

        // Undo/Redoãƒœã‚¿ãƒ³ã®æœ‰åŠ¹/ç„¡åŠ¹ã‚’æ›´æ–°
        function updateHistoryButtons() {
            const undoBtn = document.getElementById('btn-undo');
            const redoBtn = document.getElementById('btn-redo');

            if (undoBtn) {
                undoBtn.disabled = STATE.historyIndex <= 0;
            }
            if (redoBtn) {
                redoBtn.disabled = STATE.historyIndex >= STATE.history.length - 1;
            }
        }

        // ===== ã‚ªãƒ¼ãƒˆã‚»ãƒ¼ãƒ–æ©Ÿèƒ½ =====
        const AUTOSAVE_KEY = 'newspaper-editor-autosave';
        const MAX_AUTOSAVE_SIZE = 4.5 * 1024 * 1024; // 4.5MB

        // ç”»åƒãƒ‡ãƒ¼ã‚¿ã‚’åœ§ç¸®ã™ã‚‹é–¢æ•°
        async function compressImageData(imageUrl, quality = 0.8) {
            return new Promise((resolve) => {
                const img = new Image();
                img.onload = () => {
                    const canvas = document.createElement('canvas');
                    canvas.width = img.width;
                    canvas.height = img.height;
                    const ctx = canvas.getContext('2d');
                    ctx.drawImage(img, 0, 0);

                    // JPEGå½¢å¼ã§åœ§ç¸®
                    const compressed = canvas.toDataURL('image/jpeg', quality);
                    resolve(compressed);
                };
                img.onerror = () => resolve(imageUrl); // ã‚¨ãƒ©ãƒ¼æ™‚ã¯å…ƒã®URLã‚’è¿”ã™
                img.src = imageUrl;
            });
        }

        // è¦ç´ å†…ã®ç”»åƒã‚’åœ§ç¸®
        async function compressElementImages(elements, quality = 0.8) {
            const compressed = JSON.parse(JSON.stringify(elements));
            for (const elem of compressed) {
                if (elem.type === 'image' && elem.imageUrl && elem.imageUrl.startsWith('data:')) {
                    elem.imageUrl = await compressImageData(elem.imageUrl, quality);
                }
            }
            return compressed;
        }

        // ã‚ªãƒ¼ãƒˆã‚»ãƒ¼ãƒ–ã‚¤ãƒ³ã‚¸ã‚±ãƒ¼ã‚¿ãƒ¼è¡¨ç¤ºé–¢æ•°
        function showAutosaveIndicator(status = 'saving') {
            const indicator = document.getElementById('autosave-indicator');
            const text = document.getElementById('autosave-text');

            indicator.classList.remove('error');

            if (status === 'saving') {
                text.textContent = 'ä¿å­˜ä¸­...';
                indicator.classList.add('show');
            } else if (status === 'success') {
                text.textContent = 'ä¿å­˜å®Œäº†';
                indicator.classList.add('show');
                setTimeout(() => {
                    indicator.classList.remove('show');
                }, 2000);
            } else if (status === 'error') {
                text.textContent = 'ä¿å­˜å¤±æ•—';
                indicator.classList.add('show', 'error');
                setTimeout(() => {
                    indicator.classList.remove('show');
                }, 3000);
            }
        }

        async function autoSave(silent = false) {
            if (!silent) {
                showAutosaveIndicator('saving');
            }

            try {
                let elements = STATE.elements;
                let quality = 0.8;

                // ã¾ãšé€šå¸¸ã®å“è³ªã§è©¦ã™
                let project = {
                    version: '1.0',
                    canvas: STATE.canvas,
                    grid: {
                        show: STATE.grid.show,
                        dan: STATE.grid.dan,
                        charsPerDan: STATE.grid.charsPerDan,
                        totalLines: STATE.grid.totalLines
                    },
                    header: STATE.header,
                    articleSnapMode: STATE.articleSnapMode,
                    elements: elements,
                    timestamp: new Date().toISOString()
                };

                let json = JSON.stringify(project);
                let size = new Blob([json]).size;

                // ã‚µã‚¤ã‚ºãŒå¤§ãã„å ´åˆã¯ç”»åƒã‚’åœ§ç¸®
                if (size > MAX_AUTOSAVE_SIZE) {
                    console.log(`ã‚ªãƒ¼ãƒˆã‚»ãƒ¼ãƒ–ã‚µã‚¤ã‚ºãŒå¤§ãã„ãŸã‚ç”»åƒã‚’åœ§ç¸®ã—ã¾ã™ (${(size / 1024 / 1024).toFixed(2)}MB)`);

                    // æ®µéšçš„ã«å“è³ªã‚’ä¸‹ã’ã¦åœ§ç¸®
                    const qualities = [0.7, 0.6, 0.5, 0.4, 0.3];
                    for (const q of qualities) {
                        elements = await compressElementImages(STATE.elements, q);
                        project.elements = elements;
                        json = JSON.stringify(project);
                        size = new Blob([json]).size;

                        console.log(`å“è³ª${q}ã§åœ§ç¸®: ${(size / 1024 / 1024).toFixed(2)}MB`);

                        if (size <= MAX_AUTOSAVE_SIZE) {
                            break;
                        }
                    }

                    if (size > MAX_AUTOSAVE_SIZE) {
                        console.warn(`åœ§ç¸®å¾Œã‚‚ã‚µã‚¤ã‚ºãŒå¤§ãã„ãŸã‚ã€ã‚ªãƒ¼ãƒˆã‚»ãƒ¼ãƒ–ã‚’ã‚¹ã‚­ãƒƒãƒ—ã—ã¾ã™ (${(size / 1024 / 1024).toFixed(2)}MB)`);
                        if (!silent) showAutosaveIndicator('error');
                        return;
                    }
                }

                localStorage.setItem(AUTOSAVE_KEY, json);
                if (!silent) showAutosaveIndicator('success');
                console.log(`ã‚ªãƒ¼ãƒˆã‚»ãƒ¼ãƒ–å®Œäº† (${(size / 1024 / 1024).toFixed(2)}MB)`);
            } catch (e) {
                console.error('ã‚ªãƒ¼ãƒˆã‚»ãƒ¼ãƒ–ã«å¤±æ•—ã—ã¾ã—ãŸ:', e);
                if (!silent) showAutosaveIndicator('error');
            }
        }

        const BROKEN_AUTOSAVE_KEY = 'newspaper-editor-autosave-broken';

        function updateUiFromState() {
            document.getElementById('inp-canvas-w').value = STATE.canvas.width;
            document.getElementById('inp-canvas-h').value = STATE.canvas.height;
            document.getElementById('inp-margin-t').value = STATE.canvas.margin.top;
            document.getElementById('inp-margin-b').value = STATE.canvas.margin.bottom;
            document.getElementById('inp-margin-l').value = STATE.canvas.margin.left;
            document.getElementById('inp-margin-r').value = STATE.canvas.margin.right;
            document.getElementById('inp-paper-color').value = STATE.canvas.colors.paper;
            document.getElementById('inp-ink-color').value = STATE.canvas.colors.ink;
            document.getElementById('inp-layout-show').checked = STATE.grid.show;
            document.getElementById('inp-layout-dan').value = STATE.grid.dan;
            document.getElementById('inp-layout-chars').value = STATE.grid.charsPerDan;
            document.getElementById('inp-layout-lines').value = STATE.grid.totalLines;
            document.getElementById('inp-header-left-text').value = STATE.header.left.text;
            document.getElementById('inp-header-left-font').value = STATE.header.left.fontFamily;
            document.getElementById('inp-header-left-size').value = STATE.header.left.fontSize;
            document.getElementById('inp-header-left-weight').value = STATE.header.left.fontWeight;
            document.getElementById('inp-header-left-spacing').value = STATE.header.left.letterSpacing;
            document.getElementById('inp-header-center-text').value = STATE.header.center.text;
            document.getElementById('inp-header-center-font').value = STATE.header.center.fontFamily;
            document.getElementById('inp-header-center-size').value = STATE.header.center.fontSize;
            document.getElementById('inp-header-center-weight').value = STATE.header.center.fontWeight;
            document.getElementById('inp-header-center-spacing').value = STATE.header.center.letterSpacing;
            document.getElementById('inp-header-right-text').value = STATE.header.right.text;
            document.getElementById('inp-header-right-font').value = STATE.header.right.fontFamily;
            document.getElementById('inp-header-right-size').value = STATE.header.right.fontSize;
            document.getElementById('inp-header-right-weight').value = STATE.header.right.fontWeight;
            document.getElementById('inp-header-right-spacing').value = STATE.header.right.letterSpacing;
            document.getElementById('inp-snap-article').checked = STATE.articleSnapMode;
        }

        function loadAutoSave() {
            const json = localStorage.getItem(AUTOSAVE_KEY);

            if (!json) {
                const brokenJson = localStorage.getItem(BROKEN_AUTOSAVE_KEY);
                if (brokenJson) {
                    setTimeout(() => {
                        alert('ä»¥å‰ã«ç ´æã—ãŸè‡ªå‹•ä¿å­˜ãƒ‡ãƒ¼ã‚¿ã®ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ãŒè¦‹ã¤ã‹ã‚Šã¾ã—ãŸã€‚é–‹ç™ºè€…ã«ãŠå•ã„åˆã‚ã›ãã ã•ã„ã€‚');
                    }, 1500);
                }
                return false;
            }

            try {
                const project = JSON.parse(json);
                if (!project || !project.version) {
                    throw new Error('Invalid project data structure');
                }

                const timestamp = project.timestamp ? new Date(project.timestamp).toLocaleString('ja-JP') : 'ä¸æ˜';
                if (!confirm(`è‡ªå‹•ä¿å­˜ã•ã‚ŒãŸãƒ‡ãƒ¼ã‚¿ãŒã‚ã‚Šã¾ã™ã€‚\nä¿å­˜æ—¥æ™‚: ${timestamp}\n\nå¾©å…ƒã—ã¾ã™ã‹ï¼Ÿ`)) {
                    return false;
                }

                // ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆèª­ã¿è¾¼ã¿
                STATE.canvas = project.canvas;
                STATE.grid.show = project.grid.show;
                STATE.grid.dan = project.grid.dan;
                STATE.grid.charsPerDan = project.grid.charsPerDan;
                STATE.grid.totalLines = project.grid.totalLines;
                STATE.header = project.header;
                STATE.articleSnapMode = project.articleSnapMode !== undefined ? project.articleSnapMode : true;
                STATE.elements = project.elements;
                normalizeTextElements(STATE.elements);

                // UIæ›´æ–°ã¨å†æç”»
                updateUiFromState();
                updateCanvasSize();
                updateGridSettings();
                updateColors();
                renderHeaderTexts();
                document.querySelectorAll('.element-group').forEach(el => el.remove());
                document.getElementById('layer-content').innerHTML = '';
                document.getElementById('layer-ui').innerHTML = '';
                setIpadMode(STATE.ipadMode);
                renderDanLines();

                // å±¥æ­´ãƒªã‚»ãƒƒãƒˆ
                STATE.history = [];
                STATE.historyIndex = -1;
                saveHistory();

                alert("è‡ªå‹•ä¿å­˜ãƒ‡ãƒ¼ã‚¿ã‚’å¾©å…ƒã—ã¾ã—ãŸã€‚");
                return true;

            } catch (e) {
                console.error('è‡ªå‹•ä¿å­˜ãƒ‡ãƒ¼ã‚¿ã®èª­ã¿è¾¼ã¿ã«å¤±æ•—:', e);

                localStorage.setItem(BROKEN_AUTOSAVE_KEY, json);
                localStorage.removeItem(AUTOSAVE_KEY);

                alert('è‡ªå‹•ä¿å­˜ãƒ‡ãƒ¼ã‚¿ãŒç ´æã—ã¦ã„ãŸãŸã‚èª­ã¿è¾¼ã‚ã¾ã›ã‚“ã§ã—ãŸã€‚\nç ´æã—ãŸãƒ‡ãƒ¼ã‚¿ã¯ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ã•ã‚Œã¾ã—ãŸã€‚\næ–°ã—ã„ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã¨ã—ã¦é–‹å§‹ã—ã¾ã™ã€‚');

                return false;
            }
        }

        function clearAutoSave() {
            try {
                localStorage.removeItem(AUTOSAVE_KEY);
            } catch (e) {
                console.error('ã‚ªãƒ¼ãƒˆã‚»ãƒ¼ãƒ–ã®ã‚¯ãƒªã‚¢ã«å¤±æ•—ã—ã¾ã—ãŸ:', e);
            }
        }

        // ãƒšãƒ¼ã‚¸èª­ã¿è¾¼ã¿æ™‚ã«ã‚ªãƒ¼ãƒˆã‚»ãƒ¼ãƒ–ã‚’å¾©å…ƒ
        window.addEventListener('load', () => {
            // ã¾ãšã‚ªãƒ¼ãƒˆã‚»ãƒ¼ãƒ–ãƒ‡ãƒ¼ã‚¿ã‚’èª­ã¿è¾¼ã‚“ã§ã‹ã‚‰å®šæœŸä¿å­˜ã‚’é–‹å§‹
            loadAutoSave();

            // ã‚ªãƒ¼ãƒˆã‚»ãƒ¼ãƒ–èª­ã¿è¾¼ã¿å¾Œã«åˆæœŸå±¥æ­´ã‚’ä¿å­˜
            // ã“ã‚Œã«ã‚ˆã‚ŠUndo/Redoã®åˆæœŸçŠ¶æ…‹ãŒç¢ºä¿ã•ã‚Œã‚‹
            saveHistory();

            // å®šæœŸçš„ãªã‚ªãƒ¼ãƒˆã‚»ãƒ¼ãƒ– (30ç§’ã”ã¨)
            // æœ€åˆã®å®Ÿè¡Œã¯30ç§’å¾Œãªã®ã§ã€èª­ã¿è¾¼ã¿ç›´å¾Œã«ä¸Šæ›¸ãã•ã‚Œã‚‹ã“ã¨ã¯ãªã„
            setInterval(() => {
                autoSave(false); // å¿…ãšã‚¤ãƒ³ã‚¸ã‚±ãƒ¼ã‚¿ãƒ¼ã‚’è¡¨ç¤º
            }, 30000);
        });

        // ãƒ–ãƒ©ã‚¦ã‚¶ã‚’é–‰ã˜ã‚‹æ™‚ã«è­¦å‘Šã‚’è¡¨ç¤º
        window.addEventListener('beforeunload', (e) => {
            // è¦ç´ ãŒå­˜åœ¨ã™ã‚‹å ´åˆã®ã¿è­¦å‘Š
            if (STATE.elements.length > 0) {
                e.preventDefault();
                e.returnValue = ''; // Chrome requires returnValue to be set
            }
        });

        // ===== iPadå¯¾å¿œãƒ¢ãƒ¼ãƒ‰ =====
        // iPad/iOSãƒ‡ãƒã‚¤ã‚¹ã‚’æ¤œå‡º
        function detectIpadDevice() {
            const ua = navigator.userAgent || navigator.vendor || window.opera;

            // iPadæ¤œå‡º
            const isIpad = /iPad/i.test(ua) ||
                (navigator.platform === 'MacIntel' && navigator.maxTouchPoints > 1);

            // iPhoneæ¤œå‡º
            const isIphone = /iPhone/i.test(ua);

            // iPodæ¤œå‡º
            const isIpod = /iPod/i.test(ua);

            return isIpad || isIphone || isIpod;
        }

        function setIpadMode(enabled) {
            STATE.ipadMode = enabled;
            updateIpadModeIndicator();
            STATE.elements.forEach(data => renderElement(data));
            if (STATE.selectedId) {
                renderUi();
            }
        }

        // iPadãƒ¢ãƒ¼ãƒ‰ã®åˆ‡ã‚Šæ›¿ãˆ
        function toggleIpadMode() {
            setIpadMode(!STATE.ipadMode);
        }

        // iPadãƒ¢ãƒ¼ãƒ‰ã‚¤ãƒ³ã‚¸ã‚±ãƒ¼ã‚¿ãƒ¼ã®æ›´æ–°
        function updateIpadModeIndicator() {
            const btn = document.getElementById('btn-ipad-mode');
            if (STATE.ipadMode) {
                btn.classList.add('ipad-mode-active');
            } else {
                btn.classList.remove('ipad-mode-active');
            }
        }

        // ===== ã‚­ãƒ¼ãƒœãƒ¼ãƒ‰ã‚¤ãƒ™ãƒ³ãƒˆãƒãƒ³ãƒ‰ãƒ©ãƒ¼ =====
        document.addEventListener('keydown', (e) => {
            // ãƒ†ã‚­ã‚¹ãƒˆå…¥åŠ›ä¸­ã¯ç„¡è¦–
            const target = e.target;
            if (target.tagName === 'INPUT' || target.tagName === 'TEXTAREA' || target.tagName === 'SELECT') {
                return;
            }

            // Ctrl+Z: Undo
            if ((e.ctrlKey || e.metaKey) && e.key === 'z' && !e.shiftKey) {
                e.preventDefault();
                undo();
                return;
            }

            // Ctrl+Shift+Z ã¾ãŸã¯ Ctrl+Y: Redo
            if ((e.ctrlKey || e.metaKey) && (e.key === 'y' || (e.key === 'z' && e.shiftKey))) {
                e.preventDefault();
                redo();
                return;
            }

            // Delete ã¾ãŸã¯ Backspace: é¸æŠè¦ç´ ã‚’å‰Šé™¤
            if (e.key === 'Delete' || e.key === 'Backspace') {
                e.preventDefault();
                if (STATE.selectedId) {
                    deleteSelected();
                    saveHistory();
                }
                return;
            }

            // Escape: é¸æŠè§£é™¤
            if (e.key === 'Escape') {
                e.preventDefault();
                selectElement(null);
                return;
            }

            // ãƒ„ãƒ¼ãƒ«åˆ‡ã‚Šæ›¿ãˆã‚·ãƒ§ãƒ¼ãƒˆã‚«ãƒƒãƒˆ
            if (!e.ctrlKey && !e.metaKey && !e.shiftKey && !e.altKey) {
                switch (e.key.toUpperCase()) {
                    case 'V':
                        e.preventDefault();
                        setMode('select');
                        break;
                    case 'H':
                        e.preventDefault();
                        setMode('hand');
                        break;
                    case 'T':
                        e.preventDefault();
                        setMode('text');
                        break;
                    case 'F':
                        e.preventDefault();
                        setMode('freetext');
                        break;
                    case 'M':
                        e.preventDefault();
                        setMode('masthead');
                        break;
                    case 'R':
                        e.preventDefault();
                        setMode('rect');
                        break;
                    case 'L':
                        e.preventDefault();
                        setMode('vline');
                        break;
                    case 'I':
                        e.preventDefault();
                        setMode('image');
                        break;
                }
            }
        });

        // åˆæœŸåŒ–: ã‚°ãƒªãƒƒãƒ‰ã¨æ®µé–“ç½«ç·šã‚’æç”»
        renderPaperGrid();
        renderBorder();

        // ===== ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆä¿å­˜ãƒ»èª­ã¿è¾¼ã¿ =====
        function saveProject() {
            const project = {
                version: '1.0',
                canvas: STATE.canvas,
                grid: {
                    show: STATE.grid.show,
                    dan: STATE.grid.dan,
                    charsPerDan: STATE.grid.charsPerDan,
                    totalLines: STATE.grid.totalLines
                },
                header: STATE.header,
                articleSnapMode: STATE.articleSnapMode,
                elements: STATE.elements
            };

            const json = JSON.stringify(project, null, 2);
            const blob = new Blob([json], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'æ–°èãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆ.json';
            a.click();
            URL.revokeObjectURL(url);

            // ä¿å­˜å¾Œã¯ã‚ªãƒ¼ãƒˆã‚»ãƒ¼ãƒ–ã‚’ã‚¯ãƒªã‚¢
            clearAutoSave();
        }

        function updateUiFromState() {
            document.getElementById('inp-canvas-w').value = STATE.canvas.width;
            document.getElementById('inp-canvas-h').value = STATE.canvas.height;
            document.getElementById('inp-margin-t').value = STATE.canvas.margin.top;
            document.getElementById('inp-margin-b').value = STATE.canvas.margin.bottom;
            document.getElementById('inp-margin-l').value = STATE.canvas.margin.left;
            document.getElementById('inp-margin-r').value = STATE.canvas.margin.right;
            document.getElementById('inp-paper-color').value = STATE.canvas.colors.paper;
            document.getElementById('inp-ink-color').value = STATE.canvas.colors.ink;
            document.getElementById('inp-layout-show').checked = STATE.grid.show;
            document.getElementById('inp-layout-dan').value = STATE.grid.dan;
            document.getElementById('inp-layout-chars').value = STATE.grid.charsPerDan;
            document.getElementById('inp-layout-lines').value = STATE.grid.totalLines;
            document.getElementById('inp-header-left-text').value = STATE.header.left.text;
            document.getElementById('inp-header-left-font').value = STATE.header.left.fontFamily;
            document.getElementById('inp-header-left-size').value = STATE.header.left.fontSize;
            document.getElementById('inp-header-left-weight').value = STATE.header.left.fontWeight;
            document.getElementById('inp-header-left-spacing').value = STATE.header.left.letterSpacing;
            document.getElementById('inp-header-center-text').value = STATE.header.center.text;
            document.getElementById('inp-header-center-font').value = STATE.header.center.fontFamily;
            document.getElementById('inp-header-center-size').value = STATE.header.center.fontSize;
            document.getElementById('inp-header-center-weight').value = STATE.header.center.fontWeight;
            document.getElementById('inp-header-center-spacing').value = STATE.header.center.letterSpacing;
            document.getElementById('inp-header-right-text').value = STATE.header.right.text;
            document.getElementById('inp-header-right-font').value = STATE.header.right.fontFamily;
            document.getElementById('inp-header-right-size').value = STATE.header.right.fontSize;
            document.getElementById('inp-header-right-weight').value = STATE.header.right.fontWeight;
            document.getElementById('inp-header-right-spacing').value = STATE.header.right.letterSpacing;
            document.getElementById('inp-snap-article').checked = STATE.articleSnapMode;
        }

        function loadProject(json, isAutoSave = false) {
            try {
                const project = JSON.parse(json);
                if (!project || !project.version) throw new Error('ä¸æ­£ãªãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆãƒ•ã‚¡ã‚¤ãƒ«ã§ã™ã€‚');

                if (isAutoSave) {
                    const timestamp = project.timestamp ? new Date(project.timestamp).toLocaleString('ja-JP') : 'ä¸æ˜';
                    if (!confirm(`è‡ªå‹•ä¿å­˜ã•ã‚ŒãŸãƒ‡ãƒ¼ã‚¿ãŒã‚ã‚Šã¾ã™ã€‚\nä¿å­˜æ—¥æ™‚: ${timestamp}\n\nå¾©å…ƒã—ã¾ã™ã‹ï¼Ÿ`)) {
                        return false;
                    }
                }

                STATE.canvas = project.canvas;
                STATE.grid.show = project.grid.show;
                STATE.grid.dan = project.grid.dan;
                STATE.grid.charsPerDan = project.grid.charsPerDan;
                STATE.grid.totalLines = project.grid.totalLines;
                STATE.header = project.header;
                STATE.articleSnapMode = project.articleSnapMode !== undefined ? project.articleSnapMode : true;
                STATE.elements = project.elements;

                normalizeTextElements(STATE.elements);
                updateUiFromState(); // ã“ã®é–¢æ•°ã¯å¾Œã§è¿½åŠ ã•ã‚Œã‚‹æƒ³å®š

                STATE.selectedId = null;
                updateCanvasSize();
                updateGridSettings();
                updateColors();
                renderHeaderTexts();
                document.querySelectorAll('.element-group').forEach(el => el.remove());
                document.getElementById('layer-content').innerHTML = '';
                document.getElementById('layer-ui').innerHTML = '';
                STATE.elements.forEach(data => renderElement(data));
                renderDanLines();

                STATE.history = [];
                STATE.historyIndex = -1;
                saveHistory();

                if (!isAutoSave) {
                    clearAutoSave();
                    alert('ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã‚’èª­ã¿è¾¼ã¿ã¾ã—ãŸã€‚');
                } else {
                    alert("è‡ªå‹•ä¿å­˜ãƒ‡ãƒ¼ã‚¿ã‚’å¾©å…ƒã—ã¾ã—ãŸã€‚");
                }
                return true;

            } catch (e) {
                console.error(e);
                if (isAutoSave) {
                    console.error('ã‚ªãƒ¼ãƒˆã‚»ãƒ¼ãƒ–ã®å¾©å…ƒã«å¤±æ•—ã—ã¾ã—ãŸã€‚', e);
                    // ç ´æã‚’ãƒ¦ãƒ¼ã‚¶ãƒ¼ã«é€šçŸ¥ã—ã€å¤ã„ç ´æãƒ‡ãƒ¼ã‚¿ã‚’ã‚¯ãƒªã‚¢
                    alert('è‡ªå‹•ä¿å­˜ãƒ‡ãƒ¼ã‚¿ãŒç ´æã—ã¦ã„ã‚‹ãŸã‚ã€å¾©å…ƒã§ãã¾ã›ã‚“ã§ã—ãŸã€‚');
                    localStorage.removeItem('newspaper-editor-autosave-broken'); // è©¦è¡Œæ¸ˆã¿ã®ç ´æãƒ‡ãƒ¼ã‚¿ã‚’å‰Šé™¤
                } else {
                    alert('ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã®èª­ã¿è¾¼ã¿ã«å¤±æ•—ã—ã¾ã—ãŸã€‚\n' + e.message);
                }
                return false;
            }
        }

        function newProject() {
            if (!confirm('æ–°è¦ä½œæˆã—ã¾ã™ã‹ï¼Ÿç¾åœ¨ã®å†…å®¹ã¯å¤±ã‚ã‚Œã¾ã™ã€‚')) return;

            STATE.elements = [];
            STATE.selectedId = null;
            STATE.mode = 'select';
            STATE.articleSnapMode = true;
            STATE.linking = null;
            STATE.cropMode = false;
            STATE.cropEdge = null;
            STATE.canvas = { width: 297, height: 420, margin: { top: 20, bottom: 20, left: 20, right: 20 }, colors: { paper: '#ffffff', ink: '#333333' } };
            STATE.grid = { show: true, dan: 6, charsPerDan: 11, totalLines: 25, computed: { charSizeW: 0, charSizeH: 0, lineGap: 0, danHeight: 0, danPitch: 0, pitchX: 0 } };
            STATE.header = {
                left: { text: '20XXå¹´ï¼ˆä»¤å’ŒXå¹´ï¼‰XXæœˆXXæ—¥', fontFamily: '"Noto Sans JP", sans-serif', fontSize: 4, fontWeight: 700, letterSpacing: 0 },
                center: { text: 'ç©ºæƒ³æ–°è', fontFamily: '"Noto Serif JP", serif', fontSize: 6, fontWeight: 900, letterSpacing: 10 },
                right: { text: 'â—‹â—‹ã«ã¤ã„ã¦æ·±ãçŸ¥ã‚‹ã€‚', fontFamily: '"Noto Sans JP", sans-serif', fontSize: 4, fontWeight: 400, letterSpacing: 0 }
            };

            document.getElementById('inp-canvas-w').value = STATE.canvas.width;
            document.getElementById('inp-canvas-h').value = STATE.canvas.height;
            document.getElementById('inp-margin-t').value = STATE.canvas.margin.top;
            document.getElementById('inp-margin-b').value = STATE.canvas.margin.bottom;
            document.getElementById('inp-margin-l').value = STATE.canvas.margin.left;
            document.getElementById('inp-margin-r').value = STATE.canvas.margin.right;
            document.getElementById('inp-paper-color').value = STATE.canvas.colors.paper;
            document.getElementById('inp-ink-color').value = STATE.canvas.colors.ink;
            document.getElementById('inp-layout-show').checked = STATE.grid.show;
            document.getElementById('inp-layout-dan').value = STATE.grid.dan;
            document.getElementById('inp-layout-chars').value = STATE.grid.charsPerDan;
            document.getElementById('inp-layout-lines').value = STATE.grid.totalLines;
            document.getElementById('inp-header-left-text').value = STATE.header.left.text;
            document.getElementById('inp-header-left-font').value = STATE.header.left.fontFamily;
            document.getElementById('inp-header-left-size').value = STATE.header.left.fontSize;
            document.getElementById('inp-header-left-weight').value = STATE.header.left.fontWeight;
            document.getElementById('inp-header-left-spacing').value = STATE.header.left.letterSpacing;
            document.getElementById('inp-header-center-text').value = STATE.header.center.text;
            document.getElementById('inp-header-center-font').value = STATE.header.center.fontFamily;
            document.getElementById('inp-header-center-size').value = STATE.header.center.fontSize;
            document.getElementById('inp-header-center-weight').value = STATE.header.center.fontWeight;
            document.getElementById('inp-header-center-spacing').value = STATE.header.center.letterSpacing;
            document.getElementById('inp-header-right-text').value = STATE.header.right.text;
            document.getElementById('inp-header-right-font').value = STATE.header.right.fontFamily;
            document.getElementById('inp-header-right-size').value = STATE.header.right.fontSize;
            document.getElementById('inp-header-right-weight').value = STATE.header.right.fontWeight;
            document.getElementById('inp-header-right-spacing').value = STATE.header.right.letterSpacing;
            document.getElementById('inp-snap-article').checked = STATE.articleSnapMode;

            // æ—¢å­˜ã®è¦ç´ ã‚’ã™ã¹ã¦å‰Šé™¤
            document.querySelectorAll('.element-group').forEach(el => el.remove());
            document.getElementById('layer-content').innerHTML = '';
            document.getElementById('layer-ui').innerHTML = '';

            // ã‚­ãƒ£ãƒ³ãƒã‚¹ã¨è¨­å®šã‚’æ›´æ–°
            updateCanvasSize();
            updateColors();
            renderHeaderTexts();
            renderDanLines();

            // å±¥æ­´ã‚’ãƒªã‚»ãƒƒãƒˆ
            STATE.history = [];
            STATE.historyIndex = -1;
            saveHistory();
            setMode('select');

            // æ–°è¦ä½œæˆæ™‚ã¯ã‚ªãƒ¼ãƒˆã‚»ãƒ¼ãƒ–ã‚’ã‚¯ãƒªã‚¢
            clearAutoSave();
        }

        function openProjectFile() {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.json';
            input.onchange = (e) => {
                const file = e.target.files[0];
                if (!file) return;
                const reader = new FileReader();
                reader.onload = (event) => loadProject(event.target.result);
                reader.readAsText(file);
            };
            input.click();
        }

        // ãƒ‰ãƒ©ãƒƒã‚°&ãƒ‰ãƒ­ãƒƒãƒ—
        const dropOverlay = document.createElement('div');
        dropOverlay.innerHTML = '<div style="font-size:32px;color:white;font-weight:bold;text-align:center;padding:40px;background:rgba(0,0,0,0.3);border-radius:20px;">ğŸ“„ JSONãƒ•ã‚¡ã‚¤ãƒ«ã‚’ãƒ‰ãƒ­ãƒƒãƒ—ã—ã¦èª­ã¿è¾¼ã¿</div>';
        dropOverlay.style.cssText = 'position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(33,150,243,0.9);display:none;justify-content:center;align-items:center;z-index:10000;pointer-events:none;';
        document.body.appendChild(dropOverlay);

        let dragCounter = 0;
        document.addEventListener('dragenter', (e) => { e.preventDefault(); dragCounter++; if (dragCounter === 1) dropOverlay.style.display = 'flex'; });
        document.addEventListener('dragleave', (e) => { e.preventDefault(); dragCounter--; if (dragCounter === 0) dropOverlay.style.display = 'none'; });
        document.addEventListener('dragover', (e) => e.preventDefault());
        document.addEventListener('drop', (e) => {
            e.preventDefault();
            dragCounter = 0;
            dropOverlay.style.display = 'none';
            const files = e.dataTransfer.files;
            if (files.length > 0 && files[0].name.endsWith('.json')) {
                const reader = new FileReader();
                reader.onload = (event) => loadProject(event.target.result);
                reader.readAsText(files[0]);
            } else {
                alert('JSONãƒ•ã‚¡ã‚¤ãƒ«ã®ã¿èª­ã¿è¾¼ã‚ã¾ã™ã€‚');
            }
        });


    </script>
</body>

</html>
