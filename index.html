<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="theme-color" content="#111111">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black">
<link rel="manifest" href="manifest.webmanifest">
<link rel="icon" type="image/png" sizes="192x192" href="icons/icon-192.png">
<link rel="icon" type="image/png" sizes="512x512" href="icons/icon-512.png">
<link rel="apple-touch-icon" sizes="180x180" href="icons/apple-touch-icon-180.png">
<title>æ–°èä½œæˆãƒ„ãƒ¼ãƒ«</title>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<!-- Google Fonts ä¸€æ‹¬èª­ã¿è¾¼ã¿ -->
<link href="https://fonts.googleapis.com/css2?family=BIZ+UDGothic&family=Biz+UDMincho&family=Dela+Gothic+One&family=DotGothic16&family=Hachi+Maru+Pop&family=Klee+One&family=Noto+Sans+JP:wght@400;700;900&family=Noto+Serif+JP:wght@400;700;900&family=Reggae+One&family=RocknRoll+One&family=Shippori+Mincho:wght@400;700;800&family=Yuji+Boku&family=Yuji+Mai&family=Yuji+Syuku&family=Zen+Kurenaido&family=Zen+Maru+Gothic:wght@400;700;900&display=swap" rel="stylesheet">
<!-- ç”»åƒç”Ÿæˆç”¨ãƒ©ã‚¤ãƒ–ãƒ©ãƒª -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>

<style>
  :root {
    /* === åŸºæœ¬è¨­å®š === */
    --base-font-size: 24px; 
    --line-gap: 12px;
    
    /* ç”¨ç´™ã‚µã‚¤ã‚º (JSã§åˆ¶å¾¡) */
    --paper-w: 297mm;
    --paper-h: 420mm;

    /* ãƒãƒ¼ã‚¸ãƒ³ */
    --m-top: 30mm; --m-bottom: 30mm; --m-inner: 20mm; --m-outer: 20mm;
    
    /* å¾®èª¿æ•´ */
    --nudge-x: 0px; --nudge-y: 0px;
    --font-family: "BIZ UDMincho", serif;
    --font-weight: 400;
    --scale-y: 0.85; /* æ–°èç‰¹æœ‰ã®æ‰å¹³ç‡ */
    --glyph-scale: 1.0; 

    /* è‰²è¨­å®š */
    --text-color: #111111; /* ã‚¤ãƒ³ã‚¯ã®è‰² */
    --paper-color: #fcfcfc; /* ç´™ã®è‰² */
    --border-width: 1px;
    --divider-width: 1px;
    --grid-color: #dddddd;
    
    /* ã‚ãµã‚Œè­¦å‘Šè‰² */
    --overflow-color: #cd5c5c; 
    
    /* UIè‰²ï¼ˆãƒ¢ãƒã‚¯ãƒ­ï¼‰ */
    --ui-bg: #ffffff;
    --ui-border: #dddddd;
    --ui-text: #333333;
    --ui-hover: #f5f5f5;
    --ui-active: #000000;
    --ui-active-text: #ffffff;
  }

  body {
    background-color: #f0f0f0; margin: 0; padding: 0;
    font-family: "Noto Sans JP", sans-serif;
    height: 100vh; width: 100vw; overflow: hidden;
    user-select: none; touch-action: none; 
  }

  /* ãƒãƒ³ãƒ‰ãƒ¢ãƒ¼ãƒ‰æ™‚ã®é€é */
  body.tool-hand .article-group,
  body.tool-hand .resize-handle,
  body.tool-hand .port {
    pointer-events: none !important;
  }

  /* --- å·¦ã‚µã‚¤ãƒ‰ãƒãƒ¼ (ãƒ„ãƒ¼ãƒ«ãƒãƒ¼) --- */
  .toolbar-container {
    position: fixed; top: 0; left: 0; 
    width: 80px; height: 100vh; 
    z-index: 2000;
    background: var(--ui-bg);
    border-right: 1px solid var(--ui-border);
    display: flex; flex-direction: column;
    padding: 20px 0;
    box-sizing: border-box;
    overflow-y: auto; /* å°ã•ã„ç”»é¢ã§ã‚‚ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«å¯èƒ½ã« */
  }

  .tool-group {
    display: flex; flex-direction: column; 
    border-bottom: 1px solid var(--ui-border);
    padding: 10px 0;
  }
  .tool-group:last-child {
    border-bottom: none;
    margin-top: auto; /* æœ€å¾Œã®ã‚°ãƒ«ãƒ¼ãƒ—ã‚’ä¸‹ã«é…ç½® */
  }
  
  .tool-btn {
    width: 100%; height: 64px; 
    border: none; background: transparent; 
    color: var(--ui-text);
    cursor: pointer; 
    display: flex; flex-direction: column;
    justify-content: center; align-items: center;
    transition: all 0.15s;
    position: relative;
    gap: 4px;
  }
  .tool-btn:hover { 
    background: var(--ui-hover); 
  }
  .tool-btn.active { 
    background: var(--ui-active); 
    color: var(--ui-active-text); 
  }
  .tool-btn.active .duotone-icon {
    fill: var(--ui-active-text);
  }
  
  .tool-icon {
    width: 24px; height: 24px;
    display: flex; justify-content: center; align-items: center;
  }
  .tool-label {
    font-size: 10px;
    font-weight: 500;
    letter-spacing: 0.5px;
  }

  /* ã‚¢ã‚¤ã‚³ãƒ³ã‚¹ã‚¿ã‚¤ãƒ« */
  .duotone-icon {
    width: 24px; height: 24px;
    fill: var(--ui-text);
  }
  .duotone-icon .secondary {
    opacity: 0.4;
  }
  
  /* ä¿å­˜å®Œäº†é€šçŸ¥ */
  #auto-save-indicator {
    position: fixed; bottom: 20px; left: 50%;
    transform: translateX(-50%);
    background: var(--ui-active); color: var(--ui-active-text);
    padding: 8px 16px; border-radius: 4px; font-size: 12px;
    pointer-events: none; opacity: 0; transition: opacity 0.5s; z-index: 3000;
    border: 1px solid var(--ui-border);
  }

  /* ãƒ•ã‚¡ã‚¤ãƒ«ãƒ»ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆãƒ¡ãƒ‹ãƒ¥ãƒ¼ */
  .menu-overlay {
      position: fixed; top: 0; left: 0; width: 100vw; height: 100vh;
      background: rgba(0,0,0,0.3); z-index: 3000; display: none;
      justify-content: center; align-items: center;
  }
  .menu-panel {
      background: var(--ui-bg); padding: 24px; border-radius: 0;
      border: 1px solid var(--ui-border);
      width: 320px; color: var(--ui-text);
      display: flex; flex-direction: column; gap: 12px;
  }
  .menu-header { 
    font-weight: bold; font-size: 16px;
    color: var(--ui-text); 
    border-bottom: 1px solid var(--ui-border); 
    padding-bottom: 12px; margin-bottom: 8px;
  }
  .menu-item {
      padding: 12px; background: var(--ui-bg); 
      border: 1px solid var(--ui-border);
      cursor: pointer; 
      transition: background 0.15s; 
      display: flex; align-items: center; gap: 10px;
      font-size: 14px;
  }
  .menu-item:hover { background: var(--ui-hover); }
  .menu-item span { flex: 1; }
  
  /* --- å³ã‚µã‚¤ãƒ‰ãƒãƒ¼ (è¨­å®šãƒ‘ãƒãƒ«) --- */
  .settings-panel {
    position: fixed; right: 0; top: 0; 
    width: 320px; height: 100vh;
    z-index: 2000;
    background: var(--ui-bg); color: var(--ui-text); 
    border-left: 1px solid var(--ui-border);
    font-size: 13px; 
    overflow-y: auto; overflow-x: hidden;
    box-sizing: border-box;
    padding: 20px;
  }

  .ui-header { 
    font-weight: bold; 
    font-size: 13px;
    margin-bottom: 12px; 
    color: var(--ui-text); 
    border-bottom: 1px solid var(--ui-border); 
    padding-bottom: 8px; 
    margin-top: 24px; 
  }
  .ui-header:first-child { margin-top: 0; }
  
  .ui-row { 
    margin-bottom: 12px; 
    display: flex; 
    justify-content: space-between; 
    align-items: center; 
    gap: 8px; 
    width: 100%; 
    box-sizing: border-box;
  }
  .ui-row label { 
    color: var(--ui-text); 
    min-width: 70px; 
    white-space: nowrap;
    font-size: 12px;
  }
  .ui-row input[type="range"] { 
    flex: 1; cursor: pointer; margin: 0 8px; min-width: 0; 
  }
  .ui-row input[type="text"], 
  .ui-row input[type="number"] { 
    flex: 1; 
    background: var(--ui-bg); 
    color: var(--ui-text); 
    border: 1px solid var(--ui-border); 
    padding: 6px 8px; 
    border-radius: 0; 
    min-width: 0;
    font-size: 12px;
  }
  .ui-row input[type="color"] { 
    width: 40px; height: 28px; 
    border: 1px solid var(--ui-border); 
    cursor: pointer; padding: 0; 
    background: none;
  }
  .ui-row input[type="checkbox"] { 
    cursor: pointer; 
    transform: scale(1.3); 
  }
  .ui-row select { 
    flex: 1; 
    background: var(--ui-bg); 
    color: var(--ui-text); 
    border: 1px solid var(--ui-border); 
    padding: 6px 8px; 
    border-radius: 0; 
    min-width: 0; 
    text-overflow: ellipsis;
    font-size: 12px;
  }
  .val { 
    width: 40px; 
    text-align: right; 
    color: var(--ui-text); 
    font-weight: 600; 
    white-space: nowrap;
    font-size: 12px;
  }
  .calc-info { 
    font-size: 11px; 
    color: #666; 
    text-align: right; 
    margin-bottom: 12px; 
    line-height: 1.4;
  }
  
  .btn-small {
      background: var(--ui-bg); 
      color: var(--ui-text); 
      border: 1px solid var(--ui-border); 
      padding: 4px 12px; 
      cursor: pointer; 
      border-radius: 0;
      font-size: 12px;
      transition: background 0.15s;
  }
  .btn-small:hover { background: var(--ui-hover); }
  
  .btn-group-row { 
    display: flex; 
    width: 100%; 
    border: 1px solid var(--ui-border); 
    border-radius: 0; 
    overflow: hidden; 
    margin-bottom: 12px;
  }
  .btn-group-item { 
    flex: 1; 
    background: var(--ui-bg); 
    color: var(--ui-text); 
    border: none; 
    border-right: 1px solid var(--ui-border); 
    padding: 8px 4px; 
    cursor: pointer; 
    font-size: 11px; 
    white-space: nowrap; 
    overflow: hidden; 
    text-overflow: ellipsis;
    transition: background 0.15s;
  }
  .btn-group-item:last-child { border-right: none; }
  .btn-group-item:hover { background: var(--ui-hover); }
  .btn-group-item.active { 
    background: var(--ui-active); 
    color: var(--ui-active-text); 
  }

  /* ã‚¤ãƒ³ã‚¯èª¿æ•´ç”¨ã‚¹ãƒ©ã‚¤ãƒ€ãƒ¼ã‚¨ãƒªã‚¢ */
  #ink-adjust-area {
      background: var(--ui-hover); 
      padding: 12px; 
      border-radius: 0; 
      margin-top: 8px; 
      border: 1px solid var(--ui-border); 
      display: none;
  }

  /* ãƒ‘ãƒãƒ«åˆ‡ã‚Šæ›¿ãˆç”¨ */
  .panel-section { display: none; }
  .panel-section.active { display: block; }

  /* ãƒŠãƒƒã‚¸ãƒ‘ãƒƒãƒ‰ï¼ˆä½ç½®èª¿æ•´ï¼‰ */
  .nudge-pad {
    display: flex; 
    flex-direction: column; 
    align-items: center; 
    gap: 4px; 
    margin-bottom: 16px;
    background: var(--ui-hover); 
    padding: 12px; 
    border-radius: 0; 
    border: 1px solid var(--ui-border);
  }
  .nudge-row { display: flex; gap: 4px; }
  .nudge-btn {
    width: 36px; height: 36px; 
    background: var(--ui-bg); 
    border: 1px solid var(--ui-border); 
    color: var(--ui-text);
    border-radius: 0; 
    cursor: pointer; 
    display: flex; 
    justify-content: center; 
    align-items: center;
    font-size: 14px; 
    transition: background 0.15s;
  }
  .nudge-btn:hover { background: var(--ui-hover); }
  .nudge-btn:active { background: var(--ui-active); color: var(--ui-active-text); }
  .nudge-reset { 
    font-size: 9px; 
    font-weight: bold; 
    color: var(--ui-text); 
  }

  /* ç”»åƒã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ãƒ»ãƒˆãƒªãƒŸãƒ³ã‚°ç”¨ */
  .file-upload-btn, .action-btn {
      display: block; 
      width: 100%; 
      padding: 10px; 
      background: var(--ui-bg); 
      border: 1px solid var(--ui-border); 
      color: var(--ui-text);
      cursor: pointer; 
      text-align: center; 
      border-radius: 0; 
      margin-bottom: 10px; 
      box-sizing: border-box;
      font-size: 13px;
      transition: background 0.15s;
  }
  .file-upload-btn:hover, .action-btn:hover { 
    background: var(--ui-hover); 
  }
  #inp-image-file { display: none; }

  /* ã‚ãµã‚Œæƒ…å ±è¡¨ç¤ºã‚¨ãƒªã‚¢ */
  #overflow-info-box {
    background: var(--ui-hover); 
    border: 1px solid var(--ui-border); 
    padding: 12px; 
    margin-bottom: 16px; 
    border-radius: 0;
    color: var(--ui-text); 
    display: none; 
  }
  .overflow-warning { color: #d32f2f; font-weight: bold; }
  .overflow-ok { color: #388e3c; }

  /* --- ãƒ“ãƒ¥ãƒ¼ãƒãƒ¼ãƒˆ --- */
  #viewport {
    position: absolute; 
    top: 0; 
    left: 80px; 
    width: calc(100% - 400px); 
    height: 100%;
    overflow: hidden; 
    background: #f0f0f0; 
    cursor: default;
  }
  #canvas-transform { 
    transform-origin: 0 0; 
    position: absolute; 
    top: 0; 
    left: 0; 
  }

  .paper {
    width: var(--paper-w); height: var(--paper-h); 
    background-color: var(--paper-color);
    position: absolute; top: 50px; left: 50px;
    box-shadow: 0 0 50px rgba(0,0,0,0.5);
    padding-top: var(--m-top); padding-bottom: var(--m-bottom);
    padding-right: var(--m-inner); padding-left: var(--m-outer);
    box-sizing: border-box; display: flex;
    transition: background-color 0.2s;
  }
  
  /* å¤–å‘¨æƒ…å ± (ç‰ˆé¢å¤–) */
  .margin-info-container {
      position: absolute; left: 0; width: 100%; height: 0; pointer-events: none;
      display: flex; justify-content: space-between; align-items: flex-end;
      padding: 0 var(--m-inner) 0 var(--m-outer); box-sizing: border-box;
  }
  #margin-info-top {
      top: calc(var(--m-top) - 6mm); /* ç‰ˆé¢ã‹ã‚‰6mmä¸Š */
      height: 0; overflow: visible;
  }
  .margin-info-item {
      color: var(--text-color);
      writing-mode: horizontal-tb;
      white-space: nowrap;
      transform-origin: bottom center;
      line-height: 1.0;
  }

  /* ã‚«ãƒ©ãƒ¼ãƒ‘ãƒƒãƒ (ç‰ˆé¢å¤–ä¸‹) */
  #color-patches-bottom {
      position: absolute; left: 0; width: 100%;
      top: calc(100% - var(--m-bottom) + 6mm); /* ç‰ˆé¢ã‹ã‚‰6mmä¸‹ */
      height: 10mm;
      display: flex; justify-content: center; align-items: top;
      pointer-events: none;
  }
  /* ä¹—ç®—ãƒ¢ãƒ¼ãƒ‰ */
  .color-patch-svg { overflow: visible; mix-blend-mode: multiply; }

  /* ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆç·šãƒ¬ã‚¤ãƒ¤ãƒ¼ (æ®µé–“ç½«ç·š: èƒŒé¢) */
  #layout-lines-layer {
    position: absolute; top: 0; left: 0; width: 100%; height: 100%;
    pointer-events: none; 
    z-index: 1; /* è¨˜äº‹ã®å¾Œã‚ */
    overflow: visible;
  }
  /* ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆæ ãƒ¬ã‚¤ãƒ¤ãƒ¼ (å¤–å‘¨æ : æœ€å‰é¢) */
  #layout-border-layer {
    position: absolute; top: 0; left: 0; width: 100%; height: 100%;
    pointer-events: none; 
    z-index: 50; /* è¨˜äº‹ã®æ‰‹å‰ (å¡—ã‚Šã¤ã¶ã•ã‚Œãªã„) */
    overflow: visible;
  }
  
  /* ç·šé¡ã®è‰² - è§’ä¸¸å‡¦ç†è¿½åŠ  */
  .print-border { 
      stroke: var(--text-color); stroke-width: var(--border-width); 
      fill: none; mix-blend-mode: multiply; 
      stroke-linejoin: round; stroke-linecap: round; /* è§’ä¸¸ */
  }
  .print-divider { 
      stroke: var(--text-color); stroke-width: var(--divider-width); 
      fill: none; mix-blend-mode: multiply; 
      stroke-linecap: round; /* ç«¯ä¸¸ */
  }

  .hanmen { width: 100%; height: 100%; position: relative; z-index: 2; }
  
  #grid-layer {
    position: absolute; top: 0; left: 0; width: 100%; 
    height: calc(100% / var(--scale-y));
    pointer-events: none; z-index: 0;
    background-repeat: repeat; background-position: right top;
    transform-origin: top right;
    transform: scaleY(var(--scale-y));
    transition: opacity 0.2s;
    mix-blend-mode: multiply;
  }

  /* --- è¨˜äº‹ã‚°ãƒ«ãƒ¼ãƒ— --- */
  .article-group {
    position: absolute; background: transparent; 
    display: flex; flex-direction: row-reverse; flex-wrap: wrap;
    pointer-events: auto; 
    transition: outline-color 0.2s;
  }
  
  /* é¸æŠæ ãƒ»ã‚ªãƒ¼ãƒãƒ¼ãƒ•ãƒ­ãƒ¼æ ã®æç”» (::afterã‚’ä½¿ç”¨) */
  .article-group::after {
    content: "";
    position: absolute;
    top: 0; left: 0;
    width: 100%; height: 100%;
    pointer-events: none;
    box-sizing: border-box;
    z-index: 50; /* å­è¦ç´ ã‚ˆã‚Šæ‰‹å‰ */
    border: 2px solid transparent;
    transition: border-color 0.2s;
    border-radius: 4px; /* é¸æŠæ ã‚‚å°‘ã—ä¸¸ã */
  }

  .article-group.selected { z-index: 10; }
  .article-group.selected::after { border-color: #2196f3; }

  .article-group.has-overflow { background-color: rgba(205, 92, 92, 0.1); }
  .article-group.has-overflow::after { border-color: var(--overflow-color); }

  .article-group.selected.has-overflow::after {
    border-style: dashed;
    box-shadow: 0 0 10px var(--overflow-color);
  }

body.preview-mode .article-group::after { border-color: transparent !important; box-shadow: none !important; }
body.preview-mode .article-group { background-color: transparent; }

  .article-transform-wrapper {
      transform-origin: top right;
      transform: scaleY(var(--scale-y));
      display: flex; flex-direction: row-reverse; flex-wrap: wrap;
  }

  .resize-handle {
    position: absolute; bottom: -6px; left: -6px;
    width: 10px; height: 10px; background-color: #fff; border: 1px solid #2196f3;
    cursor: nesw-resize; z-index: 60; display: none;
    border-radius: 50%;
  }
  .article-group.selected .resize-handle { display: block; }
  body.preview-mode .resize-handle { display: none !important; }

  /* --- ã‚»ã‚°ãƒ¡ãƒ³ãƒˆ(è¨˜äº‹æœ¬æ–‡) --- */
  .segment {
    width: auto; writing-mode: vertical-rl; 
    --box-size: var(--base-font-size); 
    font-size: calc(var(--box-size) * var(--glyph-scale));
    font-family: var(--font-family);
    font-weight: var(--font-weight);
    line-height: calc(var(--box-size) + var(--line-gap)); 
    letter-spacing: calc(var(--box-size) - (var(--box-size) * var(--glyph-scale)));
    color: var(--text-color); mix-blend-mode: multiply; 
    overflow: visible; 
    white-space: pre-wrap; word-break: normal; overflow-wrap: break-word; text-align: justify;
    font-feature-settings: "palt" 0; pointer-events: none; 
    transform: translate(var(--nudge-x), var(--nudge-y));
  }
  .spacer { width: 100%; height: var(--h-gap); pointer-events: none;}
  
  /* --- è¦‹å‡ºã—ãƒ»ç¸¦ç·šãƒ»ä¿®æ­£ãƒ†ãƒ¼ãƒ—ãƒ»ç”»åƒè¦ç´  --- */
  .headline-wrapper { width: 100%; height: 100%; overflow: hidden; position: relative; pointer-events: none; }
  .headline-inner {
    position: absolute; top: 0; left: 0;
    white-space: nowrap; line-height: 1.0; transform-origin: 0 0;
    display: flex; align-items: center; justify-content: center;
  }
  .headline-v { writing-mode: vertical-rl; transform-origin: top right; right: 0; left: auto; }
  .headline-h { writing-mode: horizontal-tb; transform-origin: top left; }
  .tcy { text-combine-upright: all; text-decoration: none; }

  .correction-box { width: 100%; height: 100%; pointer-events: none; }
  .correction-inner { width: 100%; height: 100%; }

  .vline-box { width: 100%; height: 100%; display: flex; justify-content: center; align-items: center; pointer-events: none; }
  .vline-inner { height: 100%; border-radius: 999px; /* è§’ä¸¸ */ }

  /* ç”»åƒãƒ–ãƒ­ãƒƒã‚¯ç”¨ */
  .image-box { 
      height: calc(100% * var(--scale-y)); 
      width: 100%; 
      display: flex; overflow: hidden; 
      background: transparent;
      pointer-events: none; 
      transform: scaleY(calc(1 / var(--scale-y)));
      transform-origin: top left;
  }

  .image-container {
      flex: 1 1 auto;
      min-width: 0; min-height: 0; 
      position: relative;
      display: flex; align-items: center; justify-content: center;
      background-color: transparent; /* èƒŒæ™¯é€é (ã‚¤ãƒ³ã‚¯ãƒ¢ãƒ¼ãƒ‰ç”¨) */
      color: #888; overflow: hidden;
  }
  .image-content {
      width: 100%; height: 100%; object-fit: cover; display: block;
  }

  .image-caption {
      flex: 0 0 auto; 
      font-size: calc(var(--base-font-size) * 0.5 * var(--glyph-scale));
      line-height: 1.2;
      background: var(--paper-color); /* ç´™è‰² */
      white-space: pre-wrap;
      box-sizing: border-box;
      padding: 3px 5px;
      color: var(--text-color);
      overflow: hidden; 
      z-index: 10;
  }
  .caption-h { writing-mode: horizontal-tb; width: 100%; max-height: 100%; }
  .caption-v { writing-mode: vertical-rl; height: 100%; max-width: 100%; }

  /* é¡Œå­—ï¼ˆãƒ˜ãƒƒãƒ€ãƒ¼ï¼‰Ver.79 Layout */
  .header-container {
      width: 100%; height: 100%; 
      display: flex; flex-direction: column; 
      pointer-events: none;
      transform: translate(var(--nudge-x), var(--nudge-y));
      background-color: var(--paper-color); 
      box-shadow: calc(var(--line-gap)*-1) 0 0 0 var(--paper-color), var(--line-gap) 0 0 0 var(--paper-color); 
  }
  
  .header-title-box-outer {
      flex: 1; 
      border-style: solid; 
      border-color: var(--text-color);
      padding: 4px; 
      box-sizing: border-box;
      display: flex;
      background: var(--paper-color);
      overflow: hidden;
      border-radius: 2px; /* è§’ã‚’å°‘ã—ä¸¸ã */
  }
  
  .header-title-box-inner {
      flex: 1;
      border-style: solid;
      border-color: var(--text-color); 
      position: relative;
      overflow: hidden;
      display: flex; align-items: center; justify-content: center; 
      border-radius: 1px;
      color: var(--text-color); /* ã‚¤ãƒ³ã‚¯è‰²ã‚’ç¶™æ‰¿ */
  }

  .header-bg-pattern {
      position: absolute; top: 0; left: 0; width: 100%; height: 100%;
      z-index: 0; opacity: 1; pointer-events: none;
      color: inherit; /* è¦ªã®colorã‚’ä½¿ã† */
  }

  .header-title-text {
      z-index: 2; 
      background: transparent;
      line-height: 1.0;
      white-space: nowrap;
      position: relative; 
      writing-mode: vertical-rl;
      font-weight: 900;
      paint-order: stroke fill;
  }

  .header-info-area {
      width: 100%; 
      height: auto; 
      flex: 0 0 auto;
      display: flex; 
      flex-direction: column; 
      font-size: calc(var(--base-font-size) * 0.5);
      line-height: 1.2;
      padding: 4px; box-sizing: border-box;
      justify-content: flex-start;
      align-items: flex-start; 
      text-align: left;
      color: var(--text-color);
      writing-mode: horizontal-tb; 
      background-color: var(--paper-color);
      gap: 2px;
      overflow: hidden;
  }
  
  .header-info-item {
      display: block; 
      white-space: normal; 
      word-wrap: break-word;
      overflow-wrap: break-word;
      width: 100%;
  }

  /* --- ã‚¨ãƒ‡ã‚£ã‚¿ãƒ»ãƒ¢ãƒ¼ãƒ€ãƒ«é–¢é€£ --- */
  .inline-editor {
    position: absolute; z-index: 9999; writing-mode: vertical-rl;
    font-size: var(--base-font-size); 
    line-height: calc(var(--base-font-size) + var(--line-gap));
    font-family: var(--font-family); background: rgba(255, 255, 255, 0.95);
    border: 2px solid #2196f3; outline: none; resize: none; padding: 0; box-sizing: border-box;
    white-space: pre-wrap; overflow: auto; box-shadow: 0 5px 25px rgba(0,0,0,0.5);
    pointer-events: auto; cursor: text;
    transform-origin: top right;
    transform: scaleY(var(--scale-y));
  }
  
  .overlay-modal {
    position: fixed; top: 0; left: 0; width: 100vw; height: 100vh;
    background: rgba(0,0,0,0.3); z-index: 9999; display: none;
    justify-content: center; align-items: center; flex-direction: column;
  }
  .modal-panel {
    background: var(--ui-bg); padding: 24px; border-radius: 0;
    border: 1px solid var(--ui-border);
    display: flex; flex-direction: column; gap: 12px;
    max-width: 90%; max-height: 90%;
  }
  .modal-title { 
    color: var(--ui-text); 
    font-weight: bold; 
    font-size: 16px; 
  }
  .modal-buttons { 
    display: flex; 
    justify-content: flex-end; 
    gap: 10px; 
    margin-top: 12px; 
  }
  .modal-btn { 
    padding: 10px 20px; 
    border-radius: 0; 
    cursor: pointer; 
    border: 1px solid var(--ui-border); 
    font-weight: 500;
    transition: background 0.15s;
    font-size: 13px;
  }
  .btn-cancel { 
    background: var(--ui-bg); 
    color: var(--ui-text); 
  }
  .btn-cancel:hover {
    background: var(--ui-hover);
  }
  .btn-save { 
    background: var(--ui-active); 
    color: var(--ui-active-text); 
  }
  .btn-save:hover {
    background: #333;
  }

  /* ãƒ†ã‚­ã‚¹ãƒˆã‚¨ãƒ‡ã‚£ã‚¿ç”¨ */
  #editor-panel { width: 400px; }
  #editor-textarea {
    width: 100%; height: 120px; 
    background: var(--ui-bg); 
    color: var(--ui-text); 
    border: 1px solid var(--ui-border);
    padding: 10px; font-size: 14px; 
    border-radius: 0; resize: vertical; outline: none;
    font-family: inherit;
  }

  /* ãƒˆãƒªãƒŸãƒ³ã‚°ã‚¨ãƒ‡ã‚£ã‚¿ç”¨ */
  #crop-panel { width: auto; height: auto; align-items: center; min-width: 300px; }
  #crop-canvas-container {
      position: relative; overflow: hidden; 
      border: 1px solid var(--ui-border); 
      background: repeating-conic-gradient(#f5f5f5 0% 25%, #e0e0e0 0% 50%) 50% / 20px 20px;
  }
  #crop-canvas { display: block; cursor: move; }
  .crop-controls {
      display: flex; gap: 10px; align-items: center; width: 100%; 
      color: var(--ui-text); font-size: 12px;
  }
  .crop-controls input[type="range"] { flex: 1; }

  /* ã‚¢ã‚¤ã‚³ãƒ³ãƒ»ãƒªãƒ³ã‚¯ */
  .port {
    position: absolute;
    width: 0; height: 0;
    cursor: pointer; z-index: 60; pointer-events: auto; /* z-indexèª¿æ•´ */
    left: 50%; margin-left: -7px; 
    transition: transform 0.15s;
    border-left: 7px solid transparent;
    border-right: 7px solid transparent;
    border-top: 12px solid #444; /* ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆè‰²ã¯å¾Œã§ä¸Šæ›¸ã */
    border-bottom: 0;
    box-shadow: 0 0 2px rgba(0,0,0,0.4);
  }
  .port:hover { transform: scale(1.5); }
  .port-in { top: -8px; border-top-color: #2196f3; }
  .port-in.connected { border-top-color: #ffeb3b; }
  .port-out { bottom: -8px; border-top-color: #ef5350; }
  .port-out.linked { border-top-color: #66bb6a; }
  .port.link-mode-compatible { transform: scale(2); }
  .port.port-hovered { transform: scale(2.2); }
  .article-group.type-headline .port, .article-group.type-correction .port, .article-group.type-vline .port, .article-group.type-image .port, .article-group.type-header .port { display: none; }

  #link-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 5; }
  .link-line { stroke: #ffca28; stroke-width: 2; fill: none; stroke-dasharray: 4; stroke-linecap: round; }
  #temp-link-line { stroke: #ffeb3b; stroke-width: 3; fill: none; stroke-dasharray: 5; stroke-linecap: round; display: none; }

  body.preview-mode .port, body.preview-mode #link-layer, body.preview-mode .inline-editor { display: none !important; }

  .ghost {
    position: absolute; border: 1px solid #2196f3;
    background: rgba(33, 150, 243, 0.2); pointer-events: none; z-index: 100;
  }
  
  #measure-box {
    position: absolute; top: -9999px; left: -9999px; visibility: hidden;
    writing-mode: vertical-rl; white-space: pre-wrap; word-break: normal; overflow-wrap: break-word; text-indent: 0; 
  }
  #headline-measure-box { position: absolute; top: -9999px; left: -9999px; visibility: hidden; white-space: nowrap; line-height: 1.0; }

</style>
</head>
<body class="tool-hand"> 

<!-- SVGãƒ•ã‚£ãƒ«ã‚¿å‹•çš„æ ¼ç´ç”¨ -->
<div id="svg-filters-container" style="position: absolute; width: 0; height: 0; overflow: hidden;">
  <svg>
    <defs>
      <!-- æ¨ªç·šãƒ‘ã‚¿ãƒ¼ãƒ³ (ã‚¤ãƒ³ã‚¯è‰²ã€ãƒãƒ¼ãƒãƒ«æç”») -->
      <pattern id="pat-lines" x="0" y="0" width="10" height="4" patternUnits="userSpaceOnUse">
        <line x1="0" y1="2" x2="10" y2="2" stroke="currentColor" stroke-width="0.5" stroke-linecap="round" /> 
      </pattern>
    </defs>
  </svg>
</div>

<!-- å·¦ã‚µã‚¤ãƒ‰ãƒãƒ¼ (ãƒ„ãƒ¼ãƒ«ãƒãƒ¼) -->
<div class="toolbar-container">
  <div class="tool-group">
    <div class="tool-btn active" id="tool-hand" onclick="setTool('hand')" title="ç§»å‹•ãƒ»æ“ä½œ">
      <div class="tool-icon">
        <svg viewBox="0 0 24 24" class="duotone-icon"><path d="M21,15a2,2,0,0,1-2,2H7l-4,4V5A2,2,0,0,1,5,3h9" fill="currentColor" class="secondary" style="opacity:0"/><path d="M12,2a1,1,0,0,1,1,1v8h0a1,1,0,0,1,2,0V5a1,1,0,0,1,2,0v6h0a1,1,0,0,1,2,0V8a1,1,0,0,1,2,0v6.86c0,4.4-4.06,7.14-8.15,7.14a7,7,0,0,1-5.12-2.31L4,15.83,5.15,14a1,1,0,0,1,1.46-.22l2.39,1.9V3A1,1,0,0,1,10,2h1m0-2H10A3,3,0,0,0,7,3V13.8L6.4,13.31a3,3,0,0,0-4.39.67L.81,15.83l3.87,3.87A9,9,0,0,0,11.05,24C16.89,24,23,20.08,23,14.86V8a3,3,0,0,0-3-3V5a3,3,0,0,0-3-3V3a3,3,0,0,0-3-3Z" fill="currentColor"/></svg>
      </div>
      <div class="tool-label">ç§»å‹•</div>
    </div>
    <div class="tool-btn" id="tool-box" onclick="setTool('box')" title="è¨˜äº‹ã‚’ä½œæˆ">
      <div class="tool-icon">
         <svg viewBox="0 0 24 24" class="duotone-icon"><rect x="3" y="3" width="18" height="18" rx="2" fill="currentColor" class="secondary"/><path d="M19,3H5A2,2,0,0,0,3,5V19a2,2,0,0,0,2,2H19a2,2,0,0,0,2-2V5A2,2,0,0,0,19,3ZM10,17H7V15h3Zm0-4H7V11h3Zm0-4H7V7h3Zm7,8H12V15h5Zm0-4H12V11h5Zm0-4H12V7h5Z" fill="currentColor"/></svg>
      </div>
      <div class="tool-label">è¨˜äº‹</div>
    </div>
    <div class="tool-btn" id="tool-headline" onclick="setTool('headline')" title="è¦‹å‡ºã—ã‚’ä½œæˆ">
      <div class="tool-icon">
        <svg viewBox="0 0 24 24" class="duotone-icon"><rect x="3" y="5" width="18" height="14" rx="1" fill="currentColor" class="secondary"/><path d="M5,4V20H19V4ZM17,7v1.5H12.75V17h-1.5V8.5H7V7Z" fill="currentColor"/></svg>
      </div>
      <div class="tool-label">è¦‹å‡ºã—</div>
    </div>
    <div class="tool-btn" id="tool-image" onclick="setTool('image')" title="ç”»åƒã‚’é…ç½®">
      <div class="tool-icon">
        <svg viewBox="0 0 24 24" class="duotone-icon"><rect x="3" y="3" width="18" height="18" rx="2" fill="currentColor" class="secondary"/><circle cx="8.5" cy="8.5" r="1.5" fill="currentColor" style="opacity:0.8"/><polyline points="21 15 16 10 5 21" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg>
      </div>
      <div class="tool-label">ç”»åƒ</div>
    </div>
  </div>
  <div class="tool-group">
    <div class="tool-btn" id="tool-header" onclick="setTool('header')" title="é¡Œå­—ã‚’ä½œæˆ">
      <div class="tool-icon">
        <svg viewBox="0 0 24 24" class="duotone-icon"><path d="M12,2L2,7l10,5L22,7Z" fill="currentColor"/><path d="M2,17l10,5,10-5M2,12l10,5,10-5" fill="none" stroke="currentColor" stroke-width="2" stroke-linejoin="round"/></svg>
      </div>
      <div class="tool-label">é¡Œå­—</div>
    </div>
    <div class="tool-btn" id="tool-correction" onclick="setTool('correction')" title="ä¿®æ­£ãƒ†ãƒ¼ãƒ—">
      <div class="tool-icon">
         <svg viewBox="0 0 24 24" class="duotone-icon"><rect x="4" y="4" width="16" height="16" fill="currentColor" class="secondary"/><path d="M20,4H4V20H20ZM8,14H6V10H8Zm10,0H10V10H18Z" fill="currentColor" fill-rule="evenodd"/></svg>
      </div>
      <div class="tool-label">å¡—ã‚Š</div>
    </div>
    <div class="tool-btn" id="tool-vline" onclick="setTool('vline')" title="ç¸¦ç·šã‚’å¼•ã">
      <div class="tool-icon">
        <svg viewBox="0 0 24 24" class="duotone-icon"><rect x="11" y="3" width="2" height="18" fill="currentColor"/></svg>
      </div>
      <div class="tool-label">ç¸¦ç·š</div>
    </div>
  </div>
  <div class="tool-group">
    <div class="tool-btn" onclick="undo()" title="å…ƒã«æˆ»ã™">
      <div class="tool-icon">
        <svg viewBox="0 0 24 24" class="duotone-icon"><path d="M12,5V1L7,6l5,5V7c3.31,0,6,2.69,6,6s-2.69,6-6,6-6-2.69-6-6H4c0,4.42,3.58,8,8,8s8-3.58,8-8-3.58-8-8-8Z" fill="currentColor"/></svg>
      </div>
      <div class="tool-label">æˆ»ã‚‹</div>
    </div>
    <div class="tool-btn" onclick="redo()" title="ã‚„ã‚Šç›´ã™">
      <div class="tool-icon">
        <svg viewBox="0 0 24 24" class="duotone-icon"><path d="M12,5V1l5,5-5,5V7c-3.31,0-6,2.69-6,6s2.69,6,6,6,6-2.69,6-6h2c0,4.42-3.58,8-8,8s-8-3.58-8-8,3.58-8,8-8Z" fill="currentColor"/></svg>
      </div>
      <div class="tool-label">é€²ã‚€</div>
    </div>
    <div class="tool-btn" onclick="fitView()" title="å…¨ä½“ã‚’è¡¨ç¤º">
      <div class="tool-icon">
        <svg viewBox="0 0 24 24" class="duotone-icon"><path d="M10,20v-6h4v6h5v-8h3L12,3,2,12H5v8Z" fill="currentColor" class="secondary"/><path d="M12,5.69l5,4.5V18h-2v-6H9v6H7V10.19l5-4.5M12,3,2,12H5v8H9v-6h6v6h4V12h3L12,3Z" fill="currentColor"/></svg>
      </div>
      <div class="tool-label">å…¨ä½“</div>
    </div>
  </div>
  <div class="tool-group">
      <div class="tool-btn" onclick="saveFile(true)" title="ä¿å­˜">
        <div class="tool-icon">
          <svg viewBox="0 0 24 24" class="duotone-icon"><path d="M17,3H5A2,2,0,0,0,3,5V19a2,2,0,0,0,2,2H19a2,2,0,0,0,2-2V7Zm2,16H5V5H16.17L19,7.83Zm-7-7A3,3,0,1,0,15,15,3,3,0,0,0,12,12ZM6,6h9v4H6Z" fill="currentColor"/></svg>
        </div>
        <div class="tool-label">ä¿å­˜</div>
      </div>
      <div class="tool-btn" onclick="openFileMenu()" title="ãƒ•ã‚¡ã‚¤ãƒ«">
        <div class="tool-icon">
          <svg viewBox="0 0 24 24" class="duotone-icon"><path d="M10,4H4A2,2,0,0,0,2,6V18a2,2,0,0,0,2,2H20a2,2,0,0,0,2-2V8a2,2,0,0,0-2-2H12Z" fill="currentColor" class="secondary"/><path d="M20,6h-8l-2-2H4A2,2,0,0,0,2,6V18a2,2,0,0,0,2,2H20a2,2,0,0,0,2-2V8a2,2,0,0,0-2-2Zm0,12H4V8H20Z" fill="currentColor"/></svg>
        </div>
        <div class="tool-label">é–‹ã</div>
      </div>
      <div class="tool-btn" onclick="openExportMenu()" title="æ›¸ãå‡ºã—">
        <div class="tool-icon">
          <svg viewBox="0 0 24 24" class="duotone-icon"><path d="M19,9h-4V3H9v6H5l7,7ZM5,18v2h14v-2Z" fill="currentColor"/></svg>
        </div>
        <div class="tool-label">æ›¸å‡º</div>
      </div>
  </div>
</div>

<div id="auto-save-indicator">ä¿å­˜ã—ã¾ã—ãŸ</div>

<!-- ãƒ•ã‚¡ã‚¤ãƒ«ãƒ¡ãƒ‹ãƒ¥ãƒ¼ãƒ¢ãƒ¼ãƒ€ãƒ« -->
<div id="file-menu-overlay" class="menu-overlay" onclick="if(event.target === this) this.style.display='none'">
    <div class="menu-panel">
        <div class="menu-header">ãƒ•ã‚¡ã‚¤ãƒ«</div>
        <div class="menu-item" onclick="saveFile(true)"><span>ğŸ’¾ åå‰ã‚’ä»˜ã‘ã¦ä¿å­˜...</span></div>
        <label class="menu-item">
            <span>ğŸ“‚ èª­ã¿è¾¼ã¿...</span>
            <input type="file" accept=".json" style="display:none" onchange="loadFile(this)">
        </label>
        <div class="menu-item" onclick="resetCanvasConfirm()"><span>ğŸ—‘ï¸ æ–°è¦ä½œæˆ</span></div>
        <button class="modal-btn btn-cancel" style="margin-top:10px; width:100%;" onclick="document.getElementById('file-menu-overlay').style.display='none'">é–‰ã˜ã‚‹</button>
    </div>
</div>

<!-- ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆãƒ¡ãƒ‹ãƒ¥ãƒ¼ãƒ¢ãƒ¼ãƒ€ãƒ« -->
<div id="export-menu-overlay" class="menu-overlay" onclick="if(event.target === this) this.style.display='none'">
    <div class="menu-panel">
        <div class="menu-header">ç”»åƒæ›¸ãå‡ºã—</div>
        <div class="menu-item" onclick="exportCanvasToImage('png')"><span>ğŸ–¼ï¸ PNGç”»åƒ</span></div>
        <div class="menu-item" onclick="exportCanvasToImage('jpeg')"><span>ğŸ–¼ï¸ JPGç”»åƒ</span></div>
        <div class="calc-info" style="text-align:left; color:#666;">
            ç¾åœ¨ã®ã‚­ãƒ£ãƒ³ãƒã‚¹ã‚’ã‚¹ã‚¯ãƒªãƒ¼ãƒ³ã‚·ãƒ§ãƒƒãƒˆã®ã‚ˆã†ã«é«˜ç”»è³ªã§ä¿å­˜ã—ã¾ã™ã€‚
        </div>
        <button class="modal-btn btn-cancel" style="margin-top:10px; width:100%;" onclick="document.getElementById('export-menu-overlay').style.display='none'">é–‰ã˜ã‚‹</button>
    </div>
</div>

<!-- ãƒ†ã‚­ã‚¹ãƒˆç·¨é›†ç”¨ ãƒ¢ãƒ¼ãƒ€ãƒ« -->
<div id="editor-overlay" class="overlay-modal">
  <div id="editor-panel" class="modal-panel">
    <div class="modal-title">ãƒ†ã‚­ã‚¹ãƒˆç·¨é›†</div>
    <div class="calc-info" style="text-align:left; color:#666;">â€»2æ¡æ•°å­—ã¯è‡ªå‹•ã§ç¸¦ä¸­æ¨ªã«ãªã‚Šã¾ã™</div>
    <textarea id="editor-textarea"></textarea>
    <div class="modal-buttons">
      <button class="modal-btn btn-cancel" onclick="closeOverlayEditor()">ã‚­ãƒ£ãƒ³ã‚»ãƒ«</button>
      <button class="modal-btn btn-save" onclick="saveOverlayEditor()">OK</button>
    </div>
  </div>
</div>

<!-- ãƒˆãƒªãƒŸãƒ³ã‚°ç·¨é›†ç”¨ ãƒ¢ãƒ¼ãƒ€ãƒ« -->
<div id="crop-overlay" class="overlay-modal">
    <div id="crop-panel" class="modal-panel">
        <div class="modal-title">ç”»åƒã®é…ç½®èª¿æ•´</div>
        <div class="calc-info" style="text-align:left; color:#666;">ãƒ‰ãƒ©ãƒƒã‚°ã§ç§»å‹•ã€ã‚¹ãƒ©ã‚¤ãƒ€ãƒ¼ã§æ‹¡å¤§</div>
        <div id="crop-canvas-container">
            <canvas id="crop-canvas"></canvas>
        </div>
        <div class="crop-controls">
            <span>ç¸®å°</span>
            <input type="range" id="crop-zoom" min="1.0" max="5.0" step="0.01" value="1.0" oninput="updateCropView()">
            <span>æ‹¡å¤§</span>
        </div>
        <div class="modal-buttons">
            <button class="modal-btn btn-cancel" onclick="closeCropEditor()">ã‚­ãƒ£ãƒ³ã‚»ãƒ«</button>
            <button class="modal-btn btn-save" onclick="applyCrop()">é©ç”¨</button>
        </div>
    </div>
</div>

<!-- å³ã‚µã‚¤ãƒ‰ãƒãƒ¼ (è¨­å®šãƒ‘ãƒãƒ«) -->
<div class="settings-panel">
  <!-- ã‚°ãƒ­ãƒ¼ãƒãƒ«è¨­å®š -->
  <div id="panel-global" class="panel-section active">
    
    <div class="ui-header">ç”¨ç´™</div>
    <div class="ui-row">
        <select id="paper-preset" onchange="updatePaperSize()" style="flex:2">
            <option value="A3">A3 (297Ã—420)</option>
            <option value="A4">A4 (210Ã—297)</option>
            <option value="B4">B4 (257Ã—364)</option>
            <option value="custom">ã‚«ã‚¹ã‚¿ãƒ </option>
        </select>
        <button class="btn-small" onclick="swapPaperWH()" title="ç¸¦æ¨ªå…¥æ›¿">âŸ³</button>
    </div>
    <div class="ui-row">
        <label>å¹…</label>
        <input type="number" id="paper-w-mm" value="297" onchange="updatePaperSize()">
        <label>é«˜</label>
        <input type="number" id="paper-h-mm" value="420" onchange="updatePaperSize()">
    </div>

    <div class="ui-row">
        <label>æ®µæ•°</label>
        <input type="range" id="paper-dan-count" min="1" max="15" step="1" value="8" oninput="updatePaperConfigInternal()">
        <span id="val-paper-dan-count" class="val">8</span>
    </div>
    <div class="ui-row">
        <label>1æ®µã®è¡Œæ•°</label>
        <input type="range" id="paper-rows-per-dan" min="10" max="100" step="1" value="40" oninput="updatePaperConfigInternal()">
        <span id="val-paper-rows-per-dan" class="val">40</span>
    </div>
    <div class="ui-row">
        <label>1è¡Œã®æ–‡å­—æ•°</label>
        <input type="range" id="paper-chars-per-dan" min="5" max="30" step="1" value="11" oninput="updatePaperConfigInternal()">
        <span id="val-paper-chars-per-dan" class="val">11</span>
    </div>

    <div class="ui-header">ä½™ç™½</div>
    <div class="ui-row"><label>ä¸Š</label><input type="number" id="margin-top" value="30" onchange="updateMargins()"><span style="font-size:11px;">mm</span></div>
    <div class="ui-row"><label>ä¸‹</label><input type="number" id="margin-bottom" value="30" onchange="updateMargins()"><span style="font-size:11px;">mm</span></div>
    <div class="ui-row"><label>å·¦</label><input type="number" id="margin-left" value="20" onchange="updateMargins()"><span style="font-size:11px;">mm</span></div>
    <div class="ui-row"><label>å³</label><input type="number" id="margin-right" value="20" onchange="updateMargins()"><span style="font-size:11px;">mm</span></div>

    <div class="ui-header">ä½œæˆãƒ¢ãƒ¼ãƒ‰</div>
    <div class="ui-row">
      <label style="width:auto; flex:1; cursor:pointer; font-size:12px;">
        <input type="radio" name="c-mode" value="normal" checked onchange="setCreationMode('normal')"> æ®µæƒãˆ
      </label>
      <label style="width:auto; flex:1; cursor:pointer; font-size:12px;">
        <input type="radio" name="c-mode" value="free" onchange="setCreationMode('free')"> è‡ªç”±
      </label>
    </div>

    <div class="ui-header">å¤–å‘¨æƒ…å ±</div>
    <div class="btn-group-row">
        <button class="btn-group-item active" id="btn-marg-left" onclick="selectMarginaliaTarget('left')">å·¦</button>
        <button class="btn-group-item" id="btn-marg-center" onclick="selectMarginaliaTarget('center')">ä¸­å¤®</button>
        <button class="btn-group-item" id="btn-marg-right" onclick="selectMarginaliaTarget('right')">å³</button>
    </div>
    <div class="ui-row"><label>å†…å®¹</label><input type="text" id="marg-text" oninput="updateMarginaliaConfig()"></div>
    <div class="ui-row"><label>ãƒ•ã‚©ãƒ³ãƒˆ</label><select id="marg-font" class="font-selector" onchange="updateMarginaliaConfig()"></select></div>
    <div class="ui-row">
        <label>ã‚µã‚¤ã‚º</label><input type="range" id="marg-size" min="5" max="32" value="12" oninput="updateMarginaliaConfig()">
        <span id="val-marg-size" class="val">12</span>
    </div>
    <div class="ui-row">
        <label>å¤ªã•</label><input type="range" id="marg-weight" min="100" max="900" step="100" value="400" oninput="updateMarginaliaConfig()">
        <span id="val-marg-weight" class="val">400</span>
    </div>
    <div class="ui-row">
        <label>å­—é–“</label><input type="range" id="marg-spacing" min="0" max="20" value="2" step="0.5" oninput="updateMarginaliaConfig()">
        <span id="val-marg-spacing" class="val">2</span>
    </div>

    <!-- ã‚°ãƒ­ãƒ¼ãƒãƒ«å´ã®æœ¬æ–‡ä½ç½®èª¿æ•´ã¯è¨˜äº‹ãƒ‘ãƒãƒ«ã¸ç§»è¨­ -->

    <div class="ui-header">è¡¨ç¤º</div>
    <div class="ui-row"><label>æ–‡å­—ãƒã‚¹</label><input type="checkbox" id="chk-grid" checked onchange="toggleGrid()"></div>
    <div class="ui-row"><label>ãƒã‚¹è‰²</label><input type="color" id="inp-grid-color" value="#dddddd" oninput="updateColors()"></div>
    <div class="ui-row"><label>ç´™è‰²</label><input type="color" id="inp-paper-color" value="#fcfcfc" oninput="updateColors()"></div>
    <div class="ui-row"><label>ã‚¤ãƒ³ã‚¯è‰²</label><input type="color" id="inp-text-color" value="#111111" oninput="updateColors()"></div>
    
    <div class="ui-header">ç½«ç·š</div>
    <div class="ui-row"><label>æ®µé–“</label><input type="range" min="0.1" max="5" step="0.1" value="1.0" id="inp-divider-width" oninput="updateColors()"><span id="val-divider-width" class="val">1.0</span></div>
    <div class="ui-row"><label>å¤–å‘¨æ </label><input type="range" min="0.1" max="5" step="0.1" value="1.0" id="inp-border-width" oninput="updateColors()"><span id="val-border-width" class="val">1.0</span></div>
    
  </div>

  <!-- è¨˜äº‹è¨­å®š -->
  <div id="panel-article" class="panel-section">
    <div class="ui-header">æœ¬æ–‡ã®ä½ç½®èª¿æ•´</div>
    <div class="nudge-pad" id="nudge-pad-article" title="å…¨ä½“ã®æ–‡å­—ä½ç½®ã‚’ä¸€æ‹¬èª¿æ•´">
      <button class="nudge-btn" onclick="nudgeSelection(0, -1, false, event)">â–²</button>
      <div class="nudge-row">
        <button class="nudge-btn" onclick="nudgeSelection(-1, 0, false, event)">â—€</button>
        <button class="nudge-btn nudge-reset" onclick="nudgeSelection(0, 0, true, event)">RST</button>
        <button class="nudge-btn" onclick="nudgeSelection(1, 0, false, event)">â–¶</button>
      </div>
      <button class="nudge-btn" onclick="nudgeSelection(0, 1, false, event)">â–¼</button>
    </div>
    <div class="ui-header">ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆ</div>
    <div class="ui-row"><label>è‡ªç”±ãªé«˜ã•</label><input type="checkbox" id="art-free-layout" onchange="updateArticleAttr()"></div>
    <div id="overflow-info-box" style="display:block; margin-top:10px;">
       <div style="font-weight:600; margin-bottom:4px;">æ–‡å­—æ•°ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹</div>
       <div id="overflow-status-text" style="font-size:13px;">-</div>
    </div>
    <div class="calc-info">â€»ãƒ€ãƒ–ãƒ«ã‚¯ãƒªãƒƒã‚¯ã§ç·¨é›†</div>

    <div class="ui-header">ãƒ•ã‚©ãƒ³ãƒˆ</div>
    <div class="ui-row">
      <select id="inp-font" class="font-selector" onchange="calculateLayout()"></select>
    </div>
    <div class="ui-row">
      <label>å¤ªã•</label>
      <input type="range" min="100" max="900" step="100" value="400" id="inp-font-weight" oninput="updateVisuals()">
      <span id="val-font-weight" class="val">400</span>
    </div>
    <div class="ui-row"><label>å­—å½¢å€ç‡</label><input type="range" min="0.5" max="1.5" step="0.01" value="1.0" id="inp-glyph-scale" oninput="updateVisuals()"><span id="val-glyph-scale" class="val">1.0</span></div>
  </div>

  <!-- ç”»åƒè¨­å®š -->
  <div id="panel-image" class="panel-section">
    <div class="ui-header">ç”»åƒ</div>
    <label class="file-upload-btn">
        ğŸ“ ç”»åƒã‚’é¸æŠ
        <input type="file" id="inp-image-file" accept="image/*" onchange="handleImageUpload(this)">
    </label>
    <button class="action-btn" onclick="openCropTool()">âœ‚ é…ç½®èª¿æ•´</button>
    <div class="calc-info" style="margin-bottom:10px;">ãƒ‰ãƒ©ãƒƒã‚°ã§æ ã‚µã‚¤ã‚ºå¤‰æ›´å¯</div>

    <div class="ui-header">ã‚«ãƒ©ãƒ¼</div>
    <div class="ui-row"><label>ãƒ¢ãƒ¼ãƒ‰</label>
      <select id="img-color-mode" onchange="updateImageAttr()">
        <option value="color">ãƒ•ãƒ«ã‚«ãƒ©ãƒ¼</option>
        <option value="ink">ã‚¤ãƒ³ã‚¯è‰²</option>
      </select>
    </div>
    
    <!-- ã‚¤ãƒ³ã‚¯èª¿æ•´ã‚¹ãƒ©ã‚¤ãƒ€ãƒ¼ï¼ˆã‚¤ãƒ³ã‚¯ãƒ¢ãƒ¼ãƒ‰æ™‚ã®ã¿è¡¨ç¤ºï¼‰ -->
    <div id="ink-adjust-area">
        <div class="ui-row">
            <label style="width:70px">ã‚³ãƒ³ãƒˆãƒ©ã‚¹ãƒˆ</label>
            <input type="range" min="0.5" max="3.0" step="0.1" value="1.0" id="img-contrast" oninput="updateImageAttr()">
            <span id="val-img-contrast" class="val" style="font-size:11px; width:30px;">1.0</span>
        </div>
        <div class="ui-row">
            <label style="width:70px">æ˜ã‚‹ã•</label>
            <input type="range" min="-1.0" max="1.0" step="0.1" value="0.0" id="img-brightness" oninput="updateImageAttr()">
            <span id="val-img-brightness" class="val" style="font-size:11px; width:30px;">0.0</span>
        </div>
        <div class="calc-info">â€»æ˜åº¦ã«åˆã‚ã›ã¦è‡ªå‹•åè»¢</div>
    </div>

    <div class="ui-header">ã‚­ãƒ£ãƒ—ã‚·ãƒ§ãƒ³</div>
    <div class="ui-row"><label>ä½ç½®</label>
      <select id="img-cap-pos" onchange="updateImageAttr()">
        <option value="none">ãªã—</option>
        <option value="bottom" selected>ä¸‹</option>
        <option value="top">ä¸Š</option>
        <option value="left">å·¦</option>
        <option value="right">å³</option>
      </select>
    </div>
    <div class="ui-row"><label>ãƒ•ã‚©ãƒ³ãƒˆ</label><select id="img-font" class="font-selector" onchange="updateImageAttr()"></select></div>
    <div class="calc-info">â€»ãƒ€ãƒ–ãƒ«ã‚¯ãƒªãƒƒã‚¯ã§ç·¨é›†</div>

    <div class="ui-header">ã‚µã‚¤ã‚º</div>
    <div class="ui-row">
      <label>è¡¨ç¤ºã‚µã‚¤ã‚º</label>
      <span id="img-size-display" class="val" style="width:auto; font-weight:500;">-</span>
    </div>

    <div class="ui-header">ä½ç½®èª¿æ•´</div>
    <div class="nudge-pad">
      <button class="nudge-btn" onclick="nudgeSelection(0, -1)">â–²</button>
      <div class="nudge-row">
        <button class="nudge-btn" onclick="nudgeSelection(-1, 0)">â—€</button>
        <button class="nudge-btn nudge-reset" onclick="nudgeSelection(0, 0, true)">RST</button>
        <button class="nudge-btn" onclick="nudgeSelection(1, 0)">â–¶</button>
      </div>
      <button class="nudge-btn" onclick="nudgeSelection(0, 1)">â–¼</button>
    </div>
  </div>

  <!-- é¡Œå­—è¨­å®š -->
  <div id="panel-header" class="panel-section">
    <div class="ui-header">é¡Œå­—</div>
    <div class="ui-row"><label>æ–°èå</label><input type="text" id="hdr-title" oninput="updateHeaderAttr()" placeholder="æ–°èå"></div>
    <div class="ui-row">
      <label>ãƒ•ã‚©ãƒ³ãƒˆ</label>
      <select id="hdr-font" class="font-selector" onchange="updateHeaderAttr()"></select>
    </div>
    
    <div class="ui-header">ãƒ‡ã‚¶ã‚¤ãƒ³</div>
    <div class="ui-row"><label>å¤–æ </label><input type="range" min="0" max="10" value="4" id="hdr-border-out" oninput="updateHeaderAttr()"></div>
    <div class="ui-row"><label>å†…æ </label><input type="range" min="0" max="10" value="1" id="hdr-border-in" oninput="updateHeaderAttr()"></div>
    
    <div class="ui-header">è£…é£¾</div>
    <div class="ui-row"><label>æ–‡å­—åè»¢</label><input type="checkbox" id="hdr-text-inverted" onchange="updateHeaderAttr()"></div>
    <div class="ui-row"><label>ãƒ•ãƒå¤ªã•</label><input type="range" min="0" max="20" step="0.5" value="0" id="hdr-text-stroke" oninput="updateHeaderAttr()"></div>

    <div class="ui-header">é¡Œå­—ä½ç½®</div>
    <div class="nudge-pad">
      <button class="nudge-btn" onclick="nudgeHeaderTitle(0, -1)">â–²</button>
      <div class="nudge-row">
        <button class="nudge-btn" onclick="nudgeHeaderTitle(-1, 0)">â—€</button>
        <button class="nudge-btn nudge-reset" onclick="nudgeHeaderTitle(0, 0, true)">RST</button>
        <button class="nudge-btn" onclick="nudgeHeaderTitle(1, 0)">â–¶</button>
      </div>
      <button class="nudge-btn" onclick="nudgeHeaderTitle(0, 1)">â–¼</button>
    </div>

    <div class="ui-row"><label>ä½™ç™½(ä¸Šä¸‹)</label><input type="range" min="0" max="100" value="10" id="hdr-pad-v" oninput="updateHeaderAttr()"></div>
    <div class="ui-row"><label>ä½™ç™½(å·¦å³)</label><input type="range" min="0" max="100" value="5" id="hdr-pad-h" oninput="updateHeaderAttr()"></div>

    <div class="ui-header">ç™ºè¡Œæƒ…å ±</div>
    <div class="ui-row"><label>ç™ºè¡Œè€…</label><input type="text" id="hdr-publisher" oninput="updateHeaderAttr()" placeholder="ç™ºè¡Œæ‰€"></div>
    <div class="ui-row"><label>æ‰€åœ¨åœ°</label><input type="text" id="hdr-address" oninput="updateHeaderAttr()" placeholder="æ‰€åœ¨åœ°"></div>
    <div class="ui-row"><label>é€£çµ¡å…ˆ</label><input type="text" id="hdr-contact" oninput="updateHeaderAttr()" placeholder="é€£çµ¡å…ˆ"></div>
    <div class="ui-row"><label>å·æ•°</label><input type="text" id="hdr-issue" oninput="updateHeaderAttr()" placeholder="ç¬¬ã€‡ã€‡å·"></div>
    <div class="ui-row">
      <label>ãƒ•ã‚©ãƒ³ãƒˆ</label>
      <select id="hdr-info-font" class="font-selector" onchange="updateHeaderAttr()"></select>
    </div>
    <div class="ui-row">
        <label>ã‚µã‚¤ã‚º</label>
        <input type="range" min="5" max="24" value="12" id="hdr-info-size" oninput="updateHeaderAttr()">
    </div>

    <div class="ui-header">æ ä½ç½®</div>
    <div class="nudge-pad">
      <button class="nudge-btn" onclick="nudgeSelection(0, -1)">â–²</button>
      <div class="nudge-row">
        <button class="nudge-btn" onclick="nudgeSelection(-1, 0)">â—€</button>
        <button class="nudge-btn nudge-reset" onclick="nudgeSelection(0, 0, true)">RST</button>
        <button class="nudge-btn" onclick="nudgeSelection(1, 0)">â–¶</button>
      </div>
      <button class="nudge-btn" onclick="nudgeSelection(0, 1)">â–¼</button>
    </div>
  </div>

  <!-- è¦‹å‡ºã—è¨­å®š -->
  <div id="panel-headline" class="panel-section">
    <div class="ui-header">è¦‹å‡ºã—ã®èª¿æ•´</div>
    <div class="nudge-pad">
      <button class="nudge-btn" onclick="nudgeSelection(0, -1)">â–²</button>
      <div class="nudge-row">
        <button class="nudge-btn" onclick="nudgeSelection(-1, 0)">â—€</button>
        <button class="nudge-btn nudge-reset" onclick="nudgeSelection(0, 0, true)">RST</button>
        <button class="nudge-btn" onclick="nudgeSelection(1, 0)">â–¶</button>
      </div>
      <button class="nudge-btn" onclick="nudgeSelection(0, 1)">â–¼</button>
    </div>
    <div class="ui-header">ã‚¹ã‚¿ã‚¤ãƒ«</div>
    <div class="ui-row"><label>ç™½é»’åè»¢</label><input type="checkbox" id="hl-inverted" onchange="updateHeadlineAttr()"></div>
    <div class="ui-row"><label>ãƒ•ã‚©ãƒ³ãƒˆ</label><select id="hl-font" class="font-selector" onchange="updateHeadlineAttr()"></select></div>
    <div class="ui-row"><label>å¤ªã•</label><select id="hl-weight" onchange="updateHeadlineAttr()"><option value="400">æ¨™æº–</option><option value="700" selected>å¤ªå­—</option><option value="900">æ¥µå¤ª</option></select></div>
    <div class="ui-row"><label>ä½™ç™½(é•·è¾º)</label><input type="range" min="0" max="50" step="1" value="0" id="hl-pad-long" oninput="updateHeadlineAttr()"><span id="val-hl-pad-long" class="val">0</span></div>
    <div class="ui-row"><label>ä½™ç™½(çŸ­è¾º)</label><input type="range" min="0" max="50" step="1" value="0" id="hl-pad-short" oninput="updateHeadlineAttr()"><span id="val-hl-pad-short" class="val">0</span></div>
  </div>

  <!-- ç¸¦ç·šè¨­å®š -->
  <div id="panel-vline" class="panel-section">
    <div class="ui-header">ç¸¦ç·šã®èª¿æ•´</div>
    <div class="nudge-pad">
      <button class="nudge-btn" onclick="nudgeSelection(0, -1)">â–²</button>
      <div class="nudge-row">
        <button class="nudge-btn" onclick="nudgeSelection(-1, 0)">â—€</button>
        <button class="nudge-btn nudge-reset" onclick="nudgeSelection(0, 0, true)">RST</button>
        <button class="nudge-btn" onclick="nudgeSelection(1, 0)">â–¶</button>
      </div>
      <button class="nudge-btn" onclick="nudgeSelection(0, 1)">â–¼</button>
    </div>
    <div class="ui-header">å¤ªã•</div>
    <div class="ui-row"><label>ç·šã®å¤ªã•</label><input type="range" min="1" max="10" step="1" value="2" id="vl-width" oninput="updateVlineAttr()"><span id="val-vl-width" class="val">2</span></div>
  </div>
  
  <!-- ä¿®æ­£ãƒ†ãƒ¼ãƒ—è¨­å®š -->
  <div id="panel-correction" class="panel-section">
    <div class="ui-header">å¡—ã‚Šã¤ã¶ã—</div>
    <div class="nudge-pad">
      <button class="nudge-btn" onclick="nudgeSelection(0, -1)">â–²</button>
      <div class="nudge-row">
        <button class="nudge-btn" onclick="nudgeSelection(-1, 0)">â—€</button>
        <button class="nudge-btn nudge-reset" onclick="nudgeSelection(0, 0, true)">RST</button>
        <button class="nudge-btn" onclick="nudgeSelection(1, 0)">â–¶</button>
      </div>
      <button class="nudge-btn" onclick="nudgeSelection(0, 1)">â–¼</button>
    </div>
    <div class="calc-info">è‡ªç”±é…ç½®ãƒ»ç´™è‰²ãƒ™ã‚¿å¡—ã‚Š</div>
  </div>
</div>

<div id="viewport">
  <div id="canvas-transform">
    <div class="paper">
      
      <!-- å¤–å‘¨æƒ…å ± (Top) -->
      <div class="margin-info-container" id="margin-info-top">
          <div class="margin-info-item" id="info-left"></div>
          <div class="margin-info-item" id="info-center"></div>
          <div class="margin-info-item" id="info-right"></div>
      </div>
      
      <!-- ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆæ ãƒ¬ã‚¤ãƒ¤ãƒ¼ (å¤–å‘¨æ : æœ€å‰é¢) -->
      <svg id="layout-border-layer"></svg>
      
      <!-- ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆç·šãƒ¬ã‚¤ãƒ¤ãƒ¼ (æ®µé–“ç½«ç·š: èƒŒé¢) -->
      <svg id="layout-lines-layer"></svg>
      
      <div class="hanmen" id="hanmen">
        <div id="grid-layer"></div>
        <svg id="link-layer">
          <path id="temp-link-line" d=""></path>
        </svg>
      </div>

      <!-- ã‚«ãƒ©ãƒ¼ãƒ‘ãƒƒãƒ (Bottom) -->
      <div id="color-patches-bottom">
          <!-- JSã§æç”» -->
      </div>

    </div>
  </div>
</div>
<div id="measure-box"></div>
<div id="headline-measure-box"></div>

<script>
  // --- ãƒ•ã‚©ãƒ³ãƒˆè¨­å®š ---
  const fontOptions = [
    { label: "--- æ˜æœä½“ (Mincho) ---", options: [
      { val: '"Biz UDMincho", serif', label: "BIZ UDæ˜æœ (æ¨™æº–)" },
      { val: '"Shippori Mincho", serif', label: "ã—ã£ã½ã‚Šæ˜æœ (æ¥µå¤ª)" },
      { val: '"Noto Serif JP", serif', label: "Noto Serif JP" }
    ]},
    { label: "--- ã‚´ã‚·ãƒƒã‚¯ä½“ (Gothic) ---", options: [
      { val: '"Noto Sans JP", sans-serif', label: "Noto Sans JP (æ¨™æº–)" },
      { val: '"BIZ UDGothic", sans-serif', label: "BIZ UDã‚´ã‚·ãƒƒã‚¯" },
      { val: '"Zen Maru Gothic", sans-serif', label: "Zen ä¸¸ã‚´ã‚·ãƒƒã‚¯ (ä¸¸æ–‡å­—)" },
      { val: '"Dela Gothic One", sans-serif', label: "Dela Gothic (è¶…æ¥µå¤ª)" }
    ]},
    { label: "--- æ•™ç§‘æ›¸ãƒ»æ‰‹æ›¸ã ---", options: [
      { val: '"Klee One", cursive', label: "Klee One (æ•™ç§‘æ›¸é¢¨)" },
      { val: '"Zen Kurenaido", sans-serif', label: "Zen ç´…é“ (æ‰‹æ›¸ãé¢¨)" }
    ]},
    { label: "--- ç­†æ›¸ä½“ (Brush) ---", options: [
      { val: '"Yuji Syuku", serif', label: "ä½‘å­— å®¿ (ã‚¯ãƒ©ã‚·ãƒƒã‚¯)" },
      { val: '"Yuji Mai", serif', label: "ä½‘å­— èˆ (æµéº—)" },
      { val: '"Yuji Boku", serif', label: "ä½‘å­— æœ´ (æœ¨ç‰ˆ)" }
    ]},
    { label: "--- ãƒ‡ã‚¶ã‚¤ãƒ³ (Design) ---", options: [
      { val: '"Reggae One", cursive', label: "Reggae One (ã‚¤ãƒ³ãƒ‘ã‚¯ãƒˆ)" },
      { val: '"RocknRoll One", sans-serif', label: "RocknRoll One (ãƒãƒƒãƒ—)" },
      { val: '"DotGothic16", sans-serif', label: "DotGothic16 (ãƒ‰ãƒƒãƒˆ)" },
      { val: '"Hachi Maru Pop", cursive', label: "ãƒãƒãƒãƒ«ãƒãƒƒãƒ—" }
    ]}
  ];

  function updateFontSelectors() {
      const selectors = document.querySelectorAll('.font-selector');
      selectors.forEach(sel => {
          sel.innerHTML = "";
          fontOptions.forEach(group => {
              const optGroup = document.createElement('optgroup');
              optGroup.label = group.label;
              group.options.forEach(opt => {
                  const option = document.createElement('option');
                  option.value = opt.val;
                  option.innerText = opt.label;
                  optGroup.appendChild(option);
              });
              sel.appendChild(optGroup);
          });
      });
      // å¤–å‘¨æƒ…å ±ç”¨ãƒ•ã‚©ãƒ³ãƒˆã¯åˆæœŸå€¤å¤‰æ›´
      document.getElementById('marg-font').value = '"Noto Sans JP", sans-serif';
  }

  // --- è¨­å®š ---
  let config = {
    baseFontSize: 24, charsPerDan: 11, charsGap: 1.0, pageDanCount: 8, rowsPerDan: 40,
    marginTop: 30, marginBottom: 30, marginInner: 20, marginOuter: 20,
    nudgeX: 0, nudgeY: 0, glyphScale: 1.0, lineGap: 12,
    fontFamily: '"BIZ UDMincho", serif', fontWeight: 400,
    
    // ç”¨ç´™ã‚µã‚¤ã‚º
    paperW: 297, paperH: 420,

    gridColor: "#dddddd", paperColor: "#fcfcfc", textColor: "#111111",
    borderColor: "#000000", borderWidth: 1.0, dividerColor: "#000000", dividerWidth: 1.0,

    // å¤–å‘¨æƒ…å ±è¨­å®š (å€‹åˆ¥åŒ–)
    marginalia: {
        left: { 
            text: new Date().toLocaleDateString('ja-JP', {year:'numeric', month:'2-digit', day:'2-digit'}), 
            font: '"Noto Sans JP", sans-serif', 
            size: 12, spacing: 2, weight: 400 
        },
        center: { 
            text: "ï¼ˆæ–°èåæ‰‹å…¥åŠ›ï¼‰", 
            font: '"Noto Sans JP", sans-serif', 
            size: 12, spacing: 2, weight: 400 
        },
        right: { 
            text: "ã€‡ã€‡ã«ã¤ã„ã¦è€ƒãˆã‚‹", 
            font: '"Noto Sans JP", sans-serif', 
            size: 12, spacing: 2, weight: 400 
        }
    }
  };
  
  // ç·¨é›†ä¸­ã®å¤–å‘¨ãƒ–ãƒ­ãƒƒã‚¯
  let currentMarginaliaTarget = 'left';

  const SCALE_Y = 0.85;
  const PX_PER_MM = 3.78;

  let baseHDan, baseHGap, baseHUnit; 
  let physicalHDan, physicalHGap, physicalHUnit;
  let linePitch;

  let groups = [];
  let undoStack = []; let redoStack = []; const HISTORY_LIMIT = 100;
  let currentFileName = "shinbun_data.json";
  // let isExportFlatten = false; // å»ƒæ­¢: å¸¸ã«è¦‹ãŸç›®é€šã‚Šã«å‡ºåŠ›ã™ã‚‹

  // Viewport
  let viewX = 50, viewY = 50, viewScale = 0.6;
  let currentTool = 'hand'; 
  let isMouseDown = false, isDragging = false; 
  let activePointerId = null; // for touch/stylus/mouse unified handling
  const activePointers = new Map(); // pointerId -> {x,y}
  const previousPointers = new Map(); // pointerId -> {x,y}
  let isPinching = false, pinchStartDist = 0, pinchStartScale = 1, pinchCenter = { x: 0, y: 0 }, pinchPrevCenter = null, pinchPrevDist = 0;
  const TOUCH_PAN_FACTOR = 0.65; // dampen touch pan so movement tracks finger better
  const DRAG_THRESHOLD = 10;
  let opMode = 'none';
  let startX, startY, startViewX, startViewY, dragStartX, dragStartY;
  let initialElemX, initialElemY, anchorRight, anchorTop;
  let targetId = null, ghost = null, selectedId = null;
  let linkingSourceId = null, linkingStartX = 0, linkingStartY = 0;
  let linkingSourceType = null;
  let anchorSnapX = 0, anchorSnapY = 0;
  let editingGroupId = null; 
  let isFreeCreationMode = false; 
  let isDirty = false; // å¤‰æ›´æ¤œçŸ¥

  const viewport = document.getElementById('viewport');
  const canvasTransform = document.getElementById('canvas-transform');
  const hanmen = document.getElementById('hanmen');
  const gridLayer = document.getElementById('grid-layer');
  const layoutLinesLayer = document.getElementById('layout-lines-layer');
  const layoutBorderLayer = document.getElementById('layout-border-layer');
  const linkLayer = document.getElementById('link-layer');
  const tempLinkLine = document.getElementById('temp-link-line');
  const measureBox = document.getElementById('measure-box');
  const hlMeasureBox = document.getElementById('headline-measure-box');
  const root = document.documentElement;
  const overflowStatusText = document.getElementById('overflow-status-text');
  const svgFiltersContainer = document.getElementById('svg-filters-container');
  function clearPortHighlights() { document.querySelectorAll('.port').forEach(p => p.classList.remove('link-mode-compatible','port-hovered')); }
  function highlightCompatiblePorts(sourceId) {
      clearPortHighlights();
      const selector = (linkingSourceType === 'in') ? '.port-out' : '.port-in';
      document.querySelectorAll(selector).forEach(p => {
          const gid = p.closest('.article-group')?.dataset.id;
          if (!gid || gid === sourceId) return;
          // æ¥ç¶šå…ˆã¯æœªæ¥ç¶šã®ã‚‚ã®ã ã‘ã‚’ãƒã‚¤ãƒ©ã‚¤ãƒˆï¼ˆèµ¤/é’ã‚¯ãƒªãƒƒã‚¯æ™‚ã«ç·‘/é»„ã¯é™¤å¤–ï¼‰
          if (selector === '.port-in' && p.classList.contains('connected')) return;
          if (selector === '.port-out' && p.classList.contains('linked')) return;
          p.classList.add('link-mode-compatible');
      });
  }
  function updatePatternColor() {
      const patLine = document.querySelector('#pat-lines line');
      if (patLine) patLine.setAttribute('stroke', config.textColor || '#000');
  }
  function applyConfigToUI() {
      // ç”¨ç´™ãƒ»ãƒãƒ¼ã‚¸ãƒ³
      if (document.getElementById('paper-w-mm')) document.getElementById('paper-w-mm').value = config.paperW;
      if (document.getElementById('paper-h-mm')) document.getElementById('paper-h-mm').value = config.paperH;
      if (document.getElementById('margin-top')) document.getElementById('margin-top').value = config.marginTop;
      if (document.getElementById('margin-bottom')) document.getElementById('margin-bottom').value = config.marginBottom;
      if (document.getElementById('margin-left')) document.getElementById('margin-left').value = config.marginOuter;
      if (document.getElementById('margin-right')) document.getElementById('margin-right').value = config.marginInner;
      
      // ç´™é¢ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆè¨­å®š
      if (document.getElementById('paper-dan-count')) {
          document.getElementById('paper-dan-count').value = config.pageDanCount;
          document.getElementById('val-paper-dan-count').innerText = config.pageDanCount;
      }
      if (document.getElementById('paper-rows-per-dan')) {
          document.getElementById('paper-rows-per-dan').value = config.rowsPerDan;
          document.getElementById('val-paper-rows-per-dan').innerText = config.rowsPerDan;
      }
      if (document.getElementById('paper-chars-per-dan')) {
          document.getElementById('paper-chars-per-dan').value = config.charsPerDan;
          document.getElementById('val-paper-chars-per-dan').innerText = config.charsPerDan;
      }

      // è‰²ãƒ»ç·š
      if (document.getElementById('inp-grid-color')) document.getElementById('inp-grid-color').value = config.gridColor;
      if (document.getElementById('inp-paper-color')) document.getElementById('inp-paper-color').value = config.paperColor;
      if (document.getElementById('inp-text-color')) document.getElementById('inp-text-color').value = config.textColor;
      if (document.getElementById('inp-border-width')) { document.getElementById('inp-border-width').value = config.borderWidth; document.getElementById('val-border-width').innerText = config.borderWidth; }
      if (document.getElementById('inp-divider-width')) { document.getElementById('inp-divider-width').value = config.dividerWidth; document.getElementById('val-divider-width').innerText = config.dividerWidth; }
      // ã‚°ãƒªãƒƒãƒ‰è¡¨ç¤º
      if (document.getElementById('chk-grid')) document.getElementById('chk-grid').checked = true;
      // ãƒ•ã‚©ãƒ³ãƒˆã¨å­—å½¢å€ç‡ãƒ»å¤ªã•
      if (document.getElementById('inp-font')) document.getElementById('inp-font').value = config.fontFamily;
      if (document.getElementById('inp-font-weight')) { document.getElementById('inp-font-weight').value = config.fontWeight; document.getElementById('val-font-weight').innerText = config.fontWeight; }
      if (document.getElementById('inp-glyph-scale')) { document.getElementById('inp-glyph-scale').value = config.glyphScale; document.getElementById('val-glyph-scale').innerText = config.glyphScale; }
      // å¤–å‘¨æƒ…å ±ï¼ˆç¾åœ¨é¸æŠä¸­ã®ã‚¿ãƒ¼ã‚²ãƒƒãƒˆã«åæ˜ ï¼‰
      if (document.getElementById('marg-text')) document.getElementById('marg-text').value = config.marginalia[currentMarginaliaTarget].text;
      if (document.getElementById('marg-font')) document.getElementById('marg-font').value = config.marginalia[currentMarginaliaTarget].font;
      if (document.getElementById('marg-size')) { document.getElementById('marg-size').value = config.marginalia[currentMarginaliaTarget].size; document.getElementById('val-marg-size').innerText = config.marginalia[currentMarginaliaTarget].size; }
      if (document.getElementById('marg-weight')) { document.getElementById('marg-weight').value = config.marginalia[currentMarginaliaTarget].weight || 400; document.getElementById('val-marg-weight').innerText = config.marginalia[currentMarginaliaTarget].weight || 400; }
      if (document.getElementById('marg-spacing')) { document.getElementById('marg-spacing').value = config.marginalia[currentMarginaliaTarget].spacing; document.getElementById('val-marg-spacing').innerText = config.marginalia[currentMarginaliaTarget].spacing; }
  }

  // ãƒˆãƒªãƒŸãƒ³ã‚°ç”¨å¤‰æ•°
  let cropCanvas = document.getElementById('crop-canvas');
  let cropCtx = cropCanvas.getContext('2d');
  let cropImageObj = null;
  let cropState = { scale: 1.0, x: 0, y: 0, minScale: 1.0 };
  let isCropDragging = false;
  let cropStartX=0, cropStartY=0;
  let cropStartState = { x: 0, y: 0 };
  const MAX_IMG_SIZE = 2400; // px: ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰æ™‚ã«è»½ããƒªã‚µã‚¤ã‚ºã™ã‚‹æœ€å¤§ä¸€è¾ºï¼ˆç”»è³ªé‡è¦–ï¼‰
  const STORAGE_LIMIT_BYTES = 4.5 * 1024 * 1024; // autosaveç›®æ¨™ä¸Šé™

  // ç”»åƒåœ§ç¸®ï¼ˆãƒªã‚µã‚¤ã‚ºï¼‹å†ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‰ï¼‰ã€‚ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã¯ç”»è³ªå¯„ã‚Šï¼ˆå“è³ª0.9ã€ä¸€è¾ºMAX_IMG_SIZEï¼‰
  async function compressImage(src, maxSize = MAX_IMG_SIZE, quality = 0.9) {
      return new Promise((resolve) => {
          const img = new Image();
          img.onload = () => {
              try {
                  const { width, height } = img;
                  let targetW = width, targetH = height;
                  if (Math.max(width, height) > maxSize) {
                      const scale = maxSize / Math.max(width, height);
                      targetW = Math.round(width * scale);
                      targetH = Math.round(height * scale);
                  }
                  const cvs = document.createElement('canvas');
                  cvs.width = targetW;
                  cvs.height = targetH;
                  const ctx = cvs.getContext('2d');
                  ctx.drawImage(img, 0, 0, targetW, targetH);
                  const out = cvs.toDataURL('image/jpeg', quality);
                  resolve(out);
              } catch(e) {
                  console.error('compressImage failed', e);
                  resolve(src);
              }
          };
          img.onerror = () => resolve(src);
          img.src = src;
      });
  }

  // ç”»åƒã‚’ã‚¤ãƒ³ã‚¯è‰²ã«ãƒãƒƒãƒ—ã™ã‚‹ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£ï¼ˆç™½â†’ç´™è‰²ã€é»’â†’ã‚¤ãƒ³ã‚¯è‰²ï¼‰
  function lerpColor(c1, c2, t) {
      return {
          r: Math.round(c1.r + (c2.r - c1.r) * t),
          g: Math.round(c1.g + (c2.g - c1.g) * t),
          b: Math.round(c1.b + (c2.b - c1.b) * t),
      };
  }
  function hexToRgb(hex) {
      const v = parseInt(hex.slice(1), 16);
      return { r: (v >> 16) & 255, g: (v >> 8) & 255, b: v & 255 };
  }
  function clamp01(v) { return Math.min(1, Math.max(0, v)); }
  // ç”»åƒã‚’ã‚¤ãƒ³ã‚¯è‰²ã«å¤‰æ›ã€‚è‰²å¤‰æ›´ã‚„æ›¸ãå‡ºã—å‰ã«ã‚‚å†è¨ˆç®—ã§ãã‚‹ã‚ˆã†Promiseã§è¿”ã™
  function convertImageToInk(g, shouldRender = true) {
      return new Promise((resolve) => {
          if (!g.imageSrc) { resolve(); return; }
          const img = new Image();
          img.crossOrigin = 'anonymous';
          img.onload = () => {
              try {
                  const cvs = document.createElement('canvas');
                  cvs.width = img.width; cvs.height = img.height;
                  const ctx = cvs.getContext('2d');
                  ctx.drawImage(img, 0, 0);
                  const imgData = ctx.getImageData(0, 0, cvs.width, cvs.height);
                  const data = imgData.data;
                  const paper = hexToRgb(config.paperColor || '#ffffff');
                  const ink = hexToRgb(config.textColor || '#000000');
                  const luma = (c) => (0.299 * c.r + 0.587 * c.g + 0.114 * c.b) / 255;
                  const inkIsDarker = luma(ink) < luma(paper); // trueãªã‚‰ç™½â†’ç´™ã€é»’â†’ã‚¤ãƒ³ã‚¯ã€‚falseãªã‚‰åè»¢ã§ç™½â†’ã‚¤ãƒ³ã‚¯ã€é»’â†’ç´™ã€‚
                  const contrast = g.inkContrast ?? 1.0; // 1.0=é€šå¸¸
                  const bright = g.inkBrightness ?? 0.0; // -1..1
                  for (let i = 0; i < data.length; i += 4) {
                      const r = data[i], gch = data[i+1], b = data[i+2];
                      let lum = (0.299*r + 0.587*gch + 0.114*b) / 255; // 0=é»’,1=ç™½
                      lum = (lum - 0.5) * contrast + 0.5 + bright; // ã‚³ãƒ³ãƒˆãƒ©ã‚¹ãƒˆ/æ˜ã‚‹ã•èª¿æ•´
                      lum = clamp01(lum);
                      const col = inkIsDarker ? lerpColor(ink, paper, lum) : lerpColor(paper, ink, lum);
                      data[i] = col.r; data[i+1] = col.g; data[i+2] = col.b;
                  }
                  ctx.putImageData(imgData, 0, 0);
                  g.imageInkSrc = cvs.toDataURL('image/png');
                  if (shouldRender) renderGroups();
              } catch(e) {
                  console.error("convertImageToInk failed:", e);
              } finally {
                  resolve();
              }
          };
          img.onerror = () => { resolve(); };
          img.src = g.imageSrc;
      });
  }

  // --- åˆæœŸåŒ– ---
  function init() {
    updateFontSelectors(); 
    selectMarginaliaTarget('left');
    
    // AutoSaveã®ç¢ºèª
    if (localStorage.getItem('shinbun_autosave_v82')) {
        if(confirm("å‰å›ä½œæ¥­ã—ã¦ã„ãŸå†…å®¹ãŒæ®‹ã£ã¦ã„ã¾ã™ã€‚å¾©å…ƒã—ã¾ã™ã‹ï¼Ÿ")) {
            restoreAutosave();
        } else {
            localStorage.removeItem('shinbun_autosave_v82');
        }
    }
    
    updatePaperSize(); // ã‚µã‚¤ã‚ºåˆæœŸåŒ–
    fitView();
    setTool('hand');
    updateColors();
    isDirty = false;
  }

  // --- ãƒ•ã‚¡ã‚¤ãƒ«æ“ä½œ ---
  function openFileMenu() { document.getElementById('file-menu-overlay').style.display = 'flex'; }
  function openExportMenu() { document.getElementById('export-menu-overlay').style.display = 'flex'; }

  function saveFile(saveAs) {
      const data = {
          version: "Ver.84",
          timestamp: new Date().toISOString(),
          config: config,
          groups: groups
      };
      const jsonStr = JSON.stringify(data, null, 2);
      const blob = new Blob([jsonStr], {type: "application/json"});
      
      let fileName = currentFileName;
      if (saveAs) {
          const input = prompt("ãƒ•ã‚¡ã‚¤ãƒ«åã‚’å…¥åŠ›ã—ã¦ãã ã•ã„", currentFileName);
          if (!input) return; // ã‚­ãƒ£ãƒ³ã‚»ãƒ«
          fileName = input;
          if(!fileName.endsWith(".json")) fileName += ".json";
      }
      currentFileName = fileName;

      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = fileName;
      a.click();
      URL.revokeObjectURL(url);
      
      isDirty = false;
      document.getElementById('file-menu-overlay').style.display='none';
  }

  function loadFile(input) {
      if (!input.files || !input.files[0]) return;
      const file = input.files[0];
      const reader = new FileReader();
      reader.onload = function(e) {
          try {
              const data = JSON.parse(e.target.result);
              if (data.config && data.groups) {
                  config = data.config;
                  groups = data.groups;
                  currentFileName = file.name;
                  applyConfigToUI();
                  updatePaperSize();
                  updateColors();
                  isDirty = false;
                  saveToLocalStorage();
              } else {
                  alert("ç„¡åŠ¹ãªãƒ•ã‚¡ã‚¤ãƒ«å½¢å¼ã§ã™ã€‚");
              }
          } catch(err) {
              alert("èª­ã¿è¾¼ã¿ã‚¨ãƒ©ãƒ¼: " + err);
          }
      };
      reader.readAsText(file);
      document.getElementById('file-menu-overlay').style.display='none';
      input.value = '';
  }

  function resetCanvasConfirm() {
      if (confirm("ç¾åœ¨ã®ä½œæ¥­å†…å®¹ã¯å¤±ã‚ã‚Œã¾ã™ã€‚æ–°è¦ä½œæˆã—ã¾ã™ã‹ï¼Ÿ")) {
          groups = [];
          undoStack = []; redoStack = [];
          isDirty = false;
          renderGroups();
          localStorage.removeItem('shinbun_autosave_v82');
          document.getElementById('file-menu-overlay').style.display='none';
      }
  }

  // --- Auto Save (Local Storage) ---
  async function saveToLocalStorage() {
      const baseData = () => ({
          version: "Ver.84",
          timestamp: new Date().toISOString(),
          config: config,
          groups: groups,
          fileName: currentFileName
      });
      const indicator = (msg = "ä¿å­˜ã—ã¾ã—ãŸ") => {
          const ind = document.getElementById('auto-save-indicator');
          if (!ind) return;
          ind.textContent = msg;
          ind.style.opacity = 1;
          setTimeout(() => { ind.style.opacity = 0; }, 2000);
      };
      const estimateBytes = (obj) => JSON.stringify(obj).length * 2; // UTF-16æ›ç®—ã®ã–ã£ãã‚Šå®¹é‡
      const imageGroups = groups.filter(g => g.type === 'image');

      // æ®µéšçš„ã«åœ§ç¸®ãƒ¬ãƒ™ãƒ«ã‚’ä¸Šã’ã¦4.5MBæœªæº€ã‚’ç›®æŒ‡ã™ï¼ˆã§ãã‚‹ã ã‘å¼±ã„åœ§ç¸®ã‹ã‚‰è©¦ã™ï¼‰
      const compressLevels = [
          { maxSize: 1400, quality: 0.75, label: "å¼±" },
          { maxSize: 1200, quality: 0.65, label: "ä¸­" },
          { maxSize: 1000, quality: 0.55, label: "å¼·" },
          { maxSize: 800,  quality: 0.45, label: "æœ€å¼·" }
      ];

      const buildDataWithCompression = async (level) => {
          const tasks = groups.map(async g => {
              if (g.type !== 'image') return g;
              const compressed = g.imageSrc ? await compressImage(g.imageSrc, level.maxSize, level.quality) : null;
              return { ...g, imageSrc: compressed, originalSrc: compressed, imageInkSrc: null };
          });
          const newGroups = await Promise.all(tasks);
          const data = { ...baseData(), groups: newGroups, autosaveNote: `compress:${level.label}` };
          return { data, size: estimateBytes(data), level };
      };

      try {
          // ã¾ãšã¯ç¾çŠ¶ã®ã¾ã¾ã‚µã‚¤ã‚ºãƒã‚§ãƒƒã‚¯
          let data = baseData();
          let size = estimateBytes(data);
          if (size > STORAGE_LIMIT_BYTES) {
              // åœ§ç¸®æ®µéšã‚’è©¦ã™
              let appliedLevel = null;
              for (const lvl of compressLevels) {
                  const res = await buildDataWithCompression(lvl);
                  data = res.data; size = res.size;
                  appliedLevel = lvl;
                  if (size <= STORAGE_LIMIT_BYTES) break;
              }
              // ãã‚Œã§ã‚‚è¶…ãˆã‚‹å ´åˆã¯ç”»åƒã‚’çœç•¥
              if (size > STORAGE_LIMIT_BYTES) {
                  const slimGroups = groups.map(g => {
                      if (g.type !== 'image') return g;
                      const { imageSrc, imageInkSrc, originalSrc, ...rest } = g;
                      return { ...rest, imageSrc: null, imageInkSrc: null, originalSrc: null, hasImageOmitted: true };
                  });
                  data = { ...baseData(), groups: slimGroups, autosaveNote: "images omitted to fit storage" };
                  size = estimateBytes(data);
                  indicator(`ä¿å­˜ã—ã¾ã—ãŸï¼ˆç”»åƒçœç•¥: ${imageGroups.length}ä»¶ / æ¨å®š ${Math.round(size/1024)} KBï¼‰`);
              } else {
                  indicator(`ä¿å­˜ã—ã¾ã—ãŸï¼ˆç”»åƒ${imageGroups.length}ä»¶ / åœ§ç¸®:${appliedLevel ? appliedLevel.label : "ãªã—"} / ç´„${Math.round(size/1024)} KBï¼‰`);
              }
          } else {
              indicator(`ä¿å­˜ã—ã¾ã—ãŸï¼ˆç”»åƒ${imageGroups.length}ä»¶ / ç´„${Math.round(size/1024)} KBï¼‰`);
          }
          localStorage.setItem('shinbun_autosave_v82', JSON.stringify(data));
      } catch(err) {
          console.error("Auto Save Failed:", err);
          indicator("ä¿å­˜ã«å¤±æ•—ã—ã¾ã—ãŸï¼ˆå®¹é‡ä¸è¶³ï¼‰");
      }
  }

  function restoreAutosave() {
      try {
          const raw = localStorage.getItem('shinbun_autosave_v82');
          if (!raw) return;
          const data = JSON.parse(raw);
          config = data.config;
          groups = data.groups;
          currentFileName = data.fileName || "restored_shinbun.json";
          
          applyConfigToUI();
          updatePaperSize();
          updateColors();
          isDirty = false;
          console.log("Restored from Autosave");
      } catch(e) {
          console.error("Restore Failed:", e);
      }
  }


  // --- ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆ (html2canvas) ---
  
  async function exportCanvasToImage(format) {
      document.getElementById('export-menu-overlay').style.display='none';
      deselectAll();
      document.body.classList.add('preview-mode');
      // ã‚¤ãƒ³ã‚¯ç”»åƒã‚’æœ€æ–°è‰²ã§åæ˜ ã•ã›ã¦ã‹ã‚‰æ›¸ãå‡ºã—
      const inkTasks = [];
      groups.forEach(g => {
          if (g.type === 'image' && g.colorMode === 'ink' && !g.imageInkSrc) {
              inkTasks.push(convertImageToInk(g, false));
          }
      });
      if (inkTasks.length > 0) {
          await Promise.all(inkTasks);
          renderGroups();
      }
      
      const gridWasVisible = document.getElementById('chk-grid') ? document.getElementById('chk-grid').checked : true;
      const gridPrevDisplay = gridLayer.style.display;
      gridLayer.style.display = 'none'; // æ›¸ãå‡ºã—ã¯æ–‡å­—ãƒã‚¹ã‚’å¿…ãšéè¡¨ç¤º
      gridLayer.style.opacity = 0;
      await document.fonts.ready;
      renderGroups();
      
      const paperElement = document.querySelector('.paper');
      
      // ç¾åœ¨ã®ViewçŠ¶æ…‹ã‚’ä¿å­˜
      const originalTransform = canvasTransform.style.transform;
      const originalLeft = paperElement.style.left;
      const originalTop = paperElement.style.top;
      const originalParent = paperElement.parentNode;
      const originalNext = paperElement.nextSibling;
      const originalBodyOverflow = document.body.style.overflow;
      const originalHtmlOverflow = document.documentElement.style.overflow;
      
      // æ›¸ãå‡ºã—ç”¨ã«ãƒªã‚»ãƒƒãƒˆï¼ˆå¤‰å½¢ãªã©ã‚’ç¶­æŒã—ã¤ã¤ã€ä½ç½®ã‚’åŸç‚¹ã¸ï¼‰
      window.scrollTo(0,0);
      canvasTransform.style.transform = "scale(1)"; // ãƒ“ãƒ¥ãƒ¼ãƒãƒ¼ãƒˆã®ã‚ºãƒ¼ãƒ ã‚’è§£é™¤
      paperElement.style.left = "0px";
      paperElement.style.top = "0px";
      paperElement.style.margin = "0";
      
      // ç¥–å…ˆã®overflowã«ã‚ˆã‚‹ã‚¯ãƒªãƒƒãƒ”ãƒ³ã‚°ã‚’é¿ã‘ã‚‹ãŸã‚ã€ç”¨ç´™ã‚’ä¸€æ™‚çš„ã«ãƒœãƒ‡ã‚£ç›´ä¸‹ã¸é€€é¿ã•ã›ã‚‹
      const tempWrapper = document.createElement('div');
      tempWrapper.style.position = 'absolute';
      tempWrapper.style.top = '0';
      tempWrapper.style.left = '0';
      tempWrapper.style.overflow = 'visible';
      tempWrapper.style.zIndex = '-1';
      document.body.appendChild(tempWrapper);
      tempWrapper.appendChild(paperElement);
      document.body.style.overflow = 'visible';
      document.documentElement.style.overflow = 'visible';

      try {
          // html2canvaså®Ÿè¡Œ (useCORSã§ç”»åƒèª­ã¿è¾¼ã¿å¯¾å¿œã€allowTaintã¯é¿ã‘ã‚‹)
          // é«˜ã•è¨ˆç®—ã®ä¸æ•´åˆã‚’é˜²ããŸã‚ã€windowHeightç­‰ã‚’æ˜ç¤º
          const canvas = await html2canvas(paperElement, {
              scale: 2, // é«˜è§£åƒåº¦
              useCORS: true, 
              logging: false,
              backgroundColor: null, // é€éPNGå¯¾å¿œ
              scrollX: 0, scrollY: 0,
              x: 0, y: 0,
              width: paperElement.offsetWidth,
              height: paperElement.offsetHeight, // ã“ã“ã‚’è¦ç´ ã®é«˜ã•ã«åˆã‚ã›ã‚‹
              windowWidth: paperElement.scrollWidth,
              windowHeight: paperElement.scrollHeight,
              foreignObjectRendering: true // writing-modeãªã©CSSä¾å­˜æç”»ã‚’ãƒ–ãƒ©ã‚¦ã‚¶ã«å§”è­²
          });
          
          const link = document.createElement('a');
          if (format === 'png') {
              link.href = canvas.toDataURL('image/png');
              link.download = 'shinbun.png';
          } else {
              link.href = canvas.toDataURL('image/jpeg', 0.9);
              link.download = 'shinbun.jpg';
          }
          link.click();
          
      } catch (err) {
          alert("æ›¸ãå‡ºã—ã«å¤±æ•—ã—ã¾ã—ãŸ: " + err);
          console.error(err);
      } finally {
          // ç”¨ç´™ã‚’å…ƒã®ä½ç½®ã«æˆ»ã™
          if (tempWrapper && tempWrapper.parentNode) {
              originalParent.insertBefore(paperElement, originalNext);
              tempWrapper.remove();
          }
          document.body.style.overflow = originalBodyOverflow;
          document.documentElement.style.overflow = originalHtmlOverflow;
          // çŠ¶æ…‹å¾©å…ƒ
          document.body.classList.remove('preview-mode');
          canvasTransform.style.transform = originalTransform;
          paperElement.style.left = originalLeft;
          paperElement.style.top = originalTop;
          gridLayer.style.display = gridPrevDisplay;
          gridLayer.style.opacity = gridWasVisible ? 1 : 0;
          renderGroups();
      }
  }

  // çµ‚äº†æ™‚ç¢ºèª (æœªä¿å­˜ã®å ´åˆ)
  window.onbeforeunload = function(e) {
      if (isDirty) { 
          e.preventDefault();
          e.returnValue = ''; 
      }
  };

  function setTool(tool) {
    currentTool = tool;
    document.querySelectorAll('.tool-btn').forEach(b => b.classList.remove('active'));
    document.getElementById('tool-' + tool).classList.add('active');
    
    if (tool === 'hand') {
        document.body.classList.add('tool-hand');
        viewport.style.cursor = 'grab';
    } else {
        document.body.classList.remove('tool-hand');
        viewport.style.cursor = 'crosshair';
    }
    deselectAll();
  }
  
  function switchPanel(panelId) {
    document.querySelectorAll('.panel-section').forEach(el => el.classList.remove('active'));
    const target = document.getElementById(panelId);
    if(target) target.classList.add('active');
  }
  
  function setCreationMode(mode) {
      isFreeCreationMode = (mode === 'free');
  }

  function swapPaperWH() {
      const wInput = document.getElementById('paper-w-mm');
      const hInput = document.getElementById('paper-h-mm');
      const temp = wInput.value;
      wInput.value = hInput.value;
      hInput.value = temp;
      document.getElementById('paper-preset').value = 'custom';
      updatePaperSize();
  }

  function updatePaperConfigInternal() {
    config.pageDanCount = parseInt(document.getElementById('paper-dan-count').value);
    config.rowsPerDan = parseInt(document.getElementById('paper-rows-per-dan').value);
    config.charsPerDan = parseInt(document.getElementById('paper-chars-per-dan').value);
    
    document.getElementById('val-paper-dan-count').innerText = config.pageDanCount;
    document.getElementById('val-paper-rows-per-dan').innerText = config.rowsPerDan;
    document.getElementById('val-paper-chars-per-dan').innerText = config.charsPerDan;

    calculateLayout();
  }

function updatePaperSize() {
      const preset = document.getElementById('paper-preset').value;
      const wInput = document.getElementById('paper-w-mm');
      const hInput = document.getElementById('paper-h-mm');

      if (preset !== 'custom') {
          let w, h;
          switch(preset) {
              case 'A3': w=297; h=420; break;
              case 'A4': w=210; h=297; break;
              case 'B4': w=257; h=364; break;
          }
          wInput.value = w; hInput.value = h;
      }
      config.paperW = parseFloat(wInput.value);
      config.paperH = parseFloat(hInput.value);
      
      root.style.setProperty('--paper-w', config.paperW + 'mm');
      root.style.setProperty('--paper-h', config.paperH + 'mm');
      
      calculateLayout();
  }

  function updateMargins() {
      config.marginTop = parseFloat(document.getElementById('margin-top').value);
      config.marginBottom = parseFloat(document.getElementById('margin-bottom').value);
      config.marginOuter = parseFloat(document.getElementById('margin-left').value); 
      config.marginInner = parseFloat(document.getElementById('margin-right').value); 

      calculateLayout();
  }

  // --- å¤–å‘¨æƒ…å ± (Marginalia) åˆ¶å¾¡ ---

  function selectMarginaliaTarget(target) {
      currentMarginaliaTarget = target;
      document.querySelectorAll('.btn-group-item').forEach(b => b.classList.remove('active'));
      document.getElementById('btn-marg-' + target).classList.add('active');

      const data = config.marginalia[target];
      document.getElementById('marg-text').value = data.text;
      document.getElementById('marg-font').value = data.font;
      document.getElementById('marg-size').value = data.size;
      document.getElementById('marg-weight').value = data.weight || 400;
      document.getElementById('marg-spacing').value = data.spacing;
      
      document.getElementById('val-marg-size').innerText = data.size;
      document.getElementById('val-marg-weight').innerText = data.weight || 400;
      document.getElementById('val-marg-spacing').innerText = data.spacing;
  }

  function updateMarginaliaConfig() {
      const target = currentMarginaliaTarget;
      const data = config.marginalia[target];
      
      data.text = document.getElementById('marg-text').value;
      data.font = document.getElementById('marg-font').value;
      data.size = parseFloat(document.getElementById('marg-size').value);
      data.weight = parseInt(document.getElementById('marg-weight').value) || 400;
      data.spacing = parseFloat(document.getElementById('marg-spacing').value);

      document.getElementById('val-marg-size').innerText = data.size;
      document.getElementById('val-marg-weight').innerText = data.weight;
      document.getElementById('val-marg-spacing').innerText = data.spacing;
      
      renderMarginalia();
      isDirty = true;
      saveToLocalStorage();
  }

  function renderMarginalia() {
      const leftEl = document.getElementById('info-left');
      const centerEl = document.getElementById('info-center');
      const rightEl = document.getElementById('info-right');
      
      const setStyleAndText = (el, data) => {
          el.innerText = data.text;
          const weight = data.weight || 400;
          el.style = `font-family: ${data.font}; font-size: ${data.size}pt; letter-spacing: ${data.spacing}px; font-weight: ${weight};`;
      };

      setStyleAndText(leftEl, config.marginalia.left);
      setStyleAndText(centerEl, config.marginalia.center);
      setStyleAndText(rightEl, config.marginalia.right);
  }

  function renderColorPatch() {
      const container = document.getElementById('color-patches-bottom');
      const colors = [
          '#000000', // K
          'none',    // Paper (Stroke only)
          '#ffff00', // Y
          '#ff00ff', // M
          '#00ffff', // C
          '#000000', // K
          '#000000'  // K
      ];
      
      const patchSize = 3.78; // 1mm in px approx
      const gap = 11.34; // 3mm in px approx
      
      let html = '';
      colors.forEach((c, i) => {
          let fill = c;
          let stroke = 'none';
          if (c === 'none') {
              fill = config.paperColor;
              stroke = 'none'; 
          }
          const r = patchSize / 2;
          const cx = r; const cy = r;
          const d = `M ${cx} 0 L ${patchSize} ${cy} L ${cx} ${patchSize} L 0 ${cy} Z`;
          
          html += `<svg width="${patchSize}" height="${patchSize}" class="color-patch-svg" style="margin: 0 ${gap/2}px;">
                    <path d="${d}" fill="${fill}" stroke="${stroke}" stroke-width="0.5" />
                   </svg>`;
      });
      container.innerHTML = html;
  }

  function calculateLayout() {
    const fontEl = document.getElementById('inp-font');
    if(fontEl && fontEl.value) {
        config.fontFamily = fontEl.value;
    }

    const effectiveH_px = (config.paperH - config.marginTop - config.marginBottom) * PX_PER_MM;
    const logicalH_px = effectiveH_px / SCALE_Y;
    const totalUnitsV = (config.charsPerDan * config.pageDanCount) + (config.charsGap * (config.pageDanCount - 1));
    let calculatedFontSize = logicalH_px / totalUnitsV;
    if (calculatedFontSize < 10) calculatedFontSize = 10;
    config.baseFontSize = calculatedFontSize;

    const effectiveW_px = (config.paperW - config.marginInner - config.marginOuter) * PX_PER_MM;
    let calcLineGap = 0;
    if (config.rowsPerDan > 1) {
      calcLineGap = (effectiveW_px - (config.baseFontSize * config.rowsPerDan)) / (config.rowsPerDan - 1);
    }
    if (calcLineGap < 0) calcLineGap = 0;
    config.lineGap = calcLineGap;

    updateSettingsInternal();
  }

  function updateSettingsInternal() {
    baseHDan = config.baseFontSize * config.charsPerDan;
    baseHGap = config.baseFontSize * config.charsGap;
    baseHUnit = baseHDan + baseHGap;
    
    physicalHDan = baseHDan * SCALE_Y;
    physicalHGap = baseHGap * SCALE_Y;
    physicalHUnit = baseHUnit * SCALE_Y;
    
    linePitch = config.baseFontSize + config.lineGap;

    root.style.setProperty('--base-font-size', config.baseFontSize + 'px');
    root.style.setProperty('--line-gap', config.lineGap + 'px');
    root.style.setProperty('--h-gap', baseHGap + 'px'); 
    
    root.style.setProperty('--m-top', config.marginTop + 'mm');
    root.style.setProperty('--m-bottom', config.marginBottom + 'mm');
    root.style.setProperty('--m-inner', config.marginInner + 'mm');
    root.style.setProperty('--m-outer', config.marginOuter + 'mm');
    root.style.setProperty('--font-family', config.fontFamily);
    root.style.setProperty('--font-weight', config.fontWeight);
    
    updateVisuals();
    renderLayoutLines(); 
    renderPaperGrid();       
    renderGroups();
    renderMarginalia();
    renderColorPatch();
    saveToLocalStorage();
  }

  async function updateColors() {
    config.gridColor = document.getElementById('inp-grid-color').value;
    config.paperColor = document.getElementById('inp-paper-color').value;
    config.textColor = document.getElementById('inp-text-color').value; 
    
    config.borderWidth = parseFloat(document.getElementById('inp-border-width').value);
    config.dividerWidth = parseFloat(document.getElementById('inp-divider-width').value);
    document.getElementById('val-border-width').innerText = config.borderWidth;
    document.getElementById('val-divider-width').innerText = config.dividerWidth;

    document.querySelector('.paper').style.backgroundColor = config.paperColor;
    root.style.setProperty('--text-color', config.textColor);
    root.style.setProperty('--paper-color', config.paperColor);
    root.style.setProperty('--border-width', config.borderWidth + 'px');
    root.style.setProperty('--divider-width', config.dividerWidth + 'px');
    updatePatternColor();
    
    // ã‚¤ãƒ³ã‚¯è‰²ç”»åƒã¯è‰²å¤‰æ›´ã«åˆã‚ã›ã¦å†ç”Ÿæˆã™ã‚‹ï¼ˆå…¨ã¦å®Œäº†å¾Œã«å†æç”»ï¼‰
    const inkTasks = [];
    groups.forEach(g => {
        if (g.type === 'image' && g.colorMode === 'ink') {
            g.imageInkSrc = null;
            inkTasks.push(convertImageToInk(g, false));
        }
    });
    await Promise.all(inkTasks);
    
    renderPaperGrid(); renderGroups(); renderColorPatch();
    isDirty = true;
    saveToLocalStorage();
  }

  function updateVisuals() {
    config.glyphScale = parseFloat(document.getElementById('inp-glyph-scale').value);
    document.getElementById('val-glyph-scale').innerText = config.glyphScale;
    if (document.getElementById('inp-font-weight')) {
        config.fontWeight = parseInt(document.getElementById('inp-font-weight').value) || 400;
        document.getElementById('val-font-weight').innerText = config.fontWeight;
        root.style.setProperty('--font-weight', config.fontWeight);
    }
    root.style.setProperty('--glyph-scale', config.glyphScale);
    root.style.setProperty('--nudge-x', config.nudgeX + 'px');
    root.style.setProperty('--nudge-y', config.nudgeY + 'px');
    renderGroups();
    isDirty = true;
    saveToLocalStorage();
  }
  
  function updateHeadlineAttr() {
    if (!selectedId) return;
    const g = groups.find(i => i.id === selectedId);
    if (!g || g.type !== 'headline') return;
    g.fontFamily = document.getElementById('hl-font').value;
    g.fontWeight = document.getElementById('hl-weight').value;
    g.isInverted = document.getElementById('hl-inverted').checked;
    g.padLong = parseInt(document.getElementById('hl-pad-long').value); document.getElementById('val-hl-pad-long').innerText = g.padLong;
    g.padShort = parseInt(document.getElementById('hl-pad-short').value); document.getElementById('val-hl-pad-short').innerText = g.padShort;
    renderGroups();
    isDirty = true;
    saveToLocalStorage();
  }

  function updateVlineAttr() {
    if (!selectedId) return;
    const g = groups.find(i => i.id === selectedId);
    if (!g || g.type !== 'vline') return;
    g.lineWidth = parseInt(document.getElementById('vl-width').value);
    document.getElementById('val-vl-width').innerText = g.lineWidth;
    renderGroups();
    isDirty = true;
    saveToLocalStorage();
  }

  function updateArticleAttr() {
      if (!selectedId) return;
      const g = groups.find(i => i.id === selectedId);
      if (!g || g.type !== 'article') return;
      g.freeLayout = document.getElementById('art-free-layout').checked;
      
      if (g.freeLayout && !g.h) {
          g.h = (g.danCount * physicalHDan) + ((g.danCount - 1) * physicalHGap);
      }
      renderGroups();
      isDirty = true;
      saveToLocalStorage();
  }

  function updateHeaderAttr() {
      if (!selectedId) return;
      const g = groups.find(i => i.id === selectedId);
      if (!g || g.type !== 'header') return;
      
      g.text = document.getElementById('hdr-title').value;
      g.fontFamily = document.getElementById('hdr-font').value;
      
      g.publisher = document.getElementById('hdr-publisher').value;
      g.address = document.getElementById('hdr-address').value;
      g.contact = document.getElementById('hdr-contact').value;
      g.issue = document.getElementById('hdr-issue').value;
      
      g.infoFont = document.getElementById('hdr-info-font').value;
      g.infoSize = parseInt(document.getElementById('hdr-info-size').value);
      
      g.isTitleInverted = document.getElementById('hdr-text-inverted').checked;
      g.titleStrokeWidth = parseFloat(document.getElementById('hdr-text-stroke').value);

      g.titlePadV = parseInt(document.getElementById('hdr-pad-v').value);
      g.titlePadH = parseInt(document.getElementById('hdr-pad-h').value);
      
      g.borderOut = parseInt(document.getElementById('hdr-border-out').value);
      g.borderIn = parseInt(document.getElementById('hdr-border-in').value);
      
      renderGroups();
      isDirty = true;
      saveToLocalStorage();
  }

  function nudgeHeaderTitle(dx, dy, reset = false) {
      if (!selectedId) return;
      const g = groups.find(i => i.id === selectedId);
      if (!g || g.type !== 'header') return;

      const mult = (event && event.shiftKey) ? 10 : 1;
      const ndx = dx * mult; const ndy = dy * mult;

      if (reset) { 
          g.titleNudgeX = 0; g.titleNudgeY = 0; 
      } else {
          g.titleNudgeX = (g.titleNudgeX || 0) + ndx;
          g.titleNudgeY = (g.titleNudgeY || 0) + ndy;
      }
      renderGroups();
      isDirty = true;
      saveToLocalStorage();
  }

  function updateImageAttr() {
    if (!selectedId) return;
    const g = groups.find(i => i.id === selectedId);
    if (!g || g.type !== 'image') return;
    g.captionPos = document.getElementById('img-cap-pos').value;
    g.fontFamily = document.getElementById('img-font').value;
    
    g.colorMode = document.getElementById('img-color-mode').value;
    const inkArea = document.getElementById('ink-adjust-area');
    if (g.colorMode === 'ink') {
        inkArea.style.display = 'block';
        g.inkContrast = parseFloat(document.getElementById('img-contrast').value);
        g.inkBrightness = parseFloat(document.getElementById('img-brightness').value);
        document.getElementById('val-img-contrast').innerText = g.inkContrast.toFixed(1);
        document.getElementById('val-img-brightness').innerText = g.inkBrightness.toFixed(1);
        g.imageInkSrc = null;
        convertImageToInk(g);
    } else {
        inkArea.style.display = 'none';
    }
    
    renderGroups();
    isDirty = true;
    saveToLocalStorage();
  }

  async function handleImageUpload(input) {
      if (!selectedId || !input.files || !input.files[0]) return;
      const g = groups.find(i => i.id === selectedId);
      if (!g || g.type !== 'image') return;
      
      const file = input.files[0];
      const reader = new FileReader();
      reader.onload = async function(e) {
          saveHistory();
          // ç”»è³ªå„ªå…ˆã§è»½ããƒªã‚µã‚¤ã‚ºï¼ˆMAX_IMG_SIZE=2400, q=0.9ï¼‰ã€‚å…ƒç”»åƒãŒå°ã•ã‘ã‚Œã°ç„¡å¤‰æ›ã€‚
          const compressed = await compressImage(e.target.result, MAX_IMG_SIZE, 0.9);
          g.imageSrc = compressed;
          g.originalSrc = compressed; 
          g.imageInkSrc = null; // invalidate ink cache
          if (g.colorMode === 'ink') convertImageToInk(g);
          renderGroups();
      }
      reader.readAsDataURL(file);
      input.value = ''; 
  }

  // --- ãƒˆãƒªãƒŸãƒ³ã‚°æ©Ÿèƒ½ ---
  function openCropTool() {
      if (!selectedId) return;
      const g = groups.find(i => i.id === selectedId);
      if (!g || g.type !== 'image') return;
      
      if (!g.imageSrc && !g.originalSrc) {
          alert("ç”»åƒãŒé¸æŠã•ã‚Œã¦ã„ã¾ã›ã‚“ã€‚");
          return;
      }

      const src = g.originalSrc || g.imageSrc;
      cropImageObj = new Image();
      cropImageObj.onload = function() {
          const overlay = document.getElementById('crop-overlay');
          overlay.style.display = 'flex';
          
          const frameW = g.w; 
          let targetAspect = 1.0;
          const totalH = (g.h) ? g.h : ((g.danCount * physicalHDan) + ((g.danCount - 1) * physicalHGap));
          targetAspect = frameW / totalH;

          const maxViewW = Math.min(window.innerWidth * 0.8, 800);
          const maxViewH = Math.min(window.innerHeight * 0.6, 600);
          
          let canvasW = maxViewW;
          let canvasH = canvasW / targetAspect;
          
          if (canvasH > maxViewH) {
              canvasH = maxViewH;
              canvasW = canvasH * targetAspect;
          }

          cropCanvas.width = canvasW;
          cropCanvas.height = canvasH;
          document.getElementById('crop-canvas-container').style.width = canvasW + 'px';
          document.getElementById('crop-canvas-container').style.height = canvasH + 'px';

          const imgAspect = cropImageObj.width / cropImageObj.height;
          const frameAspect = canvasW / canvasH;

          let baseScale = 1.0;
          if (imgAspect > frameAspect) {
              baseScale = canvasH / cropImageObj.height;
          } else {
              baseScale = canvasW / cropImageObj.width;
          }
          
          cropState.minScale = baseScale;
          cropState.scale = baseScale;
          
          cropState.x = (canvasW - cropImageObj.width * baseScale) / 2;
          cropState.y = (canvasH - cropImageObj.height * baseScale) / 2;

          const slider = document.getElementById('crop-zoom');
          slider.min = baseScale;
          slider.max = baseScale * 5.0; 
          slider.value = baseScale;

          updateCropView();
      };
      cropImageObj.src = src;
  }

  function updateCropView() {
      if (!cropImageObj) return;
      
      const scaledW = cropImageObj.width * cropState.scale;
      const scaledH = cropImageObj.height * cropState.scale;
      
      if (cropState.x > 0) cropState.x = 0;
      if (cropState.y > 0) cropState.y = 0;
      if (cropState.x + scaledW < cropCanvas.width) cropState.x = cropCanvas.width - scaledW;
      if (cropState.y + scaledH < cropCanvas.height) cropState.y = cropCanvas.height - scaledH;

      cropCtx.clearRect(0, 0, cropCanvas.width, cropCanvas.height);
      cropCtx.drawImage(cropImageObj, cropState.x, cropState.y, scaledW, scaledH);
      document.getElementById('crop-zoom').value = cropState.scale;
  }

  cropCanvas.onmousedown = (e) => {
      isCropDragging = true;
      cropStartX = e.clientX;
      cropStartY = e.clientY;
      cropStartState = { x: cropState.x, y: cropState.y };
  };
  window.onmousemove = (e) => { 
      if (!isCropDragging || document.getElementById('crop-overlay').style.display === 'none') return;
      const dx = e.clientX - cropStartX;
      const dy = e.clientY - cropStartY;
      cropState.x = cropStartState.x + dx;
      cropState.y = cropStartState.y + dy;
      updateCropView();
  };
  window.onmouseup = () => { isCropDragging = false; };
  
  document.getElementById('crop-zoom').oninput = (e) => {
      const newScale = parseFloat(e.target.value);
      const oldScale = cropState.scale;
      const ratio = newScale / oldScale;
      const cx = cropCanvas.width / 2;
      const cy = cropCanvas.height / 2;
      cropState.x = cx - (cx - cropState.x) * ratio;
      cropState.y = cy - (cy - cropState.y) * ratio;
      cropState.scale = newScale;
      updateCropView();
  };

  async function applyCrop() {
      if (!selectedId || !cropImageObj) return;
      const g = groups.find(i => i.id === selectedId);
      const displayScale = cropState.scale; 
      const srcX = -cropState.x / displayScale;
      const srcY = -cropState.y / displayScale;
      const srcW = cropCanvas.width / displayScale;
      const srcH = cropCanvas.height / displayScale;
      
      const tempCvs = document.createElement('canvas');
      tempCvs.width = srcW;
      tempCvs.height = srcH;
      const tempCtx = tempCvs.getContext('2d');
      tempCtx.drawImage(cropImageObj, srcX, srcY, srcW, srcH, 0, 0, srcW, srcH);
      const croppedData = tempCvs.toDataURL('image/png');
      // ã‚¯ãƒ­ãƒƒãƒ—å¾Œã‚‚ç”»è³ªå¯„ã‚Šã§è»½ã‚ã®åœ§ç¸®ã®ã¿
      const compressed = await compressImage(croppedData, MAX_IMG_SIZE, 0.9);
      
      saveHistory();
      g.imageSrc = compressed;
      g.originalSrc = compressed; // æ¬¡å›ä»¥é™ã®ãƒˆãƒªãƒŸãƒ³ã‚°ãƒ™ãƒ¼ã‚¹ã‚‚æ›´æ–°
      g.imageInkSrc = null; // ã‚¤ãƒ³ã‚¯ãƒ¢ãƒ¼ãƒ‰ã®å ´åˆå†ç”Ÿæˆã•ã›ã‚‹
      if (g.colorMode === 'ink') {
          convertImageToInk(g, false);
      }
      closeCropEditor();
      renderGroups();
  }

  function closeCropEditor() {
      document.getElementById('crop-overlay').style.display = 'none';
      cropImageObj = null;
  }

  // --- å…±é€šæ“ä½œ ---
  function nudgeSelection(dx, dy, reset = false, evt = null) {
    const ev = evt || event;
    const mult = (ev && ev.shiftKey) ? 10 : 1;
    const ndx = dx * mult; const ndy = dy * mult;
    if (!selectedId) {
        if (reset) { config.nudgeX = 0; config.nudgeY = 0; }
        else { config.nudgeX += ndx; config.nudgeY += ndy; }
        updateVisuals();
    } else {
        const g = groups.find(i => i.id === selectedId);
        if (!g) return;
        if (reset) { g.nudgeX = 0; g.nudgeY = 0; }
        else { g.nudgeX = (g.nudgeX || 0) + ndx; g.nudgeY = (g.nudgeY || 0) + ndy; }
        renderGroups();
    }
    saveHistory();
  }

  function toggleGrid() {
    const show = document.getElementById('chk-grid').checked;
    gridLayer.style.opacity = show ? 1 : 0;
    if (show) { document.body.classList.remove('preview-mode'); }
    else { document.body.classList.add('preview-mode'); deselectAll(); }
  }


  function renderLayoutLines() {
    const effectiveH_px = (config.paperH - config.marginTop - config.marginBottom) * PX_PER_MM;
    const effectiveW_px = (config.paperW - config.marginInner - config.marginOuter) * PX_PER_MM;
    const mt = config.marginTop * PX_PER_MM;
    const ml = config.marginOuter * PX_PER_MM; 
    
    const off = 3 * PX_PER_MM;
    const borderX = ml - off; const borderY = mt - off;
    const borderW = effectiveW_px + (off * 2); const borderH = effectiveH_px + (off * 2);

    const borderLayer = document.getElementById('layout-border-layer');
    borderLayer.innerHTML = `<rect x="${borderX}" y="${borderY}" width="${borderW}" height="${borderH}" class="print-border" />`;

    let svgContent = '';
    for (let i = 0; i < config.pageDanCount - 1; i++) {
        let blockTop = mt + i * (physicalHDan + physicalHGap);
        let blockBottom = blockTop + physicalHDan;
        let lineY = blockBottom + (physicalHGap / 2);
        svgContent += `<line x1="${ml}" y1="${lineY}" x2="${ml + effectiveW_px}" y2="${lineY}" class="print-divider" />`;
    }
    document.getElementById('layout-lines-layer').innerHTML = svgContent;
  }

  function renderPaperGrid() {
    const w = linePitch; const h = baseHUnit; 
    const fW = config.baseFontSize; const fH = config.baseFontSize;
    const gColor = config.gridColor;
    const svg = `
      <svg width="${w}" height="${h}" xmlns="http://www.w3.org/2000/svg">
        <defs><pattern id="charPat" x="0" y="0" width="${w}" height="${fH}" patternUnits="userSpaceOnUse">
           <rect x="${config.lineGap}" y="0" width="${fW}" height="${fH}" fill="none" stroke="${gColor}" stroke-width="1" />
        </pattern></defs>
        <rect width="100%" height="100%" fill="url(#charPat)" />
      </svg>`;
    gridLayer.style.backgroundImage = `url("data:image/svg+xml;charset=utf-8,${encodeURIComponent(svg.trim())}")`;
    gridLayer.style.backgroundSize = `${w}px ${h}px`;
  }

  // --- Zoom / Pan ---
  function updateTransform() { canvasTransform.style.transform = `translate(${viewX}px, ${viewY}px) scale(${viewScale})`; }
  function fitView() {
    viewScale = 0.6;
    viewX = (window.innerWidth - 80 - 320 - (config.paperW * PX_PER_MM * viewScale)) / 2 + 80;
    viewY = 50;
    updateTransform();
  }

  viewport.addEventListener('wheel', (e) => {
    e.preventDefault();
    const mx = e.clientX; const my = e.clientY;
    const wx = (mx - viewX) / viewScale; const wy = (my - viewY) / viewScale;
    const factor = 0.05;
    const delta = -Math.sign(e.deltaY) * factor;
    const newScale = Math.min(Math.max(viewScale * (1 + delta), 0.1), 5.0);
    viewX = mx - wx * newScale; viewY = my - wy * newScale;
    viewScale = newScale;
    updateTransform();
  }, { passive: false });

  function screenToHanmen(sx, sy) {
    const rect = hanmen.getBoundingClientRect();
    return { x: (sx - rect.left) / viewScale, y: (sy - rect.top) / viewScale };
  }

  function startLinkFromPort(groupId, portEl) {
      const rect = portEl.getBoundingClientRect();
      const p = screenToHanmen(rect.left + rect.width/2, rect.top + rect.height/2);
      linkingSourceId = groupId;
      linkingSourceType = portEl.classList.contains('port-in') ? 'in' : 'out';
      linkingStartX = p.x; linkingStartY = p.y;
      opMode = 'link';
      tempLinkLine.setAttribute('d', `M ${linkingStartX} ${linkingStartY} L ${linkingStartX} ${linkingStartY}`);
      tempLinkLine.style.display = 'block';
      highlightCompatiblePorts(groupId);
      document.querySelectorAll('.port').forEach(el => el.classList.remove('port-hovered'));
  }

  function completeLinkTo(targetId, targetType) {
      if (!linkingSourceId || linkingSourceId === targetId) return;
      // æ¥ç¶šã¯ out -> in ã«é™å®šã€‚é–‹å§‹ãŒinã®å ´åˆã¯æ–¹å‘ã‚’åè»¢ã—ã¦è¨­å®šã™ã‚‹
      let fromId = linkingSourceId;
      let toId = targetId;
      if (linkingSourceType === targetType) return; // åŒç¨®ã¯æ¥ç¶šä¸å¯
      if (linkingSourceType === 'in' && targetType === 'out') {
          fromId = targetId; toId = linkingSourceId;
      }
      if (!checkLoop(fromId, toId)) {
          saveHistory();
          const src = groups.find(g => g.id === fromId);
          if (src) src.next = toId;
      } else {
          alert("ãƒ«ãƒ¼ãƒ—æ¥ç¶šã¯ã§ãã¾ã›ã‚“");
      }
      clearPortHighlights();
      tempLinkLine.style.display = 'none';
      linkingSourceId = null; linkingSourceType = null; opMode = 'none';
      renderGroups();
      selectObject(toId);
  }

  // --- Event Handlers ---
  function handlePointerDown(e) {
    if (activePointerId !== null && e.pointerId === undefined) return; // avoid synthetic mouse after pointer
    if (e.pointerId !== undefined) { activePointerId = e.pointerId; e.preventDefault(); }
    const key = e.pointerId || 'mouse';
    previousPointers.set(key, activePointers.get(key) || { x: e.clientX, y: e.clientY });
    activePointers.set(key, { x: e.clientX, y: e.clientY });
    if (activePointers.size === 2) {
        const pts = Array.from(activePointers.values());
        pinchStartDist = Math.hypot(pts[0].x - pts[1].x, pts[0].y - pts[1].y);
        pinchStartScale = viewScale;
        pinchCenter = { x: (pts[0].x + pts[1].x) / 2, y: (pts[0].y + pts[1].y) / 2 };
        pinchPrevCenter = { ...pinchCenter };
        pinchPrevDist = pinchStartDist;
        isPinching = true;
        opMode = 'none';
        return;
    }
    if (e.target.closest('.overlay-modal') || e.target.classList.contains('inline-editor')) return;
    const isTool = e.target.closest('.toolbar-container') || e.target.closest('.settings-panel');
    const isMenu = e.target.closest('.menu-overlay');
    if (!isTool && !isMenu && !['box','headline','correction','vline','image','header'].includes(currentTool)) deselectAll();

    isMouseDown = true; isDragging = false; 
    startX = e.clientX; startY = e.clientY;
    const hPos = screenToHanmen(e.clientX, e.clientY);

    if (currentTool === 'hand') {
        opMode = 'pan'; startViewX = viewX; startViewY = viewY;
        viewport.style.cursor = 'grabbing'; deselectAll(); return; 
    }

    if (e.target.classList.contains('port-out')) {
        const groupEl = e.target.closest('.article-group');
        const g = groups.find(item => item.id === groupEl.dataset.id);
        if (g && g.next) { saveHistory(); g.next = null; renderGroups(); selectObject(g.id); return; }
        if (linkingSourceId) { completeLinkTo(groupEl.dataset.id, 'out'); return; }
        startLinkFromPort(groupEl.dataset.id, e.target);
        return;
    }
    if (e.target.classList.contains('port-in')) {
        const groupEl = e.target.closest('.article-group');
        const gid = groupEl.dataset.id;
        const parent = groups.find(p => p.type === 'article' && p.next === gid);
        if (parent) { saveHistory(); parent.next = null; renderGroups(); selectObject(parent.id); return; }
        if (linkingSourceId) { completeLinkTo(gid, 'in'); return; }
        startLinkFromPort(gid, e.target);
        return;
    }
    // ãƒªãƒ³ã‚¯é–‹å§‹ä¸­ã«åˆ¥ã®å ´æ‰€ã‚’ã‚¯ãƒªãƒƒã‚¯ã—ãŸã‚‰ã‚­ãƒ£ãƒ³ã‚»ãƒ«
    if (linkingSourceId) {
        clearPortHighlights();
        tempLinkLine.style.display = 'none';
        linkingSourceId = null; linkingSourceType = null; opMode = 'none';
    }
    if (e.target.classList.contains('resize-handle')) {
        opMode = 'resize';
        const groupEl = e.target.closest('.article-group');
        targetId = groupEl.dataset.id;
        const g = groups.find(item => item.id === targetId);
        anchorRight = g.x + g.w; anchorTop = g.y;
        return;
    }
    const targetGroup = e.target.closest('.article-group');
    if (targetGroup && !e.target.classList.contains('port-in')) {
        // ã‚°ãƒªãƒƒãƒ‰éè¡¨ç¤º(preview-mode)æ™‚ã§ã‚‚ã‚¯ãƒªãƒƒã‚¯ã§ã‚°ãƒªãƒƒãƒ‰ã‚’æˆ»ã—ã¤ã¤é¸æŠã§ãã‚‹ã‚ˆã†ã«ã™ã‚‹
        if (document.body.classList.contains('preview-mode')) {
            const chk = document.getElementById('chk-grid');
            if (chk) { chk.checked = true; toggleGrid(); }
        }
        selectObject(targetGroup.dataset.id);
        opMode = 'move'; targetId = targetGroup.dataset.id;
        const g = groups.find(item => item.id === targetId);
        dragStartX = hPos.x; dragStartY = hPos.y;
        initialElemX = g.x; initialElemY = g.y;
        return;
    }
    if (['box','headline','correction','vline','image','header'].includes(currentTool)) {
        if (!document.body.classList.contains('preview-mode')) {
           deselectAll(); 
           opMode = 'draw_wait'; 
           const snap = calculateSnapPoint(hPos.x, hPos.y, currentTool);
           anchorSnapX = snap.x; anchorSnapY = snap.y;
        }
    }
  }
  viewport.onmousedown = handlePointerDown;
  viewport.addEventListener('pointerdown', handlePointerDown);

  function handlePointerMove(e) {
    if (e.pointerId !== undefined) {
        const prev = activePointers.get(e.pointerId);
        if (prev) previousPointers.set(e.pointerId, { ...prev });
        activePointers.set(e.pointerId, { x: e.clientX, y: e.clientY });
    }
    if (isPinching) {
        if (activePointers.size >= 2) {
            const keys = Array.from(activePointers.keys()).slice(0, 2);
            const p0 = activePointers.get(keys[0]); const p1 = activePointers.get(keys[1]);
            const pp0 = previousPointers.get(keys[0]) || p0; const pp1 = previousPointers.get(keys[1]) || p1;
            const curCenter = { x: (p0.x + p1.x) / 2, y: (p0.y + p1.y) / 2 };

            const v0 = { x: p0.x - pp0.x, y: p0.y - pp0.y };
            const v1 = { x: p1.x - pp1.x, y: p1.y - pp1.y };
            const dot = (v0.x * v1.x) + (v0.y * v1.y);
            const len0 = Math.hypot(v0.x, v0.y) || 1;
            const len1 = Math.hypot(v1.x, v1.y) || 1;
            const dotNorm = dot / (len0 * len1);

            const dist = Math.hypot(p0.x - p1.x, p0.y - p1.y);
            const doPan = dotNorm > 0.3; // åŒæ–¹å‘ãªã‚‰å¹³è¡Œç§»å‹•ã€åå¯¾ãªã‚‰ãƒ”ãƒ³ãƒã‚ºãƒ¼ãƒ 

            if (doPan) {
                const avgDx = (v0.x + v1.x) / 2;
                const avgDy = (v0.y + v1.y) / 2;
                viewX += avgDx * TOUCH_PAN_FACTOR;
                viewY += avgDy * TOUCH_PAN_FACTOR;
                updateTransform();
            } else if (!doPan && dist > 0) {
                const mx = curCenter.x; const my = curCenter.y;
                const wx = (mx - viewX) / viewScale; const wy = (my - viewY) / viewScale;
                const baseDist = pinchPrevDist || dist;
                const newScale = Math.min(Math.max(viewScale * (dist / baseDist), 0.1), 5.0);
                viewX = mx - wx * newScale;
                viewY = my - wy * newScale;
                viewScale = newScale;
                updateTransform();
            }
            pinchPrevCenter = curCenter;
            pinchPrevDist = dist;
        }
        return;
    }
    if (activePointerId !== null && e.pointerId !== undefined && activePointerId !== e.pointerId) return;
    if (activePointerId !== null && e.pointerId === undefined) return;
    if (!isMouseDown) return;
    if (!isDragging) {
        if (Math.sqrt(Math.pow(e.clientX - startX, 2) + Math.pow(e.clientY - startY, 2)) < DRAG_THRESHOLD) return;
        isDragging = true;
        if (opMode !== 'pan' && opMode !== 'link' && opMode !== 'draw_wait') saveHistory();
    }
    const hPos = screenToHanmen(e.clientX, e.clientY);

    if (opMode === 'pan') {
        viewX = startViewX + e.clientX - startX; viewY = startViewY + e.clientY - startY;
        updateTransform();
    } else if (opMode === 'link') {
        const cp1x = linkingStartX; const cp1y = linkingStartY + 50;
        const cp2x = hPos.x; const cp2y = hPos.y - 50;
        const d = `M ${linkingStartX} ${linkingStartY} C ${cp1x} ${cp1y}, ${cp2x} ${cp2y}, ${hPos.x} ${hPos.y}`;
        tempLinkLine.setAttribute('d', d);
        clearPortHighlights();
        highlightCompatiblePorts(linkingSourceId);
        document.querySelectorAll('.port').forEach(el => el.classList.remove('port-hovered'));
        const target = document.elementFromPoint(e.clientX, e.clientY);
        if (target && target.classList.contains('port')) target.classList.add('port-hovered');

    } else if ((opMode === 'draw_wait' || opMode === 'draw') && isDragging) {
        if (opMode === 'draw_wait') {
            opMode = 'draw';
            ghost = document.createElement('div'); ghost.className = 'ghost';
            hanmen.appendChild(ghost);
        }
        
        const fixedRight = anchorSnapX + config.baseFontSize;
        
        let unitH;
        if (currentTool === 'box') {
            unitH = isFreeCreationMode ? (config.baseFontSize * SCALE_Y) : physicalHUnit;
        } else {
            unitH = (currentTool === 'correction' || currentTool === 'image' || currentTool === 'headline' || currentTool === 'header') ? (config.baseFontSize * SCALE_Y) : physicalHUnit;
        }
        
        let finalY, snH;
        if (hPos.y < anchorSnapY) {
            finalY = anchorSnapY; snH = unitH;
        } else {
            let distY = hPos.y - anchorSnapY;
            let dc = Math.ceil(distY / unitH); if (dc < 1) dc = 1;
            
            if (currentTool === 'box') {
                snH = isFreeCreationMode ? (dc * unitH) : ((dc * physicalHDan) + ((dc - 1) * physicalHGap));
            } else {
                snH = (currentTool === 'correction' || currentTool === 'image' || currentTool === 'headline' || currentTool === 'header') ? (dc * unitH) : ((dc * physicalHDan) + ((dc - 1) * physicalHGap));
            }
            finalY = anchorSnapY;
        }

        let finalX, snW;
        if (hPos.x > fixedRight) {
             snW = config.baseFontSize; finalX = anchorSnapX;
        } else {
             const colRight = getColIndex(fixedRight - 1); 
             const colCurrent = getColIndex(hPos.x);
             const cols = Math.max(1, colCurrent - colRight + 1);
             snW = (cols * config.baseFontSize) + ((cols - 1) * config.lineGap);
             finalX = fixedRight - snW;
        }
        ghost.style.left = finalX + 'px'; ghost.style.top = finalY + 'px';
        ghost.style.width = snW + 'px'; ghost.style.height = snH + 'px';

    } else if (opMode === 'move') {
        let newX = initialElemX + hPos.x - dragStartX;
        let newY = initialElemY + hPos.y - dragStartY;
        const g = groups.find(item => item.id === targetId);
        
        const snap = calculateSnapPoint(newX, newY, g.type, g);
        const el = document.querySelector(`.article-group[data-id="${targetId}"]`);
        if(el) { el.style.left = snap.x + 'px'; el.style.top = snap.y + 'px'; }

    } else if (opMode === 'resize') {
        const g = groups.find(item => item.id === targetId);
        
        // è¨˜äº‹ã®ãƒ•ãƒªãƒ¼ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆå¯¾å¿œ
        let isFree = (g.type === 'article' && g.freeLayout);
        let unitH = (g.type === 'correction' || g.type === 'image' || g.type === 'headline' || g.type === 'header' || isFree) ? (config.baseFontSize * SCALE_Y) : physicalHUnit;
        
        let rawH = hPos.y - anchorTop;
        let minH = unitH;
        if (rawH < minH) rawH = minH; 
        
        let dc = Math.ceil(rawH / unitH); if (dc < 1) dc = 1;
        
        let snH = (g.type === 'correction' || g.type === 'image' || g.type === 'headline' || g.type === 'header' || isFree) ? (dc * unitH) : ((dc * physicalHDan) + ((dc - 1) * physicalHGap));

        let distW = anchorRight - hPos.x;
        let minW = config.baseFontSize;
        if (distW < minW) distW = minW; 
        let cols = Math.ceil(distW / linePitch); if (cols < 1) cols = 1;
        let snW = (cols * config.baseFontSize) + ((cols - 1) * config.lineGap);
        let newX = anchorRight - snW;
        
        const el = document.querySelector(`.article-group[data-id="${targetId}"]`);
        if(el) {
            el.style.left = newX + 'px'; el.style.top = anchorTop + 'px';
            el.style.width = snW + 'px'; el.style.height = snH + 'px';
        }
    }
  }
  window.addEventListener('mousemove', handlePointerMove);
  window.addEventListener('pointermove', handlePointerMove);

  function handlePointerUp(e) {
    activePointers.delete(e.pointerId || 'mouse');
    previousPointers.delete(e.pointerId || 'mouse');
    if (isPinching && activePointers.size < 2) {
        isPinching = false; pinchStartDist = 0; pinchPrevCenter = null; pinchPrevDist = 0;
    }
    if (activePointerId !== null && e.pointerId !== undefined && activePointerId !== e.pointerId) return;
    if (!isMouseDown) return; isMouseDown = false; activePointerId = null;
    viewport.style.cursor = (['box','headline','correction','vline','image','header'].includes(currentTool)) ? 'crosshair' : 'default';
    if (currentTool === 'hand') viewport.style.cursor = 'grab';

    if (!isDragging) {
        const targetGroup = e.target.closest('.article-group');
        if (targetGroup && currentTool !== 'hand' && !document.body.classList.contains('preview-mode')) {
           selectObject(targetGroup.dataset.id);
        } else if (!e.target.closest('.settings-panel') && !e.target.closest('.toolbar-container') && !e.target.closest('.menu-panel')) {
           deselectAll();
        }
        return;
    }
    if (opMode === 'link') {
        // ãƒã‚¦ã‚¹ã‚¢ãƒƒãƒ—ã§ã¯ç¢ºå®šã—ãªã„ï¼ˆã‚¯ãƒªãƒƒã‚¯ï¼†ã‚¯ãƒªãƒƒã‚¯ç”¨ï¼‰ã€‚ã‚­ãƒ£ãƒ³ã‚»ãƒ«æ“ä½œã¯åˆ¥é€”ã€‚
    } else if (opMode === 'draw' && ghost) {
        const x = parseFloat(ghost.style.left), y = parseFloat(ghost.style.top);
        const w = parseFloat(ghost.style.width), h = parseFloat(ghost.style.height);
        ghost.remove(); ghost = null;
        if (w > 0 && h > 0) { saveHistory(); addGroup(currentTool, x, y, w, h); }
    } else if (opMode === 'move' || opMode === 'resize') {
        const el = document.querySelector(`.article-group[data-id="${targetId}"]`);
        if (el) {
            const g = groups.find(item => item.id === targetId);
            if (opMode === 'move') { g.x = parseFloat(el.style.left); g.y = parseFloat(el.style.top); }
            else { 
                g.x = parseFloat(el.style.left); g.w = parseFloat(el.style.width);
                let hVal = parseFloat(el.style.height);
                
                if (g.type === 'correction' || g.type === 'image' || g.type === 'headline' || g.type === 'header' || (g.type === 'article' && g.freeLayout)) {
                    g.h = hVal; 
                } else {
                    g.danCount = Math.max(1, Math.round((hVal + physicalHGap) / physicalHUnit));
                }
            }
            renderGroups(); selectObject(targetId);
        }
    }
    isDragging = false; opMode = 'none';
    isDirty = true;
    saveToLocalStorage();
  }
  window.addEventListener('mouseup', handlePointerUp);
  window.addEventListener('pointerup', handlePointerUp);
  window.addEventListener('pointercancel', handlePointerUp);

  document.addEventListener('keydown', (e) => {
    // Ctrl+S ã§å³åº§ã«ä¿å­˜
    if ((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === 's') { 
        e.preventDefault(); 
        saveFile(true); // ä¿å­˜
        return;
    }
    if ((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === 'z') { e.preventDefault(); e.shiftKey ? redo() : undo(); }
    if ((e.key === 'Delete' || e.key === 'Backspace') && selectedId && document.activeElement.tagName !== 'TEXTAREA' && document.activeElement.tagName !== 'INPUT') {
        saveHistory(); deleteObject(selectedId); 
    }
  });

  function checkLoop(sourceId, targetId) {
    let curr = targetId, safety = 0;
    while(curr && safety < 1000) {
        if (curr === sourceId) return true;
        const next = groups.find(g => g.id === curr);
        if (!next || !next.next) break;
        curr = next.next; safety++;
    }
    return false;
  }
  function getColIndex(rawX) {
      let col = Math.floor((hanmen.clientWidth - rawX) / linePitch);
      return Math.max(0, col);
  }
  
  function calculateSnapPoint(rawX, rawY, type, obj = null) {
    let unitH;
    
    if (obj && obj.type === 'article') {
        unitH = obj.freeLayout ? (config.baseFontSize * SCALE_Y) : physicalHUnit;
    } else if (type === 'box') {
        unitH = isFreeCreationMode ? (config.baseFontSize * SCALE_Y) : physicalHUnit;
    } else {
        unitH = (type === 'correction' || type === 'image' || type === 'headline' || type === 'header') ? (config.baseFontSize * SCALE_Y) : physicalHUnit;
    }
    
    let snY = Math.round(rawY / unitH) * unitH; if (snY < 0) snY = 0;
    let col = getColIndex(rawX);
    let snX = hanmen.clientWidth - (col * linePitch) - config.baseFontSize;
    return { x: snX, y: snY };
  }

  function addGroup(type, x, y, w, h) {
    let danCount = Math.max(1, Math.round((h + physicalHGap) / physicalHUnit));
    const id = Date.now().toString();
    let newGroup = { id, x, y, w, danCount, nudgeX: 0, nudgeY: 0 };
    
    if (type === 'box') {
        newGroup.type = 'article'; newGroup.text = "è¨˜äº‹ã‚’å…¥åŠ›ã€‚"; newGroup.next = null; newGroup.displayText = [];
        newGroup.freeLayout = isFreeCreationMode; 
        if (newGroup.freeLayout) newGroup.h = h; 
    } else if (type === 'headline') {
        newGroup.type = 'headline'; newGroup.text = "è¦‹å‡ºã—";
        newGroup.h = h; 
        newGroup.fontFamily = '"Noto Sans JP", sans-serif'; newGroup.fontWeight = '700'; newGroup.isInverted = true;
        newGroup.padLong = 0; newGroup.padShort = 0;
    } else if (type === 'header') {
        newGroup.type = 'header'; newGroup.h = h; 
        newGroup.text = "ç©ºæƒ³æ–°è"; 
        newGroup.fontFamily = '"Shippori Mincho", serif'; 
        newGroup.pattern = "pat-lines"; 
        newGroup.publisher = "ç©ºæƒ³æ–°èç¤¾";
        newGroup.address = "ç©ºæƒ³éƒ½å¸‚ãƒ»è¥¿ãƒ–ãƒ­ãƒƒã‚¯221B"; 
        newGroup.contact = "000-0000-0000"; 
        newGroup.issue = "ç¬¬00001å·";
        newGroup.infoFont = '"Noto Sans JP", sans-serif';
        newGroup.infoSize = 12; 
        
        newGroup.isTitleInverted = false;
        // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã§è¢‹æ–‡å­—ã‚’å°‘ã—ã¤ã‘ã‚‹
        newGroup.titleStrokeWidth = 4;

        newGroup.titleNudgeX = 0; newGroup.titleNudgeY = 0;
        newGroup.titlePadV = 10; newGroup.titlePadH = 5;
        newGroup.borderOut = 4; newGroup.borderIn = 1;
    } else if (type === 'correction') {
        newGroup.type = 'correction'; newGroup.h = h; newGroup.text = ""; 
    } else if (type === 'vline') {
        newGroup.type = 'vline'; newGroup.lineWidth = 2; newGroup.text = "";
    } else if (type === 'image') {
        newGroup.type = 'image'; newGroup.h = h; newGroup.text = "ã‚­ãƒ£ãƒ—ã‚·ãƒ§ãƒ³"; 
        newGroup.captionPos = 'bottom'; newGroup.imageSrc = null; newGroup.originalSrc = null;
        newGroup.fontFamily = config.fontFamily;
        newGroup.colorMode = 'color';
        newGroup.inkContrast = 1.0;
        newGroup.inkBrightness = 0.0;
    }
    groups.push(newGroup); renderGroups(); selectObject(id);
    saveToLocalStorage();
  }
  function deleteObject(id) {
    groups = groups.filter(g => g.id !== id);
    groups.forEach(g => { if(g.next === id) g.next = null; });
    renderGroups(); 
    deselectAll();
    saveToLocalStorage();
  }
  
  function selectObject(id) {
    deselectAll(); selectedId = id; 
    const el = document.querySelector(`.article-group[data-id="${id}"]`);
    if (el) el.classList.add('selected');
    const g = groups.find(item => item.id === id);
    if(g) {
       // æ¥ç¶šæ¸ˆã¿è¨˜äº‹ã¯ã‚¯ãƒªãƒƒã‚¯æ™‚ã«ãƒªãƒ³ã‚¯ã‚’è§£é™¤
       if (g.type === 'headline') {
         switchPanel('panel-headline');
         document.getElementById('hl-font').value = g.fontFamily;
         document.getElementById('hl-weight').value = g.fontWeight;
         document.getElementById('hl-inverted').checked = (g.isInverted !== false);
         document.getElementById('hl-pad-long').value = g.padLong || 0; document.getElementById('val-hl-pad-long').innerText = g.padLong || 0;
         document.getElementById('hl-pad-short').value = g.padShort || 0; document.getElementById('val-hl-pad-short').innerText = g.padShort || 0;
       } else if (g.type === 'header') {
         switchPanel('panel-header');
         document.getElementById('hdr-title').value = g.text;
         document.getElementById('hdr-font').value = g.fontFamily || config.fontFamily;
         
         document.getElementById('hdr-publisher').value = g.publisher || "";
         document.getElementById('hdr-address').value = g.address || "";
         document.getElementById('hdr-contact').value = g.contact || "";
         document.getElementById('hdr-issue').value = g.issue;
         
         document.getElementById('hdr-info-font').value = g.infoFont || '"Noto Sans JP", sans-serif';
         document.getElementById('hdr-info-size').value = g.infoSize || 12;

         document.getElementById('hdr-text-inverted').checked = (g.isTitleInverted === true);
         document.getElementById('hdr-text-stroke').value = g.titleStrokeWidth || 0;

         document.getElementById('hdr-pad-v').value = g.titlePadV || 10;
         document.getElementById('hdr-pad-h').value = g.titlePadH || 5;
         document.getElementById('hdr-border-out').value = g.borderOut !== undefined ? g.borderOut : 4;
         document.getElementById('hdr-border-in').value = g.borderIn !== undefined ? g.borderIn : 1;
       } else if (g.type === 'correction') { switchPanel('panel-correction');
       } else if (g.type === 'vline') {
         switchPanel('panel-vline');
         document.getElementById('vl-width').value = g.lineWidth || 2; document.getElementById('val-vl-width').innerText = g.lineWidth || 2;
       } else if (g.type === 'image') {
         switchPanel('panel-image');
         document.getElementById('img-cap-pos').value = g.captionPos || 'bottom';
         document.getElementById('img-font').value = g.fontFamily || config.fontFamily;
         document.getElementById('img-color-mode').value = g.colorMode || 'color';
         
         const inkArea = document.getElementById('ink-adjust-area');
         if(g.colorMode === 'ink') {
             inkArea.style.display = 'block';
             document.getElementById('img-contrast').value = g.inkContrast ?? 1.0;
             document.getElementById('img-brightness').value = g.inkBrightness ?? 0.0;
             document.getElementById('val-img-contrast').innerText = (g.inkContrast ?? 1.0).toFixed(1);
             document.getElementById('val-img-brightness').innerText = (g.inkBrightness ?? 0.0).toFixed(1);
         } else {
             inkArea.style.display = 'none';
         }
         // ã‚µã‚¤ã‚ºè¡¨ç¤ºã‚’æ›´æ–°
         const sizeEl = document.getElementById('img-size-display');
         if (sizeEl) {
             const w = Math.round(g.w || 0);
             const h = Math.round(g.h || 0);
             sizeEl.textContent = `${w}px Ã— ${h}px`;
         }

       } else {
         switchPanel('panel-article'); 
         updateOverflowStatus(g);
         document.getElementById('art-free-layout').checked = (g.freeLayout === true);
       }
    }
  }
  function deselectAll() {
    selectedId = null;
    document.querySelectorAll('.selected').forEach(el => el.classList.remove('selected'));
    switchPanel('panel-global');
    closeInlineEditor();
  }
  
  function updateOverflowStatus(group) {
      if(group.overflowCount > 0) overflowStatusText.innerHTML = `<span class="overflow-warning">ã‚ãµã‚Œ: ${group.overflowCount} æ–‡å­—</span>`;
      else overflowStatusText.innerHTML = `<span class="overflow-ok">OK (åã¾ã£ã¦ã„ã¾ã™)</span>`;
  }

  function saveHistory() {
    undoStack.push({ groups: JSON.parse(JSON.stringify(groups)) });
    if (undoStack.length > HISTORY_LIMIT) undoStack.shift(); redoStack = [];
    isDirty = true;
    saveToLocalStorage();
  }
  function undo() {
    if (undoStack.length === 0) return;
    redoStack.push({ groups: JSON.parse(JSON.stringify(groups)) });
    groups = undoStack.pop().groups; renderGroups(); deselectAll();
    isDirty = true;
    saveToLocalStorage();
  }
  function redo() {
    if (redoStack.length === 0) return;
    undoStack.push({ groups: JSON.parse(JSON.stringify(groups)) });
    groups = redoStack.pop().groups; renderGroups(); deselectAll();
    isDirty = true;
    saveToLocalStorage();
  }

  // --- ã‚¨ãƒ‡ã‚£ã‚¿é–¢é€£ ---
  function findRootGroup(group) {
    if (group.type === 'headline' || group.type === 'image' || group.type === 'header') return group;
    let curr = group, depth = 0;
    while(depth < 100) {
        const parent = groups.find(p => p.next === curr.id);
        if (!parent) return curr;
        curr = parent; depth++;
    }
    return curr;
  }
  
  function openEditorHandler(g) {
      if (document.body.classList.contains('preview-mode') || currentTool === 'hand') return;
      if (g.type === 'article') {
          openInlineEditor(g);
      } else {
          openOverlayEditor(g);
      }
  }

  function openInlineEditor(group) {
    closeInlineEditor(); saveHistory(); 
    const el = document.querySelector(`.article-group[data-id="${group.id}"]`);
    if (!el) return;
    const editor = document.createElement('textarea'); editor.className = 'inline-editor';
    editor.value = group.text;
    editor.dataset.editingId = group.id;
    
    editor.style.left = group.x + 'px'; editor.style.top = group.y + 'px';
    editor.style.width = group.w + 'px'; 
    const originalHeight = (el.offsetHeight / SCALE_Y) + 20; 
    editor.style.height = originalHeight + 'px';
    editor.style.transform = `translate(${config.nudgeX}px, ${config.nudgeY}px) scaleY(${SCALE_Y})`;
    
    editor.onblur = function() { closeInlineEditor(); }; 
    editor.onkeydown = (e) => { if (e.key === 'Escape') closeInlineEditor(); };
    hanmen.appendChild(editor); editor.focus();
  }

  function closeInlineEditor() {
    const existing = document.querySelector('.inline-editor');
    if (existing) {
        const id = existing.dataset.editingId;
        if (id) {
            const g = groups.find(i => i.id === id);
            if (g) {
                g.text = existing.value;
                renderGroups(); 
            }
        }
        existing.onblur = null; 
        if (existing.parentNode) existing.parentNode.removeChild(existing);
        saveToLocalStorage();
    }
  }

  function openOverlayEditor(group) {
    editingGroupId = group.id;
    const overlay = document.getElementById('editor-overlay');
    const ta = document.getElementById('editor-textarea');
    ta.value = group.text;
    overlay.style.display = 'flex'; ta.focus();
  }
  function saveOverlayEditor() {
    if (editingGroupId) {
       saveHistory();
       const g = groups.find(i => i.id === editingGroupId);
       if (g) { 
           g.text = document.getElementById('editor-textarea').value; 
           renderGroups(); 
       }
    }
    closeOverlayEditor();
  }
  function closeOverlayEditor() { document.getElementById('editor-overlay').style.display = 'none'; editingGroupId = null; }

  // --- ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚° ---
  
  function hexToLuma(hex) {
      const c = hex.substring(1);
      const rgb = parseInt(c, 16);
      const r = (rgb >> 16) & 0xff;
      const g = (rgb >>  8) & 0xff;
      const b = (rgb >>  0) & 0xff;
      return 0.299 * r + 0.587 * g + 0.114 * b;
  }

  function generateFilter(id, paperColor, inkColor, contrast, brightness) {
      const lumaPaper = hexToLuma(paperColor);
      const lumaInk = hexToLuma(inkColor);
      const isReverse = lumaInk > lumaPaper; 
      const baseSlope = 1.8 * contrast;
      const baseIntercept = -0.1 - (brightness * 0.5); 
      let matrixValues = isReverse 
          ? `0 0 0 0 0  0 0 0 0 0  0 0 0 0 0  0.2126 0.7152 0.0722 0 0`
          : `0 0 0 0 0  0 0 0 0 0  0 0 0 0 0  -0.2126 -0.7152 -0.0722 0 1`;

      return `
      <svg><filter id="filter-${id}">
        <feColorMatrix type="matrix" values="${matrixValues}" result="alpha-map" />
        <feComponentTransfer in="alpha-map" result="contrast-alpha">
          <feFuncA type="linear" slope="${baseSlope}" intercept="${baseIntercept}" /> 
        </feComponentTransfer>
        <feFlood flood-color="${inkColor}" result="ink-color" />
        <feComposite in="ink-color" in2="contrast-alpha" operator="in" />
      </filter></svg>`;
  }

  function renderGroups() {
    document.querySelectorAll('.article-group').forEach(e => e.remove());
    linkLayer.innerHTML = '<path id="temp-link-line" d=""></path>';
    const container = document.getElementById('svg-filters-container');
    const svg = container.querySelector('svg');
    if (svg) {
        const filters = svg.querySelectorAll('filter');
        filters.forEach(f => f.remove());
    }
    
    reflowText();

    groups.forEach(g => {
      // ä»¥å‰ã¯æ›¸ãå‡ºã—æ™‚ã«flattenã—ã¦ã„ãŸãŒã€CSS scaleYã§æ‰å¹³ã«ã—ã¦ã„ã‚‹ã®ã§ã€
      // flattenã™ã‚‹ã¨ç¸¦ã«ä¼¸ã³ã¦ã—ã¾ã„æç”»é ˜åŸŸã‹ã‚‰ã¯ã¿å‡ºã™åŸå› ã¨ãªã‚‹ãŸã‚å»ƒæ­¢ã€‚
      // ç¾åœ¨ã¯å¸¸ã«è¦‹ãŸç›®é€šã‚Šã®scaleYã‚’ç¶­æŒã™ã‚‹ã€‚
      const flatten = false;
      const el = document.createElement('div');
      el.className = 'article-group type-' + g.type; el.dataset.id = g.id;
      el.style.left = g.x + 'px'; el.style.top = g.y + 'px'; el.style.width = g.w + 'px';
      
      let totalH;
      if (g.type === 'correction' || g.type === 'image' || g.type === 'headline' || g.type === 'header' || (g.type === 'article' && g.freeLayout)) {
          totalH = g.h;
      } else {
          totalH = (g.danCount * physicalHDan) + ((g.danCount - 1) * physicalHGap);
      }
      
      el.style.height = totalH + 'px';
      if(selectedId === g.id) el.classList.add('selected');

      const handle = document.createElement('div'); handle.className = 'resize-handle'; el.appendChild(handle);
      const tr = `translate(${g.nudgeX || 0}px, ${g.nudgeY || 0}px)`;

      // ã‚³ãƒ³ãƒ†ãƒ³ãƒ„æç”»åˆ†å²
      if (g.type === 'headline') {
          const isVertical = (totalH > g.w);
          const wrapper = document.createElement('div'); wrapper.className = 'headline-wrapper';
          const isInverted = (g.isInverted !== false); 
          wrapper.style.backgroundColor = isInverted ? config.textColor : config.paperColor;
          wrapper.style.boxShadow = `calc(var(--line-gap)*-1) 0 0 0 ${config.paperColor}, var(--line-gap) 0 0 0 ${config.paperColor}`;
          
          const content = document.createElement('div');
          content.className = 'headline-inner ' + (isVertical ? 'headline-v' : 'headline-h');
          let htmlText = g.text.replace(/([0-9]{1,2})/g, '<span class="tcy">$1</span>').replace(/\{\{(.*?)\}\}/g, '<span class="tcy">$1</span>');
          content.innerHTML = htmlText;
          content.style.fontFamily = g.fontFamily; content.style.fontWeight = g.fontWeight;
          content.style.color = isInverted ? config.paperColor : config.textColor;

          const padLong = g.padLong || 0; const padShort = g.padShort || 0;
          const availW = g.w - (isVertical ? (padShort * 2) : (padLong * 2));
          const availH = totalH - (isVertical ? (padLong * 2) : (padShort * 2));
          
          if (availW > 0 && availH > 0) {
             const shortSide = isVertical ? availW : availH;
             const longSide = isVertical ? availH : availW;
             content.style.fontSize = shortSide + 'px';
             
             hlMeasureBox.innerHTML = htmlText; 
             hlMeasureBox.style.fontFamily = g.fontFamily; hlMeasureBox.style.fontWeight = g.fontWeight;
             hlMeasureBox.style.fontSize = shortSide + 'px';
             const actualLen = hlMeasureBox.offsetWidth;
             let scaleFactor = (actualLen > 0) ? (longSide / actualLen) : 1.0;
             let baseTransform = isVertical ? `scale(1, ${scaleFactor})` : `scale(${scaleFactor}, 1)`;
             
             if (isVertical) { content.style.right = padShort + 'px'; content.style.top = padLong + 'px'; }
             else { content.style.left = padLong + 'px'; content.style.top = padShort + 'px'; }
             content.style.transform = `${baseTransform} ${tr}`;
          } else { content.style.display = 'none'; }
          wrapper.appendChild(content); el.appendChild(wrapper);

      } else if (g.type === 'header') {
          const box = document.createElement('div'); box.className = 'header-container';
          box.style.transform = tr;

          const titleBoxOuter = document.createElement('div'); titleBoxOuter.className = 'header-title-box-outer';
          titleBoxOuter.style.borderWidth = (g.borderOut !== undefined ? g.borderOut : 4) + 'px';
          titleBoxOuter.style.borderColor = config.textColor;
          titleBoxOuter.style.backgroundColor = config.paperColor;

          const titleBoxInner = document.createElement('div'); titleBoxInner.className = 'header-title-box-inner';
          titleBoxInner.style.borderWidth = (g.borderIn !== undefined ? g.borderIn : 1) + 'px';
          titleBoxInner.style.borderColor = config.textColor;
          titleBoxInner.style.color = config.textColor; // ãƒ‘ã‚¿ãƒ¼ãƒ³ç”¨ã«è‰²ã‚’ç¶™æ‰¿

          // åœ°ç´‹ãƒ‘ã‚¿ãƒ¼ãƒ³
          if (true) {
              const bgSvg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
              bgSvg.setAttribute("class", "header-bg-pattern");
              const patId = `pat-lines-${g.id}`;
              bgSvg.innerHTML = `
                <defs>
                  <pattern id="${patId}" x="0" y="0" width="10" height="4" patternUnits="userSpaceOnUse">
                    <line x1="0" y1="2" x2="10" y2="2" stroke="${config.textColor}" stroke-width="0.5" stroke-linecap="round" />
                  </pattern>
                </defs>
                <rect width="100%" height="100%" fill="url(#${patId})" />
              `;
              titleBoxInner.appendChild(bgSvg);
          }

          const titleText = document.createElement('div'); titleText.className = 'header-title-text';
          titleText.innerText = g.text;
          titleText.style.fontFamily = g.fontFamily || config.fontFamily;
          
          // è‰²è¨­å®š (åè»¢ãƒ­ã‚¸ãƒƒã‚¯)
          const isTitleInverted = g.isTitleInverted === true;
          const strokeW = g.titleStrokeWidth || 0;

          titleText.style.color = isTitleInverted ? config.paperColor : config.textColor;
          if (strokeW > 0) {
              titleText.style.webkitTextStrokeWidth = strokeW + 'px';
              titleText.style.webkitTextStrokeColor = isTitleInverted ? config.textColor : config.paperColor;
              // ãƒ•ãƒæ–‡å­—ã®è¨­å®š (ãƒ•ãƒã®ä¸Šã«æ–‡å­—ã‚’æç”»)
              titleText.style.paintOrder = "stroke fill"; 
          }
          
          const borderSpace = (g.borderOut || 4) + 4 + (g.borderIn || 1);
          const padV = g.titlePadV || 10;
          const padH = g.titlePadH || 5;
          
          // DOMã«è¿½åŠ ã—ã¦infoAreaã®é«˜ã•ã‚’ç¢ºå®šã•ã›ã‚‹
          titleBoxInner.appendChild(titleText);
          titleBoxOuter.appendChild(titleBoxInner);
          box.appendChild(titleBoxOuter);

          const infoArea = document.createElement('div'); infoArea.className = 'header-info-area';
          infoArea.style.borderColor = config.textColor;
          infoArea.style.fontFamily = g.infoFont || '"Noto Sans JP", sans-serif';
          infoArea.style.color = config.textColor;
          const infoFontSize = g.infoSize || 12;
          infoArea.style.fontSize = infoFontSize + 'pt';
          
          let items = [];
          if(g.publisher) items.push(g.publisher);
          if(g.address) items.push(g.address);
          if(g.contact) items.push(g.contact);
          if(g.issue) items.push(g.issue);
          
          infoArea.innerHTML = items.map(t => `<span class="header-info-item">${t}</span>`).join("");
          
          box.appendChild(infoArea);
          el.appendChild(box);
          
          // ç°¡æ˜“è¨ˆç®— (ãƒ«ãƒ¼ãƒ—å†…ã§ã®è¨ˆæ¸¬ã¯æ­£ç¢ºã§ã¯ãªã„ãŒã€é«˜ã•ç¢ºä¿ã®ãŸã‚)
          const estimatedInfoH = items.length * (infoFontSize * 1.33 * 1.2 + 2) + 8; // æ¦‚ç®—
          
          const availW = Math.max(10, g.w - (borderSpace * 2) - (padH * 2));
          const availH = Math.max(10, totalH - estimatedInfoH - (borderSpace * 2) - (padV * 2));
          
          const fontSize = availW; 
          titleText.style.fontSize = fontSize + 'px';
          
          const textLen = g.text.length * fontSize;
          let scaleY = (textLen > 0) ? (availH / textLen) : 1.0;

          titleText.style.transform = `translate(${g.titleNudgeX || 0}px, ${g.titleNudgeY || 0}px) scale(1, ${scaleY})`;

      } else if (g.type === 'correction') {
          const box = document.createElement('div'); box.className = 'correction-box';
          const inner = document.createElement('div'); inner.className = 'correction-inner';
          inner.style.backgroundColor = config.paperColor;
          inner.style.boxShadow = `calc(var(--line-gap)*-1) 0 0 0 ${config.paperColor}, var(--line-gap) 0 0 0 ${config.paperColor}`;
          inner.style.transform = tr;
          box.appendChild(inner); el.appendChild(box);

      } else if (g.type === 'vline') {
          const box = document.createElement('div'); box.className = 'vline-box';
          const innerBg = document.createElement('div'); 
          innerBg.style.width = '100%'; innerBg.style.height = '100%';
          innerBg.style.display = 'flex'; innerBg.style.justifyContent = 'center'; innerBg.style.alignItems = 'center';
          innerBg.style.backgroundColor = config.paperColor;
          innerBg.style.boxShadow = `calc(var(--line-gap)*-1) 0 0 0 ${config.paperColor}, var(--line-gap) 0 0 0 ${config.paperColor}`;
          const line = document.createElement('div'); line.className = 'vline-inner';
          line.style.width = (g.lineWidth || 2) + 'px'; line.style.backgroundColor = config.textColor;
          innerBg.appendChild(line); innerBg.style.transform = tr;
          box.appendChild(innerBg); el.appendChild(box);

      } else if (g.type === 'image') {
          const box = document.createElement('div'); box.className = 'image-box';
          
          box.style.overflow = 'visible';
          box.style.backgroundColor = config.paperColor;
          box.style.boxShadow = `-${config.lineGap}px 0 0 0 ${config.paperColor}, ${config.lineGap}px 0 0 0 ${config.paperColor}`;

          const pos = g.captionPos || 'bottom';
          if (pos === 'top') { box.style.flexDirection = 'column'; }
          else if (pos === 'bottom') { box.style.flexDirection = 'column'; }
          else if (pos === 'left') { box.style.flexDirection = 'row'; }
          else if (pos === 'right') { box.style.flexDirection = 'row'; }

      const imgContainer = document.createElement('div'); imgContainer.className = 'image-container';
      
      if (g.imageSrc) {
          const img = document.createElement('img');
          img.className = 'image-content';
          if (g.colorMode === 'ink') {
              img.src = g.imageInkSrc || g.imageSrc;
              if (!g.imageInkSrc) convertImageToInk(g);
          } else {
              img.src = g.imageSrc;
          }
          imgContainer.appendChild(img);
      } else {
              imgContainer.innerText = "No Image";
          }

          const caption = document.createElement('div'); caption.className = 'image-caption';
          caption.innerText = g.text;
          caption.style.fontFamily = g.fontFamily || config.fontFamily;
          
          if (pos === 'left' || pos === 'right') caption.classList.add('caption-v');
          else caption.classList.add('caption-h');

          if (pos === 'none') {
              box.appendChild(imgContainer);
          } else if (pos === 'top') {
              box.appendChild(caption); box.appendChild(imgContainer);
          } else if (pos === 'bottom') {
              box.appendChild(imgContainer); box.appendChild(caption);
          } else if (pos === 'left') {
              box.appendChild(caption); box.appendChild(imgContainer);
          } else if (pos === 'right') {
              box.appendChild(imgContainer); box.appendChild(caption);
          }
          
          const wrapper = document.createElement('div');
          wrapper.style.width = '100%'; wrapper.style.height = (flatten ? totalH : (totalH / SCALE_Y)) + 'px';
          if (!flatten) {
              wrapper.style.transformOrigin = 'top right';
              wrapper.style.transform = `scaleY(${SCALE_Y})`;
              box.style.transform = tr + ` scaleY(${1/SCALE_Y})`;
          } else {
              wrapper.style.transform = 'none';
              box.style.transform = tr;
          }
          
          wrapper.appendChild(box);
          el.appendChild(wrapper);

      } else { // Article
          if(g.overflowCount > 0) el.classList.add('has-overflow');
          
          if (g.freeLayout) {
              el.style.backgroundColor = config.paperColor;
              el.style.boxShadow = `-${config.lineGap}px 0 0 0 ${config.paperColor}, ${config.lineGap}px 0 0 0 ${config.paperColor}`;
          }

          const wrapper = document.createElement('div'); wrapper.className = 'article-transform-wrapper';
          wrapper.style.width = '100%';
          wrapper.style.height = flatten ? totalH + 'px' : (totalH / SCALE_Y) + 'px';
          if (flatten) {
              wrapper.style.transform = `translate(${g.nudgeX || 0}px, ${g.nudgeY || 0}px)`;
          } else {
              wrapper.style.transformOrigin = 'top right';
              wrapper.style.transform = `translate(${g.nudgeX || 0}px, ${g.nudgeY || 0}px) scaleY(${SCALE_Y})`;
          }
          el.appendChild(wrapper);

          let loopCount = (g.freeLayout) ? 1 : g.danCount;
          let segH = (g.freeLayout) ? (g.h / SCALE_Y) : baseHDan;
          if (flatten) segH = (g.freeLayout) ? g.h : physicalHDan;

          for (let i = 0; i < loopCount; i++) {
            if (i > 0) {
              const spacer = document.createElement('div'); spacer.className = 'spacer';
              spacer.style.height = flatten ? (g.freeLayout ? g.h : physicalHGap) + 'px' : '';
              wrapper.appendChild(spacer);
            }
            const seg = document.createElement('div'); seg.className = 'segment';
            seg.style.height = segH + 'px'; 
            seg.innerHTML = (g.displayText && g.displayText[i]) ? g.displayText[i] : "";
            wrapper.appendChild(seg);
          }
          const isConnected = groups.some(parent => parent.next === g.id);
          const inPort = document.createElement('div'); inPort.className = 'port port-in';
          if (isConnected) inPort.classList.add('connected');
          el.appendChild(inPort);
          const outPort = document.createElement('div'); outPort.className = 'port port-out';
          if (g.next) outPort.classList.add('linked'); el.appendChild(outPort);
          if (g.next) {
              const nextG = groups.find(grp => grp.id === g.next);
              if (nextG) drawLinkLine(g, nextG);
          }
      }
      el.ondblclick = (e) => { e.stopPropagation(); const root = findRootGroup(g); openEditorHandler(root); };
      hanmen.appendChild(el);
    });
  }

  function reflowText() {
    groups.forEach(g => { if (g.type === 'article') { g.displayText = []; g.overflowCount = 0; } });
    const roots = groups.filter(g => g.type === 'article' && !groups.some(other => other.next === g.id));
    
    roots.forEach(root => {
        let currentGroup = root; let formattedText = root.text;
        formattedText = formattedText.replace(/([0-9]+)/g, (match) => { return (match.length <= 2) ? "{{" + match + "}}" : match; });
        if (!formattedText.startsWith("\u3000")) formattedText = "\u3000" + formattedText;
        formattedText = formattedText.replace(/\n(?!\u3000)/g, "\n\u3000");
        let processedHTML = formattedText.replace(/\{\{(.*?)\}\}/g, '<span class="tcy">$1</span>').replace(/\n/g, '<br>');
        let remainingHTML = processedHTML;
        let chainGroups = []; 
        while (currentGroup) {
            chainGroups.push(currentGroup); if (remainingHTML.length === 0) break;
            
            // ãƒ•ãƒªãƒ¼ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆå¯¾å¿œ
            let loopCount = (currentGroup.freeLayout) ? 1 : currentGroup.danCount;
            const flattenLayout = false; // ç¸¦çµ„ã¿å´©ã‚Œé˜²æ­¢ã®ãŸã‚å¸¸ã«å¾“æ¥ã®é«˜ã•è¨ˆç®—ã‚’ä½¿ã†
            let currentSegHeight = (currentGroup.freeLayout && currentGroup.h) ? (currentGroup.h / SCALE_Y) : baseHDan;

            for (let i = 0; i < loopCount; i++) {
                if (remainingHTML.length === 0) break;
                const segWidth = currentGroup.w; const segHeight = currentSegHeight; 
                measureBox.style.width = segWidth + 'px'; measureBox.style.height = segHeight + 'px';
                measureBox.style.fontSize = config.baseFontSize + 'px';
                measureBox.style.lineHeight = (config.baseFontSize + config.lineGap) + 'px';
                measureBox.style.fontFamily = config.fontFamily;
                measureBox.style.fontWeight = config.fontWeight;
                measureBox.style.fontWeight = config.fontWeight;

                measureBox.innerHTML = remainingHTML;
                const tokens = remainingHTML.match(/(<[^>]+>|[^<])/g) || [];
                let fitCount = tokens.length;
                
                // Safariå¯¾ç­–: ã‚„ã‚„ç·©ã‚ã®è¨±å®¹ç¯„å›²ï¼ˆå³ã—ã™ãã‚‹ã¨1è¡Œæ¬ ã‘ã‚‹ãŸã‚ï¼‰
                const tolerance = Math.max(config.baseFontSize * 0.6, config.lineGap * 0.5);

                while (fitCount > 0) {
                    const tryHTML = tokens.slice(0, fitCount).join(''); measureBox.innerHTML = tryHTML;
                    const overW = measureBox.scrollWidth - measureBox.clientWidth;
                    const overH = measureBox.scrollHeight - measureBox.clientHeight;
                    if (overW <= tolerance && overH <= tolerance) {
                        currentGroup.displayText[i] = tryHTML; remainingHTML = tokens.slice(fitCount).join(''); break;
                    }
                    fitCount--;
                }
                if (fitCount === 0) remainingHTML = "";
            }
            currentGroup = currentGroup.next ? groups.find(g => g.id === currentGroup.next) : null;
        }
        if (remainingHTML.length > 0) {
            const tempDiv = document.createElement('div'); tempDiv.innerHTML = remainingHTML;
            const overflowLen = tempDiv.textContent.length;
            chainGroups.forEach(g => { g.overflowCount = overflowLen; });
        }
    });
  }

  function drawLinkLine(g1, g2) {
    const x1 = g1.x + (g1.w / 2); 
    const y1 = g1.y + ((g1.danCount * physicalHDan) + ((g1.danCount - 1) * physicalHGap)) + 5; 
    const x2 = g2.x + (g2.w / 2); const y2 = g2.y - 5; 
    const path = document.createElementNS("http://www.w3.org/2000/svg", "path");
    const d = `M ${x1} ${y1} C ${x1} ${y1+50}, ${x2} ${y2-50}, ${x2} ${y2}`;
    path.setAttribute("d", d); path.setAttribute("class", "link-line"); linkLayer.appendChild(path);
  }

  function registerServiceWorker() {
    if (!('serviceWorker' in navigator)) return;
    window.addEventListener('load', () => {
      navigator.serviceWorker.register('sw.js').catch((err) => console.warn('SW registration failed', err));
    });
  }

  init();
  registerServiceWorker();
</script>
</body>
</html>
