<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="theme-color" content="#111111">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black">
<link rel="manifest" href="manifest.webmanifest">
<link rel="icon" type="image/png" sizes="192x192" href="icons/icon-192.png">
<link rel="icon" type="image/png" sizes="512x512" href="icons/icon-512.png">
<link rel="apple-touch-icon" sizes="180x180" href="icons/apple-touch-icon-180.png">
<title>æ–°èä½œæˆãƒ„ãƒ¼ãƒ«</title>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<!-- Google Fonts ä¸€æ‹¬èª­ã¿è¾¼ã¿ -->
<link href="https://fonts.googleapis.com/css2?family=BIZ+UDMincho&family=Noto+Sans+JP:wght@400;700;900&family=Noto+Serif+JP:wght@400;700;900&family=Yuji+Syuku&display=block" rel="stylesheet">
<!-- ç”»åƒç”Ÿæˆç”¨ãƒ©ã‚¤ãƒ–ãƒ©ãƒª -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>

<style>
  :root {
    /* === åŸºæœ¬è¨­å®š === */
    --base-font-size: 24px; 
    --line-gap: 12px;
    --safe-top: env(safe-area-inset-top, 0px);
    --safe-right: env(safe-area-inset-right, 0px);
    --safe-bottom: env(safe-area-inset-bottom, 0px);
    --safe-left: env(safe-area-inset-left, 0px);
    --safe-top-init: var(--safe-top);
    --safe-right-init: var(--safe-right);
    --safe-bottom-init: var(--safe-bottom);
    --safe-left-init: var(--safe-left);
    --initial-vh: 100vh;
    --initial-safe-top: var(--safe-top);
    --initial-safe-bottom: var(--safe-bottom);
    --initial-vh: 100vh;
    
    /* ç”¨ç´™ã‚µã‚¤ã‚º (JSã§åˆ¶å¾¡) */
    --paper-w: 297mm;
    --paper-h: 420mm;

    /* ãƒãƒ¼ã‚¸ãƒ³ */
    --m-top: 30mm; --m-bottom: 30mm; --m-inner: 20mm; --m-outer: 20mm;
    
    /* å¾®èª¿æ•´ */
    --nudge-x: 0px; --nudge-y: 0px;
    --font-family: "BIZ UDMincho", serif;
    --font-weight: 400;
    --scale-y: 0.85; /* æ–°
    èç‰¹æœ‰ã®æ‰å¹³ç‡ */
    --glyph-scale: 1.0; 

    /* è‰²è¨­å®š */
    --text-color: #111111; /* ã‚¤ãƒ³ã‚¯ã®è‰² */
    --paper-color: #fcfcfc; /* ç´™ã®è‰² */
    --border-width: 1px;
    --divider-width: 1px;
    --grid-color: #dddddd;
    
    /* ã‚ãµã‚Œè­¦å‘Šè‰² */
    --overflow-color: #cd5c5c; 
    
    /* UIè‰²ï¼ˆãƒ¢ãƒã‚¯ãƒ­ï¼‰ */
    --ui-bg: #ffffff;
    --ui-border: #dddddd;
    --ui-text: #333333;
    --ui-hover: #f5f5f5;
    --ui-active: #000000;
    --ui-active-text: #ffffff;
  }

  html {
    height: 100%; background-color: #f0f0f0;
  }
  body {
    background-color: #f0f0f0; margin: 0; padding: 0;
    font-family: "Noto Sans JP", sans-serif;
    min-height: 100vh; width: 100vw; height: var(--initial-vh); overflow: hidden;
    user-select: none; touch-action: none; 
  }

  /* ãƒãƒ³ãƒ‰ãƒ¢ãƒ¼ãƒ‰æ™‚ã®é€é */
  body.tool-hand .article-group,
  body.tool-hand .resize-handle,
  body.tool-hand .port {
    pointer-events: none !important;
  }

  /* --- å·¦ã‚µã‚¤ãƒ‰ãƒãƒ¼ (ãƒ„ãƒ¼ãƒ«ãƒãƒ¼) --- */
  .toolbar-container {
    position: fixed; top: var(--safe-top); bottom: var(--safe-bottom);
    left: var(--safe-left); width: 80px; 
    z-index: 2000;
    background: var(--ui-bg);
    border-right: 1px solid var(--ui-border);
    display: flex; flex-direction: column;
    padding: 20px 0;
    box-sizing: border-box;
    overflow-y: auto; /* å°ã•ã„ç”»é¢ã§ã‚‚ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«å¯èƒ½ã« */
  }

  #launch-screen {
    position: fixed;
    inset: 0;
    background: linear-gradient(180deg, #080808, #151515);
    color: #f7f7f7;
    display: flex;
    justify-content: center;
    align-items: center;
    z-index: 4000;
    font-family: "Noto Sans JP", sans-serif;
    text-align: center;
    padding: 20px;
    transition: opacity 0.4s ease;
  }
  #launch-screen.loaded {
    opacity: 0;
    pointer-events: none;
  }
  #launch-screen .content {
    max-width: 280px;
  }
  #launch-screen h1 {
    margin: 0; font-size: 22px; letter-spacing: 0.4px;
  }
  #launch-screen .subtitle {
    margin-top: 12px;
    font-size: 14px;
    color: #c6c6c6;
  }
  #launch-screen .launch-spinner {
    margin: 18px auto 0;
    width: 40px; height: 40px;
    border-radius: 50%;
    border: 4px solid rgba(255,255,255,0.15);
    border-top-color: #ffcc33;
    animation: spin 1s linear infinite;
  }
  @keyframes spin {
    to { transform: rotate(360deg); }
  }

  .tool-group {
    display: flex; flex-direction: column; 
    border-bottom: 1px solid var(--ui-border);
    padding: 10px 0;
  }
  .tool-group:last-child {
    border-bottom: none;
    margin-top: auto; /* æœ€å¾Œã®ã‚°ãƒ«ãƒ¼ãƒ—ã‚’ä¸‹ã«é…ç½® */
  }
  
  .tool-btn {
    width: 100%; height: 64px; 
    border: none; background: transparent; 
    color: var(--ui-text);
    cursor: pointer; 
    display: flex; flex-direction: column;
    justify-content: center; align-items: center;
    transition: all 0.15s;
    position: relative;
    gap: 4px;
  }
  .tool-btn:hover { 
    background: var(--ui-hover); 
  }
  .tool-btn.active { 
    background: var(--ui-active); 
    color: var(--ui-active-text); 
  }
  .tool-btn.active .duotone-icon {
    fill: var(--ui-active-text);
  }
  
  .tool-icon {
    width: 24px; height: 24px;
    display: flex; justify-content: center; align-items: center;
  }
  .tool-label {
    font-size: 10px;
    font-weight: 500;
    letter-spacing: 0.5px;
  }

  /* ã‚¢ã‚¤ã‚³ãƒ³ã‚¹ã‚¿ã‚¤ãƒ« */
  .duotone-icon {
    width: 24px; height: 24px;
    fill: var(--ui-text);
  }
  .duotone-icon .secondary {
    opacity: 0.4;
  }
  
  /* ä¿å­˜å®Œäº†é€šçŸ¥ */
  #auto-save-indicator {
    position: fixed; bottom: 20px; left: 50%;
    transform: translateX(-50%);
    background: var(--ui-active); color: var(--ui-active-text);
    padding: 8px 16px; border-radius: 4px; font-size: 12px;
    pointer-events: none; opacity: 0; transition: opacity 0.5s; z-index: 3000;
    border: 1px solid var(--ui-border);
  }

  /* ãƒ•ã‚¡ã‚¤ãƒ«ãƒ»ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆãƒ¡ãƒ‹ãƒ¥ãƒ¼ */
  .menu-overlay {
      position: fixed; top: 0; left: 0; width: 100vw; height: 100vh;
      background: rgba(0,0,0,0.3); z-index: 3000; display: none;
      justify-content: center; align-items: center;
  }
  .menu-panel {
      background: var(--ui-bg); padding: 24px; border-radius: 0;
      border: 1px solid var(--ui-border);
      width: 320px; color: var(--ui-text);
      display: flex; flex-direction: column; gap: 12px;
  }
  .menu-header { 
    font-weight: bold; font-size: 16px;
    color: var(--ui-text); 
    border-bottom: 1px solid var(--ui-border); 
    padding-bottom: 12px; margin-bottom: 8px;
  }
  .menu-item {
      padding: 12px; background: var(--ui-bg); 
      border: 1px solid var(--ui-border);
      cursor: pointer; 
      transition: background 0.15s; 
      display: flex; align-items: center; gap: 10px;
      font-size: 14px;
  }
  .menu-item:hover { background: var(--ui-hover); }
  .menu-item span { flex: 1; }
  
  /* --- å³ã‚µã‚¤ãƒ‰ãƒãƒ¼ (è¨­å®šãƒ‘ãƒãƒ«) --- */
  .settings-panel {
    position: fixed; right: var(--safe-right); top: var(--safe-top); bottom: var(--safe-bottom);
    width: 320px;
    z-index: 2000;
    background: var(--ui-bg); color: var(--ui-text); 
    border-left: 1px solid var(--ui-border);
    font-size: 13px; 
    overflow-y: auto; overflow-x: hidden;
    box-sizing: border-box;
    padding: 20px;
  }

  .ui-header { 
    font-weight: bold; 
    font-size: 13px;
    margin-bottom: 12px; 
    color: var(--ui-text); 
    border-bottom: 1px solid var(--ui-border); 
    padding-bottom: 8px; 
    margin-top: 24px; 
  }
  .ui-header:first-child { margin-top: 0; }
  
  .ui-row { 
    margin-bottom: 12px; 
    display: flex; 
    justify-content: space-between; 
    align-items: center; 
    gap: 8px; 
    width: 100%; 
    box-sizing: border-box;
  }
  .ui-row label { 
    color: var(--ui-text); 
    min-width: 70px; 
    white-space: nowrap;
    font-size: 12px;
  }
  .ui-row input[type="range"] { 
    flex: 1; cursor: pointer; margin: 0 8px; min-width: 0; 
  }
  .ui-row input[type="text"], 
  .ui-row input[type="number"] { 
    flex: 1; 
    background: var(--ui-bg); 
    color: var(--ui-text); 
    border: 1px solid var(--ui-border); 
    padding: 6px 8px; 
    border-radius: 0; 
    min-width: 0;
    font-size: 12px;
  }
  .ui-row input[type="color"] { 
    width: 40px; height: 28px; 
    border: 1px solid var(--ui-border); 
    cursor: pointer; padding: 0; 
    background: none;
  }
  .ui-row input[type="checkbox"] { 
    cursor: pointer; 
    transform: scale(1.3); 
  }
  .ui-row select { 
    flex: 1; 
    background: var(--ui-bg); 
    color: var(--ui-text); 
    border: 1px solid var(--ui-border); 
    padding: 6px 8px; 
    border-radius: 0; 
    min-width: 0; 
    text-overflow: ellipsis;
    font-size: 12px;
  }
  .val {
    width: 50px;
    text-align: right;
    color: var(--ui-text);
    font-weight: 600;
    white-space: nowrap;
    font-size: 12px;
    background: var(--ui-panel-bg);
    border: 1px solid var(--ui-border);
    border-radius: 3px;
    padding: 2px 4px;
  }
  .val:focus {
    outline: 2px solid var(--ui-accent);
    outline-offset: 0;
  }
  .calc-info { 
    font-size: 11px; 
    color: #666; 
    text-align: right; 
    margin-bottom: 12px; 
    line-height: 1.4;
  }
  
  .btn-small {
      background: var(--ui-bg); 
      color: var(--ui-text); 
      border: 1px solid var(--ui-border); 
      padding: 4px 12px; 
      cursor: pointer; 
      border-radius: 0;
      font-size: 12px;
      transition: background 0.15s;
  }
  .btn-small:hover { background: var(--ui-hover); }
  
  .btn-group-row { 
    display: flex; 
    width: 100%; 
    border: 1px solid var(--ui-border); 
    border-radius: 0; 
    overflow: hidden; 
    margin-bottom: 12px;
  }
  .btn-group-item { 
    flex: 1; 
    background: var(--ui-bg); 
    color: var(--ui-text); 
    border: none; 
    border-right: 1px solid var(--ui-border); 
    padding: 8px 4px; 
    cursor: pointer; 
    font-size: 11px; 
    white-space: nowrap; 
    overflow: hidden; 
    text-overflow: ellipsis;
    transition: background 0.15s;
  }
  .btn-group-item:last-child { border-right: none; }
  .btn-group-item:hover { background: var(--ui-hover); }
  .btn-group-item.active { 
    background: var(--ui-active); 
    color: var(--ui-active-text); 
  }

  /* ã‚¤ãƒ³ã‚¯èª¿æ•´ç”¨ã‚¹ãƒ©ã‚¤ãƒ€ãƒ¼ã‚¨ãƒªã‚¢ */
  #ink-adjust-area {
      background: var(--ui-hover); 
      padding: 12px; 
      border-radius: 0; 
      margin-top: 8px; 
      border: 1px solid var(--ui-border); 
      display: none;
  }

  /* ãƒ‘ãƒãƒ«åˆ‡ã‚Šæ›¿ãˆç”¨ */
  .panel-section { display: none; }
  .panel-section.active { display: block; }

  /* ãƒŠãƒƒã‚¸ãƒ‘ãƒƒãƒ‰ï¼ˆä½ç½®èª¿æ•´ï¼‰ */
  .nudge-pad {
    display: flex; 
    flex-direction: column; 
    align-items: center; 
    gap: 4px; 
    margin-bottom: 16px;
    background: var(--ui-hover); 
    padding: 12px; 
    border-radius: 0; 
    border: 1px solid var(--ui-border);
  }
  .nudge-row { display: flex; gap: 4px; }
  .nudge-btn {
    width: 36px; height: 36px; 
    background: var(--ui-bg); 
    border: 1px solid var(--ui-border); 
    color: var(--ui-text);
    border-radius: 0; 
    cursor: pointer; 
    display: flex; 
    justify-content: center; 
    align-items: center;
    font-size: 14px; 
    transition: background 0.15s;
  }
  .nudge-btn:hover { background: var(--ui-hover); }
  .nudge-btn:active { background: var(--ui-active); color: var(--ui-active-text); }
  .nudge-reset { 
    font-size: 9px; 
    font-weight: bold; 
    color: var(--ui-text); 
  }

  /* ç”»åƒã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ãƒ»ãƒˆãƒªãƒŸãƒ³ã‚°ç”¨ */
  .file-upload-btn, .action-btn {
      display: block; 
      width: 100%; 
      padding: 10px; 
      background: var(--ui-bg); 
      border: 1px solid var(--ui-border); 
      color: var(--ui-text);
      cursor: pointer; 
      text-align: center; 
      border-radius: 0; 
      margin-bottom: 10px; 
      box-sizing: border-box;
      font-size: 13px;
      transition: background 0.15s;
  }
  .file-upload-btn:hover, .action-btn:hover { 
    background: var(--ui-hover); 
  }
  .danger-btn {
    border-color: #d9534f;
    color: #d9534f;
  }
  .danger-btn:hover {
    background: #ffeaea;
  }
  #inp-image-file { display: none; }

  /* ã‚ãµã‚Œæƒ…å ±è¡¨ç¤ºã‚¨ãƒªã‚¢ */
  #overflow-info-box {
    background: var(--ui-hover); 
    border: 1px solid var(--ui-border); 
    padding: 12px; 
    margin-bottom: 16px; 
    border-radius: 0;
    color: var(--ui-text); 
    display: none; 
  }
  .overflow-warning { color: #d32f2f; font-weight: bold; }
  .overflow-ok { color: #388e3c; }

  /* --- ãƒ“ãƒ¥ãƒ¼ãƒãƒ¼ãƒˆ --- */
  #viewport {
    position: absolute; 
    top: var(--safe-top); 
    left: calc(80px + var(--safe-left)); 
    right: calc(320px + var(--safe-right));
    height: calc(var(--initial-vh) - var(--safe-top) - var(--safe-bottom));
    overflow: hidden; 
    background: #f0f0f0; 
    cursor: default;
  }
  #canvas-transform { 
    transform-origin: 0 0; 
    position: absolute; 
    top: 0; 
    left: 0; 
  }

  .paper {
    width: var(--paper-w); height: var(--paper-h); 
    background-color: var(--paper-color);
    position: absolute; top: 50px; left: 50px;
    box-shadow: 0 0 50px rgba(0,0,0,0.5);
    padding-top: var(--m-top); padding-bottom: var(--m-bottom);
    padding-right: var(--m-inner); padding-left: var(--m-outer);
    box-sizing: border-box; display: flex;
    transition: background-color 0.2s;
  }
  
  /* å¤–å‘¨æƒ…å ± (ç‰ˆé¢å¤–) */
  .margin-info-container {
      position: absolute; left: 0; width: 100%; height: 0; pointer-events: none;
      display: flex; justify-content: space-between; align-items: flex-end;
      padding: 0 var(--m-inner) 0 var(--m-outer); box-sizing: border-box;
  }
  #margin-info-top {
      top: calc(var(--m-top) - 6mm); /* ç‰ˆé¢ã‹ã‚‰6mmä¸Š */
      height: 0; overflow: visible;
  }
  .margin-info-item {
      color: var(--text-color);
      writing-mode: horizontal-tb;
      white-space: nowrap;
      transform-origin: bottom center;
      line-height: 1.0;
  }

  /* ã‚«ãƒ©ãƒ¼ãƒ‘ãƒƒãƒ (ç‰ˆé¢å¤–ä¸‹) */
  #color-patches-bottom {
      position: absolute; left: 0; width: 100%;
      top: calc(100% - var(--m-bottom) + 6mm); /* ç‰ˆé¢ã‹ã‚‰6mmä¸‹ */
      height: 10mm;
      display: flex; justify-content: center; align-items: top;
      pointer-events: none;
  }
  /* ä¹—ç®—ãƒ¢ãƒ¼ãƒ‰ */
  .color-patch-svg { overflow: visible; mix-blend-mode: multiply; }

  /* ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆç·šãƒ¬ã‚¤ãƒ¤ãƒ¼ (æ®µé–“ç½«ç·š: èƒŒé¢) */
  #layout-lines-layer {
    position: absolute; top: 0; left: 0; width: 100%; height: 100%;
    pointer-events: none; 
    z-index: 1; /* è¨˜äº‹ã®å¾Œã‚ */
    overflow: visible;
  }
  /* ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆæ ãƒ¬ã‚¤ãƒ¤ãƒ¼ (å¤–å‘¨æ : æœ€å‰é¢) */
  #layout-border-layer {
    position: absolute; top: 0; left: 0; width: 100%; height: 100%;
    pointer-events: none; 
    z-index: 50; /* è¨˜äº‹ã®æ‰‹å‰ (å¡—ã‚Šã¤ã¶ã•ã‚Œãªã„) */
    overflow: visible;
  }
  
  /* ç·šé¡ã®è‰² - è§’ä¸¸å‡¦ç†è¿½åŠ  */
  .print-border { 
      stroke: var(--text-color); stroke-width: var(--border-width); 
      fill: none; mix-blend-mode: multiply; 
      stroke-linejoin: round; stroke-linecap: round; /* è§’ä¸¸ */
  }
  .print-divider { 
      stroke: var(--text-color); stroke-width: var(--divider-width); 
      fill: none; mix-blend-mode: multiply; 
      stroke-linecap: round; /* ç«¯ä¸¸ */
  }

  .hanmen { width: 100%; height: 100%; position: relative; z-index: 2; }
  
  #grid-layer {
    position: absolute; top: 0; left: 0; width: 100%; 
    height: calc(100% / var(--scale-y));
    pointer-events: none; z-index: 0;
    background-repeat: repeat; background-position: right top;
    transform-origin: top right;
    transform: scaleY(var(--scale-y));
    transition: opacity 0.2s;
    mix-blend-mode: multiply;
  }

  /* --- è¨˜äº‹ã‚°ãƒ«ãƒ¼ãƒ— --- */
  .article-group {
    position: absolute; background: transparent; 
    display: flex; flex-direction: row-reverse; flex-wrap: wrap;
    pointer-events: auto; 
    transition: outline-color 0.2s;
  }
  
  /* é¸æŠæ ãƒ»ã‚ªãƒ¼ãƒãƒ¼ãƒ•ãƒ­ãƒ¼æ ã®æç”» (::afterã‚’ä½¿ç”¨) */
  .article-group::after {
    content: "";
    position: absolute;
    top: 0; left: 0;
    width: 100%; height: 100%;
    pointer-events: none;
    box-sizing: border-box;
    z-index: 50; /* å­è¦ç´ ã‚ˆã‚Šæ‰‹å‰ */
    border: 2px solid transparent;
    transition: border-color 0.2s;
    border-radius: 4px; /* é¸æŠæ ã‚‚å°‘ã—ä¸¸ã */
  }

  .article-group.selected { z-index: 10; }
  .article-group.selected::after { border-color: #2196f3; }

  .article-group.has-overflow { background-color: rgba(205, 92, 92, 0.1); }
  .article-group.has-overflow::after { border-color: var(--overflow-color); }

  .article-group.selected.has-overflow::after {
    border-style: dashed;
    box-shadow: 0 0 10px var(--overflow-color);
  }

body.preview-mode .article-group::after { border-color: transparent !important; box-shadow: none !important; }
body.preview-mode .article-group { background-color: transparent; }

  .article-transform-wrapper {
      transform-origin: top right;
      transform: scaleY(var(--scale-y));
      display: flex; flex-direction: row-reverse; flex-wrap: wrap;
  }

  /* è‡ªç”±ãƒ†ã‚­ã‚¹ãƒˆ */
  .free-text-wrapper {
    position: relative;
    display: flex;
    width: 100%;
    height: 100%;
    box-sizing: border-box;
    pointer-events: none;
  }
  .free-text-content {
    color: var(--text-color);
    mix-blend-mode: multiply;
    white-space: pre-wrap;
    word-break: break-word;
    overflow-wrap: break-word;
    max-width: 100%;
    max-height: 100%;
    pointer-events: none;
  }

  .resize-handle {
    position: absolute;
    width: 20px; height: 20px;
    z-index: 60;
    display: none;
    pointer-events: auto;
  }
  .resize-handle::before {
    content: '';
    position: absolute;
    width: 8px; height: 8px;
    background-color: #fff;
    border: 2px solid #2196f3;
    border-radius: 50%;
    top: 50%; left: 50%;
    transform: translate(-50%, -50%);
  }
  .resize-handle-tl { top: -10px; left: -10px; cursor: nwse-resize; }
  .resize-handle-tr { top: -10px; right: -10px; cursor: nesw-resize; }
  .resize-handle-bl { bottom: -10px; left: -10px; cursor: nesw-resize; }
  .resize-handle-br { bottom: -10px; right: -10px; cursor: nwse-resize; }
  .article-group.selected .resize-handle { display: block; }
  body.preview-mode .resize-handle { display: none !important; }

  /* --- ã‚»ã‚°ãƒ¡ãƒ³ãƒˆ(è¨˜äº‹æœ¬æ–‡) --- */
  .segment {
    width: auto; writing-mode: vertical-rl; 
    --box-size: var(--base-font-size); 
    font-size: calc(var(--box-size) * var(--glyph-scale));
    font-family: var(--font-family);
    font-weight: var(--font-weight);
    line-height: calc(var(--box-size) + var(--line-gap)); 
    letter-spacing: calc(var(--box-size) - (var(--box-size) * var(--glyph-scale)));
    color: var(--text-color); mix-blend-mode: multiply; 
    overflow: visible; 
    white-space: pre-wrap; word-break: normal; overflow-wrap: break-word; text-align: justify;
    font-feature-settings: "palt" 0; pointer-events: none; 
    transform: translate(var(--nudge-x), var(--nudge-y));
  }
  .spacer { width: 100%; height: var(--h-gap); pointer-events: none;}
  
  /* --- è¦‹å‡ºã—ãƒ»ç¸¦ç·šãƒ»ä¿®æ­£ãƒ†ãƒ¼ãƒ—ãƒ»ç”»åƒè¦ç´  --- */
  .headline-wrapper { width: 100%; height: 100%; overflow: hidden; position: relative; pointer-events: none; }
  .headline-inner {
    position: absolute; top: 0; left: 0;
    white-space: nowrap; line-height: 1.0; transform-origin: 0 0;
    display: flex; align-items: center; justify-content: center;
    transform-box: fill-box;
  }
  .headline-v { writing-mode: vertical-rl; transform-origin: top right; right: 0; left: auto; line-height: 1.0; }
  .headline-h { writing-mode: horizontal-tb; transform-origin: top left; line-height: 0.9; }
  .tcy { text-combine-upright: all; text-decoration: none; pointer-events: none; }

  .correction-box { width: 100%; height: 100%; pointer-events: none; }
  .correction-inner { width: 100%; height: 100%; }

  .vline-box { width: 100%; height: 100%; display: flex; justify-content: center; align-items: center; pointer-events: none; }
  .vline-inner { height: 100%; border-radius: 999px; /* è§’ä¸¸ */ }

  /* ç”»åƒãƒ–ãƒ­ãƒƒã‚¯ç”¨ */
  .image-box { 
      height: calc(100% * var(--scale-y)); 
      width: 100%; 
      display: flex; overflow: hidden; 
      background: transparent;
      pointer-events: none; 
      transform: scaleY(calc(1 / var(--scale-y)));
      transform-origin: top left;
  }

  .image-container {
      flex: 1 1 auto;
      min-width: 0; min-height: 0; 
      position: relative;
      display: flex; align-items: center; justify-content: center;
      background-color: transparent; /* èƒŒæ™¯é€é (ã‚¤ãƒ³ã‚¯ãƒ¢ãƒ¼ãƒ‰ç”¨) */
      color: #888; overflow: hidden;
  }
  .image-content {
      width: 100%; height: 100%; object-fit: cover; display: block;
  }

  .image-caption {
      flex: 0 0 auto; 
      font-size: calc(var(--base-font-size) * 0.5 * var(--glyph-scale));
      line-height: 1.2;
      background: var(--paper-color); /* ç´™è‰² */
      white-space: pre-wrap;
      box-sizing: border-box;
      padding: 3px 5px;
      color: var(--text-color);
      overflow: hidden; 
      z-index: 10;
  }
  .caption-h { writing-mode: horizontal-tb; width: 100%; max-height: 100%; }
  .caption-v { writing-mode: vertical-rl; height: 100%; max-width: 100%; }

  /* é¡Œå­—ï¼ˆãƒ˜ãƒƒãƒ€ãƒ¼ï¼‰Ver.79 Layout */
  .header-container {
      width: 100%; height: 100%; 
      display: flex; flex-direction: column; 
      pointer-events: none;
      transform: translate(var(--nudge-x), var(--nudge-y));
      background-color: var(--paper-color); 
      box-shadow: calc(var(--line-gap)*-1) 0 0 0 var(--paper-color), var(--line-gap) 0 0 0 var(--paper-color); 
  }
  
  .header-title-box-outer {
      flex: 1; 
      border-style: solid; 
      border-color: var(--text-color);
      padding: 4px; 
      box-sizing: border-box;
      display: flex;
      background: var(--paper-color);
      overflow: hidden;
      border-radius: 2px; /* è§’ã‚’å°‘ã—ä¸¸ã */
  }
  
  .header-title-box-inner {
      flex: 1;
      border-style: solid;
      border-color: var(--text-color); 
      position: relative;
      overflow: hidden;
      display: flex; align-items: center; justify-content: center; 
      border-radius: 1px;
      color: var(--text-color); /* ã‚¤ãƒ³ã‚¯è‰²ã‚’ç¶™æ‰¿ */
  }

  .header-bg-pattern {
      position: absolute; top: 0; left: 0; width: 100%; height: 100%;
      z-index: 0; opacity: 1; pointer-events: none;
      color: inherit; /* è¦ªã®colorã‚’ä½¿ã† */
  }

  .header-title-text {
      z-index: 2;
      background: transparent;
      line-height: 1.0;
      white-space: nowrap;
      position: relative;
      writing-mode: vertical-rl;
      font-weight: 900;
      paint-order: stroke fill;
      transform-box: fill-box;
  }

  .header-title-transform {
      position: absolute;
      inset: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      pointer-events: none;
  }

  /* --- ã‚¨ãƒ‡ã‚£ã‚¿ãƒ»ãƒ¢ãƒ¼ãƒ€ãƒ«é–¢é€£ --- */
  .inline-editor {
    position: absolute; z-index: 9999; writing-mode: vertical-rl;
    font-size: var(--base-font-size); 
    line-height: calc(var(--base-font-size) + var(--line-gap));
    font-family: var(--font-family); background: rgba(255, 255, 255, 0.95);
    border: 2px solid #2196f3; outline: none; resize: none; padding: 0; box-sizing: border-box;
    white-space: pre-wrap; overflow: auto; box-shadow: 0 5px 25px rgba(0,0,0,0.5);
    pointer-events: auto; cursor: text;
    transform-origin: top right;
    transform: scaleY(var(--scale-y));
  }
  
  .overlay-modal {
    position: fixed; top: 0; left: 0; width: 100vw; height: 100vh;
    background: rgba(0,0,0,0.3); z-index: 9999; display: none;
    justify-content: center; align-items: center; flex-direction: column;
  }
  .modal-panel {
    background: var(--ui-bg); padding: 24px; border-radius: 0;
    border: 1px solid var(--ui-border);
    display: flex; flex-direction: column; gap: 12px;
    max-width: 90%; max-height: 90%;
  }
  .modal-title { 
    color: var(--ui-text); 
    font-weight: bold; 
    font-size: 16px; 
  }
  .modal-buttons { 
    display: flex; 
    justify-content: flex-end; 
    gap: 10px; 
    margin-top: 12px; 
  }
  .modal-btn { 
    padding: 10px 20px; 
    border-radius: 0; 
    cursor: pointer; 
    border: 1px solid var(--ui-border); 
    font-weight: 500;
    transition: background 0.15s;
    font-size: 13px;
  }
  .btn-cancel { 
    background: var(--ui-bg); 
    color: var(--ui-text); 
  }
  .btn-cancel:hover {
    background: var(--ui-hover);
  }
  .btn-save { 
    background: var(--ui-active); 
    color: var(--ui-active-text); 
  }
  .btn-save:hover {
    background: #333;
  }

  /* ãƒ†ã‚­ã‚¹ãƒˆã‚¨ãƒ‡ã‚£ã‚¿ç”¨ */
  #editor-panel {
    width: 90vw;
    max-width: 600px;
  }
  #editor-textarea {
    width: 100%;
    height: 200px;
    min-height: 200px;
    background: var(--ui-bg);
    color: var(--ui-text);
    border: 1px solid var(--ui-border);
    padding: 12px;
    font-size: 16px;
    box-sizing: border-box; 
    border-radius: 0; resize: vertical; outline: none;
    font-family: inherit;
  }

  /* ãƒˆãƒªãƒŸãƒ³ã‚°ã‚¨ãƒ‡ã‚£ã‚¿ç”¨ */
  #crop-panel { width: auto; height: auto; align-items: center; min-width: 300px; }
  #crop-canvas-container {
      position: relative; overflow: hidden; 
      border: 1px solid var(--ui-border); 
      background: repeating-conic-gradient(#f5f5f5 0% 25%, #e0e0e0 0% 50%) 50% / 20px 20px;
  }
  #crop-canvas { display: block; cursor: move; }
  .crop-controls {
      display: flex; gap: 10px; align-items: center; width: 100%; 
      color: var(--ui-text); font-size: 12px;
  }
  .crop-controls input[type="range"] { flex: 1; }

  /* ã‚¢ã‚¤ã‚³ãƒ³ãƒ»ãƒªãƒ³ã‚¯ */
  .port {
    position: absolute;
    width: 0; height: 0;
    cursor: pointer; z-index: 60; pointer-events: auto; /* z-indexèª¿æ•´ */
    left: 50%; margin-left: -7px; 
    transition: transform 0.15s;
    border-left: 7px solid transparent;
    border-right: 7px solid transparent;
    border-top: 12px solid #444; /* ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆè‰²ã¯å¾Œã§ä¸Šæ›¸ã */
    border-bottom: 0;
    box-shadow: 0 0 2px rgba(0,0,0,0.4);
  }
  .port:hover { transform: scale(1.5); }
  .port-in { top: -8px; border-top-color: #2196f3; }
  .port-in.connected { border-top-color: #ffeb3b; }
  .port-out { bottom: -8px; border-top-color: #ef5350; }
  .port-out.linked { border-top-color: #66bb6a; }
  .port.link-mode-compatible { transform: scale(2); }
  .port.port-hovered { transform: scale(2.2); }
  .article-group.type-headline .port, .article-group.type-correction .port, .article-group.type-vline .port, .article-group.type-image .port, .article-group.type-header .port { display: none; }

  #link-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 5; }
  .link-line { stroke: #ffca28; stroke-width: 2; fill: none; stroke-dasharray: 4; stroke-linecap: round; }
  #temp-link-line { stroke: #ffeb3b; stroke-width: 3; fill: none; stroke-dasharray: 5; stroke-linecap: round; display: none; }

  body.preview-mode .port, body.preview-mode #link-layer, body.preview-mode .inline-editor { display: none !important; }

  .ghost {
    position: absolute; border: 1px solid #2196f3;
    background: rgba(33, 150, 243, 0.2); pointer-events: none; z-index: 100;
  }
  
  #measure-box {
    position: absolute; top: -9999px; left: -9999px; visibility: hidden;
    writing-mode: vertical-rl; white-space: pre-wrap; word-break: normal; overflow-wrap: break-word; text-indent: 0;
    min-width: 10px; min-height: 10px; box-sizing: border-box;
    padding: 0; margin: 0; border: none;
  }
  #text-measure-box, #header-measure-box { position: absolute; top: -9999px; left: -9999px; visibility: hidden; white-space: nowrap; line-height: 1.0; }

</style>
  
</head>
<body class="tool-hand"> 
<div id="launch-screen">
  <div class="content">
    <h1>æ–°èä½œæˆãƒ„ãƒ¼ãƒ«</h1>
    <div class="subtitle">èµ·å‹•ä¸­â€¦ æº–å‚™ãŒæ•´ã„æ¬¡ç¬¬ã‚¹ã‚¿ãƒ¼ãƒˆã—ã¾ã™</div>
    <div class="launch-spinner"></div>
  </div>
</div>

<!-- SVGãƒ•ã‚£ãƒ«ã‚¿å‹•çš„æ ¼ç´ç”¨ -->
<div id="svg-filters-container" style="position: absolute; width: 0; height: 0; overflow: hidden;">
  <svg>
    <defs>
      <!-- æ¨ªç·šãƒ‘ã‚¿ãƒ¼ãƒ³ (ã‚¤ãƒ³ã‚¯è‰²ã€ãƒãƒ¼ãƒãƒ«æç”») -->
      <pattern id="pat-lines" x="0" y="0" width="10" height="4" patternUnits="userSpaceOnUse">
        <line x1="0" y1="2" x2="10" y2="2" stroke="currentColor" stroke-width="0.5" stroke-linecap="round" /> 
      </pattern>
    </defs>
  </svg>
</div>

<!-- å·¦ã‚µã‚¤ãƒ‰ãƒãƒ¼ (ãƒ„ãƒ¼ãƒ«ãƒãƒ¼) -->
<div class="toolbar-container">
  <div class="tool-group">
    <div class="tool-btn active" id="tool-hand" onclick="setTool('hand')" title="ç§»å‹•ãƒ»æ“ä½œ">
      <div class="tool-icon">
        <svg viewBox="0 0 24 24" class="duotone-icon"><path d="M21,15a2,2,0,0,1-2,2H7l-4,4V5A2,2,0,0,1,5,3h9" fill="currentColor" class="secondary" style="opacity:0"/><path d="M12,2a1,1,0,0,1,1,1v8h0a1,1,0,0,1,2,0V5a1,1,0,0,1,2,0v6h0a1,1,0,0,1,2,0V8a1,1,0,0,1,2,0v6.86c0,4.4-4.06,7.14-8.15,7.14a7,7,0,0,1-5.12-2.31L4,15.83,5.15,14a1,1,0,0,1,1.46-.22l2.39,1.9V3A1,1,0,0,1,10,2h1m0-2H10A3,3,0,0,0,7,3V13.8L6.4,13.31a3,3,0,0,0-4.39.67L.81,15.83l3.87,3.87A9,9,0,0,0,11.05,24C16.89,24,23,20.08,23,14.86V8a3,3,0,0,0-3-3V5a3,3,0,0,0-3-3V3a3,3,0,0,0-3-3Z" fill="currentColor"/></svg>
      </div>
      <div class="tool-label">ç§»å‹•</div>
    </div>
    <div class="tool-btn" id="tool-box" onclick="setTool('box')" title="è¨˜äº‹ã‚’ä½œæˆ">
      <div class="tool-icon">
         <svg viewBox="0 0 24 24" class="duotone-icon"><rect x="3" y="3" width="18" height="18" rx="2" fill="currentColor" class="secondary"/><path d="M19,3H5A2,2,0,0,0,3,5V19a2,2,0,0,0,2,2H19a2,2,0,0,0,2-2V5A2,2,0,0,0,19,3ZM10,17H7V15h3Zm0-4H7V11h3Zm0-4H7V7h3Zm7,8H12V15h5Zm0-4H12V11h5Zm0-4H12V7h5Z" fill="currentColor"/></svg>
      </div>
      <div class="tool-label">è¨˜äº‹</div>
    </div>
    <div class="tool-btn" id="tool-headline" onclick="setTool('headline')" title="è¦‹å‡ºã—ã‚’ä½œæˆ">
      <div class="tool-icon">
        <svg viewBox="0 0 24 24" class="duotone-icon"><rect x="3" y="5" width="18" height="14" rx="1" fill="currentColor" class="secondary"/><path d="M5,4V20H19V4ZM17,7v1.5H12.75V17h-1.5V8.5H7V7Z" fill="currentColor"/></svg>
      </div>
      <div class="tool-label">è¦‹å‡ºã—</div>
    </div>
    <div class="tool-btn" id="tool-image" onclick="setTool('image')" title="ç”»åƒã‚’é…ç½®">
      <div class="tool-icon">
        <svg viewBox="0 0 24 24" class="duotone-icon"><rect x="3" y="3" width="18" height="18" rx="2" fill="currentColor" class="secondary"/><circle cx="8.5" cy="8.5" r="1.5" fill="currentColor" style="opacity:0.8"/><polyline points="21 15 16 10 5 21" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg>
      </div>
      <div class="tool-label">ç”»åƒ</div>
    </div>
  </div>
  <div class="tool-group">
    <div class="tool-btn" id="tool-header" onclick="setTool('header')" title="é¡Œå­—ã‚’ä½œæˆ">
      <div class="tool-icon">
        <svg viewBox="0 0 24 24" class="duotone-icon"><path d="M12,2L2,7l10,5L22,7Z" fill="currentColor"/><path d="M2,17l10,5,10-5M2,12l10,5,10-5" fill="none" stroke="currentColor" stroke-width="2" stroke-linejoin="round"/></svg>
      </div>
      <div class="tool-label">é¡Œå­—</div>
    </div>
    <div class="tool-btn" id="tool-correction" onclick="setTool('correction')" title="ä¿®æ­£ãƒ†ãƒ¼ãƒ—">
      <div class="tool-icon">
         <svg viewBox="0 0 24 24" class="duotone-icon"><rect x="4" y="4" width="16" height="16" fill="currentColor" class="secondary"/><path d="M20,4H4V20H20ZM8,14H6V10H8Zm10,0H10V10H18Z" fill="currentColor" fill-rule="evenodd"/></svg>
      </div>
      <div class="tool-label">å¡—ã‚Š</div>
    </div>
    <div class="tool-btn" id="tool-free-text" onclick="setTool('free-text')" title="è‡ªç”±ãƒ†ã‚­ã‚¹ãƒˆ">
      <div class="tool-icon">
        <svg viewBox="0 0 24 24" class="duotone-icon"><rect x="3" y="3" width="18" height="18" rx="2" fill="currentColor" class="secondary"/><path d="M8 7h8v2h-3v8h-2V9H8z" fill="currentColor"/></svg>
      </div>
      <div class="tool-label">è‡ªç”±æ–‡</div>
    </div>
    <div class="tool-btn" id="tool-vline" onclick="setTool('vline')" title="ç¸¦ç·šã‚’å¼•ã">
      <div class="tool-icon">
        <svg viewBox="0 0 24 24" class="duotone-icon"><rect x="11" y="3" width="2" height="18" fill="currentColor"/></svg>
      </div>
      <div class="tool-label">ç¸¦ç·š</div>
    </div>
  </div>
  <div class="tool-group">
    <div class="tool-btn" onclick="undo()" title="å…ƒã«æˆ»ã™">
      <div class="tool-icon">
        <svg viewBox="0 0 24 24" class="duotone-icon"><path d="M12,5V1L7,6l5,5V7c3.31,0,6,2.69,6,6s-2.69,6-6,6-6-2.69-6-6H4c0,4.42,3.58,8,8,8s8-3.58,8-8-3.58-8-8-8Z" fill="currentColor"/></svg>
      </div>
      <div class="tool-label">æˆ»ã‚‹</div>
    </div>
    <div class="tool-btn" onclick="redo()" title="ã‚„ã‚Šç›´ã™">
      <div class="tool-icon">
        <svg viewBox="0 0 24 24" class="duotone-icon"><path d="M12,5V1l5,5-5,5V7c-3.31,0-6,2.69-6,6s2.69,6,6,6,6-2.69,6-6h2c0,4.42-3.58,8-8,8s-8-3.58-8-8,3.58-8,8-8Z" fill="currentColor"/></svg>
      </div>
      <div class="tool-label">é€²ã‚€</div>
    </div>
    <div class="tool-btn" onclick="fitView()" title="å…¨ä½“ã‚’è¡¨ç¤º">
      <div class="tool-icon">
        <svg viewBox="0 0 24 24" class="duotone-icon"><path d="M10,20v-6h4v6h5v-8h3L12,3,2,12H5v8Z" fill="currentColor" class="secondary"/><path d="M12,5.69l5,4.5V18h-2v-6H9v6H7V10.19l5-4.5M12,3,2,12H5v8H9v-6h6v6h4V12h3L12,3Z" fill="currentColor"/></svg>
      </div>
      <div class="tool-label">å…¨ä½“</div>
    </div>
  </div>
  <div class="tool-group">
      <div class="tool-btn" onclick="saveFile(true)" title="ä¿å­˜">
        <div class="tool-icon">
          <svg viewBox="0 0 24 24" class="duotone-icon"><path d="M17,3H5A2,2,0,0,0,3,5V19a2,2,0,0,0,2,2H19a2,2,0,0,0,2-2V7Zm2,16H5V5H16.17L19,7.83Zm-7-7A3,3,0,1,0,15,15,3,3,0,0,0,12,12ZM6,6h9v4H6Z" fill="currentColor"/></svg>
        </div>
        <div class="tool-label">ä¿å­˜</div>
      </div>
      <div class="tool-btn" onclick="openFileMenu()" title="ãƒ•ã‚¡ã‚¤ãƒ«">
        <div class="tool-icon">
          <svg viewBox="0 0 24 24" class="duotone-icon"><path d="M10,4H4A2,2,0,0,0,2,6V18a2,2,0,0,0,2,2H20a2,2,0,0,0,2-2V8a2,2,0,0,0-2-2H12Z" fill="currentColor" class="secondary"/><path d="M20,6h-8l-2-2H4A2,2,0,0,0,2,6V18a2,2,0,0,0,2,2H20a2,2,0,0,0,2-2V8a2,2,0,0,0-2-2Zm0,12H4V8H20Z" fill="currentColor"/></svg>
        </div>
        <div class="tool-label">é–‹ã</div>
      </div>
      <div class="tool-btn" onclick="openExportMenu()" title="æ›¸ãå‡ºã—">
        <div class="tool-icon">
          <svg viewBox="0 0 24 24" class="duotone-icon"><path d="M19,9h-4V3H9v6H5l7,7ZM5,18v2h14v-2Z" fill="currentColor"/></svg>
        </div>
        <div class="tool-label">æ›¸å‡º</div>
      </div>
  </div>
</div>

<div id="auto-save-indicator">ä¿å­˜ã—ã¾ã—ãŸ</div>

<!-- ãƒ•ã‚¡ã‚¤ãƒ«ãƒ¡ãƒ‹ãƒ¥ãƒ¼ãƒ¢ãƒ¼ãƒ€ãƒ« -->
<div id="file-menu-overlay" class="menu-overlay" onclick="if(event.target === this) this.style.display='none'">
    <div class="menu-panel">
        <div class="menu-header">ãƒ•ã‚¡ã‚¤ãƒ«</div>
        <div class="menu-item" onclick="saveFile(true)"><span>ğŸ’¾ åå‰ã‚’ä»˜ã‘ã¦ä¿å­˜...</span></div>
        <label class="menu-item">
            <span>ğŸ“‚ èª­ã¿è¾¼ã¿...</span>
            <input type="file" accept=".json" style="display:none" onchange="loadFile(this)">
        </label>
        <div class="menu-item" onclick="resetCanvasConfirm()"><span>ğŸ—‘ï¸ æ–°è¦ä½œæˆ</span></div>
        <button class="modal-btn btn-cancel" style="margin-top:10px; width:100%;" onclick="document.getElementById('file-menu-overlay').style.display='none'">é–‰ã˜ã‚‹</button>
    </div>
</div>

<!-- ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆãƒ¡ãƒ‹ãƒ¥ãƒ¼ãƒ¢ãƒ¼ãƒ€ãƒ« -->
<div id="export-menu-overlay" class="menu-overlay" onclick="if(event.target === this) this.style.display='none'">
    <div class="menu-panel">
        <div class="menu-header">ç”»åƒæ›¸ãå‡ºã—</div>
        <div class="menu-item" onclick="exportCanvasToImage('png')"><span>ğŸ–¼ï¸ PNGç”»åƒ</span></div>
        <div class="menu-item" onclick="exportCanvasToImage('jpeg')"><span>ğŸ–¼ï¸ JPGç”»åƒ</span></div>
        <div class="calc-info" style="text-align:left; color:#666;">
            ç¾åœ¨ã®ã‚­ãƒ£ãƒ³ãƒã‚¹ã‚’ã‚¹ã‚¯ãƒªãƒ¼ãƒ³ã‚·ãƒ§ãƒƒãƒˆã®ã‚ˆã†ã«é«˜ç”»è³ªã§ä¿å­˜ã—ã¾ã™ã€‚
        </div>
        <button class="modal-btn btn-cancel" style="margin-top:10px; width:100%;" onclick="document.getElementById('export-menu-overlay').style.display='none'">é–‰ã˜ã‚‹</button>
    </div>
</div>

<!-- ãƒ†ã‚­ã‚¹ãƒˆç·¨é›†ç”¨ ãƒ¢ãƒ¼ãƒ€ãƒ« -->
<div id="editor-overlay" class="overlay-modal">
  <div id="editor-panel" class="modal-panel">
    <div class="modal-title">ãƒ†ã‚­ã‚¹ãƒˆç·¨é›†</div>
    <div class="calc-info" style="text-align:left; color:#666;">â€»2æ¡æ•°å­—ã¯è‡ªå‹•ã§ç¸¦ä¸­æ¨ªã«ãªã‚Šã¾ã™</div>
    <textarea id="editor-textarea"></textarea>
    <div class="modal-buttons">
      <button class="modal-btn btn-cancel" onclick="closeOverlayEditor()">ã‚­ãƒ£ãƒ³ã‚»ãƒ«</button>
      <button class="modal-btn btn-save" onclick="saveOverlayEditor()">OK</button>
    </div>
  </div>
</div>

<!-- ãƒˆãƒªãƒŸãƒ³ã‚°ç·¨é›†ç”¨ ãƒ¢ãƒ¼ãƒ€ãƒ« -->
<div id="crop-overlay" class="overlay-modal">
    <div id="crop-panel" class="modal-panel">
        <div class="modal-title">ç”»åƒã®é…ç½®èª¿æ•´</div>
        <div class="calc-info" style="text-align:left; color:#666;">ãƒ‰ãƒ©ãƒƒã‚°ã§ç§»å‹•ã€ã‚¹ãƒ©ã‚¤ãƒ€ãƒ¼ã§æ‹¡å¤§</div>
        <div id="crop-canvas-container">
            <canvas id="crop-canvas"></canvas>
        </div>
        <div class="crop-controls">
            <span>ç¸®å°</span>
            <input type="range" id="crop-zoom" min="1.0" max="5.0" step="0.01" value="1.0" oninput="updateCropView()">
            <span>æ‹¡å¤§</span>
        </div>
        <div class="modal-buttons">
            <button class="modal-btn btn-cancel" onclick="closeCropEditor()">ã‚­ãƒ£ãƒ³ã‚»ãƒ«</button>
            <button class="modal-btn btn-save" onclick="applyCrop()">é©ç”¨</button>
        </div>
    </div>
</div>

<!-- å³ã‚µã‚¤ãƒ‰ãƒãƒ¼ (è¨­å®šãƒ‘ãƒãƒ«) -->
<div class="settings-panel">
  <!-- ã‚°ãƒ­ãƒ¼ãƒãƒ«è¨­å®š -->
  <div id="panel-global" class="panel-section active">
    
    <div class="ui-header">ç”¨ç´™</div>
    <div class="ui-row">
        <select id="paper-preset" onchange="updatePaperSize('preset')" style="flex:2">
            <option value="A3">A3 (297Ã—420)</option>
            <option value="A4">A4 (210Ã—297)</option>
            <option value="B4">B4 (257Ã—364)</option>
            <option value="custom">ã‚«ã‚¹ã‚¿ãƒ </option>
        </select>
        <button class="btn-small" onclick="swapPaperWH()" title="ç¸¦æ¨ªå…¥æ›¿">âŸ³</button>
    </div>
    <div class="ui-row">
        <label>å¹…</label>
        <input type="number" id="paper-w-mm" value="297" onchange="updatePaperSize('input')">
        <label>é«˜</label>
        <input type="number" id="paper-h-mm" value="420" onchange="updatePaperSize('input')">
    </div>

    <div class="ui-row">
        <label>æ®µæ•°</label>
        <input type="range" id="paper-dan-count" min="1" max="15" step="1" value="8" oninput="updatePaperConfigInternal()">
        <input type="number" id="val-paper-dan-count" class="val" value="8" min="1" max="15" step="1" oninput="syncInputValue('val-paper-dan-count','paper-dan-count'); updatePaperConfigInternal()">
    </div>
    <div class="ui-row">
        <label>1æ®µã®è¡Œæ•°</label>
        <input type="range" id="paper-rows-per-dan" min="10" max="100" step="1" value="40" oninput="updatePaperConfigInternal()">
        <input type="number" id="val-paper-rows-per-dan" class="val" value="40" min="10" max="100" step="1" oninput="syncInputValue('val-paper-rows-per-dan','paper-rows-per-dan'); updatePaperConfigInternal()">
    </div>
    <div class="ui-row">
        <label>1è¡Œã®æ–‡å­—æ•°</label>
        <input type="range" id="paper-chars-per-dan" min="5" max="30" step="1" value="11" oninput="updatePaperConfigInternal()">
        <input type="number" id="val-paper-chars-per-dan" class="val" value="11" min="5" max="30" step="1" oninput="syncInputValue('val-paper-chars-per-dan','paper-chars-per-dan'); updatePaperConfigInternal()">
    </div>

    <div class="ui-header">ä½™ç™½</div>
    <div class="ui-row"><label>ä¸Š</label><input type="number" id="margin-top" value="20" onchange="updateMargins()"><span style="font-size:11px;">mm</span></div>
    <div class="ui-row"><label>ä¸‹</label><input type="number" id="margin-bottom" value="20" onchange="updateMargins()"><span style="font-size:11px;">mm</span></div>
    <div class="ui-row"><label>å·¦</label><input type="number" id="margin-left" value="20" onchange="updateMargins()"><span style="font-size:11px;">mm</span></div>
    <div class="ui-row"><label>å³</label><input type="number" id="margin-right" value="20" onchange="updateMargins()"><span style="font-size:11px;">mm</span></div>

    <div class="ui-header">å¤–å‘¨æƒ…å ±</div>
    <div class="btn-group-row">
        <button class="btn-group-item active" id="btn-marg-left" onclick="selectMarginaliaTarget('left')">å·¦</button>
        <button class="btn-group-item" id="btn-marg-center" onclick="selectMarginaliaTarget('center')">ä¸­å¤®</button>
        <button class="btn-group-item" id="btn-marg-right" onclick="selectMarginaliaTarget('right')">å³</button>
    </div>
    <div class="ui-row"><label>å†…å®¹</label><input type="text" id="marg-text" oninput="updateMarginaliaConfig()"></div>
    <div class="ui-row"><label>ãƒ•ã‚©ãƒ³ãƒˆ</label><select id="marg-font" class="font-selector" onchange="updateMarginaliaConfig()"></select></div>
    <div class="ui-row">
        <label>ã‚µã‚¤ã‚º</label><input type="range" id="marg-size" min="5" max="32" value="12" oninput="updateMarginaliaConfig()">
        <input type="number" id="val-marg-size" class="val" value="12" min="5" max="32" step="1" oninput="syncInputValue('val-marg-size','marg-size'); updateMarginaliaConfig()">
    </div>
    <div class="ui-row">
        <label>å¤ªã•</label><input type="range" id="marg-weight" min="100" max="900" step="100" value="400" oninput="updateMarginaliaConfig()">
        <input type="number" id="val-marg-weight" class="val" value="400" min="100" max="900" step="100" oninput="syncInputValue('val-marg-weight','marg-weight'); updateMarginaliaConfig()">
    </div>
    <div class="ui-row">
        <label>å­—é–“</label><input type="range" id="marg-spacing" min="0" max="20" value="2" step="0.5" oninput="updateMarginaliaConfig()">
        <input type="number" id="val-marg-spacing" class="val" value="2" min="0" max="20" step="0.5" oninput="syncInputValue('val-marg-spacing','marg-spacing'); updateMarginaliaConfig()">
    </div>

    <!-- ã‚°ãƒ­ãƒ¼ãƒãƒ«å´ã®æœ¬æ–‡ä½ç½®èª¿æ•´ã¯è¨˜äº‹ãƒ‘ãƒãƒ«ã¸ç§»è¨­ -->

    <div class="ui-header">è¡¨ç¤º</div>
    <div class="ui-row"><label>æ–‡å­—ãƒã‚¹</label><input type="checkbox" id="chk-grid" checked onchange="toggleGrid()"></div>
    <div class="ui-row"><label>ãƒã‚¹è‰²</label><input type="color" id="inp-grid-color" value="#dddddd" oninput="updateColors()"></div>
    <div class="ui-row"><label>ç´™è‰²</label><input type="color" id="inp-paper-color" value="#fcfcfc" oninput="updateColors()"></div>
    <div class="ui-row"><label>ã‚¤ãƒ³ã‚¯è‰²</label><input type="color" id="inp-text-color" value="#111111" oninput="updateColors()"></div>
    
    <div class="ui-header">ç½«ç·š</div>
    <div class="ui-row"><label>æ®µé–“</label><input type="range" min="0.1" max="5" step="0.1" value="1.0" id="inp-divider-width" oninput="updateColors()"><input type="number" id="val-divider-width" class="val" value="1.0" min="0.1" max="5" step="0.1" oninput="syncInputValue('val-divider-width','inp-divider-width'); updateColors()"></div>
    <div class="ui-row"><label>å¤–å‘¨æ </label><input type="range" min="0.1" max="5" step="0.1" value="1.0" id="inp-border-width" oninput="updateColors()"><input type="number" id="val-border-width" class="val" value="1.0" min="0.1" max="5" step="0.1" oninput="syncInputValue('val-border-width','inp-border-width'); updateColors()"></div>
    
  </div>

  <!-- è¨˜äº‹è¨­å®š -->
  <div id="panel-article" class="panel-section">
    <div class="ui-header">æœ¬æ–‡ã®ä½ç½®èª¿æ•´</div>
    <div class="nudge-pad" id="nudge-pad-article" title="å…¨ä½“ã®æ–‡å­—ä½ç½®ã‚’ä¸€æ‹¬èª¿æ•´">
      <button class="nudge-btn" onclick="nudgeSelection(0, -1, false, event)">â–²</button>
      <div class="nudge-row">
        <button class="nudge-btn" onclick="nudgeSelection(-1, 0, false, event)">â—€</button>
        <button class="nudge-btn nudge-reset" onclick="nudgeSelection(0, 0, true, event)">RST</button>
        <button class="nudge-btn" onclick="nudgeSelection(1, 0, false, event)">â–¶</button>
      </div>
      <button class="nudge-btn" onclick="nudgeSelection(0, 1, false, event)">â–¼</button>
    </div>
    <div class="ui-header">ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆ</div>
    <div class="ui-row"><label>è‡ªç”±ãªé«˜ã•</label><input type="checkbox" id="art-free-layout" onchange="updateArticleAttr()"></div>
    <div id="overflow-info-box" style="display:block; margin-top:10px;">
       <div style="font-weight:600; margin-bottom:4px;">æ–‡å­—æ•°ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹</div>
       <div id="overflow-status-text" style="font-size:13px;">-</div>
    </div>
    <div class="calc-info">â€»ãƒ€ãƒ–ãƒ«ã‚¯ãƒªãƒƒã‚¯ã§ç·¨é›†</div>

    <div class="ui-header">ãƒ•ã‚©ãƒ³ãƒˆ</div>
    <div class="ui-row">
      <select id="inp-font" class="font-selector" onchange="calculateLayout()"></select>
    </div>
    <div class="ui-row">
      <label>å¤ªã•</label>
      <input type="range" min="100" max="900" step="100" value="400" id="inp-font-weight" oninput="updateVisuals()">
      <input type="number" id="val-font-weight" class="val" value="400" min="100" max="900" step="100" oninput="syncInputValue('val-font-weight','inp-font-weight'); updateVisuals()">
    </div>
    <div class="ui-row"><label>å­—å½¢å€ç‡</label><input type="range" min="0.5" max="1.5" step="0.01" value="1.0" id="inp-glyph-scale" oninput="updateVisuals()"><input type="number" id="val-glyph-scale" class="val" value="1.0" min="0.5" max="1.5" step="0.01" oninput="syncInputValue('val-glyph-scale','inp-glyph-scale'); updateVisuals()"></div>

    <div class="ui-header">ãƒœãƒƒã‚¯ã‚¹æ“ä½œ</div>
    <button class="action-btn danger-btn" onclick="deleteSelectedBox()">ã“ã®ãƒœãƒƒã‚¯ã‚¹ã‚’å‰Šé™¤</button>
  </div>

  <!-- ç”»åƒè¨­å®š -->
  <div id="panel-image" class="panel-section">
    <div class="ui-header">ç”»åƒ</div>
    <label class="file-upload-btn">
        ğŸ“ ç”»åƒã‚’é¸æŠ
        <input type="file" id="inp-image-file" accept="image/*" onchange="handleImageUpload(this)">
    </label>
    <button class="action-btn" onclick="openCropTool()">âœ‚ é…ç½®èª¿æ•´</button>
    <div class="calc-info" style="margin-bottom:10px;">ãƒ‰ãƒ©ãƒƒã‚°ã§æ ã‚µã‚¤ã‚ºå¤‰æ›´å¯</div>

    <div class="ui-header">ã‚«ãƒ©ãƒ¼</div>
    <div class="ui-row"><label>ãƒ¢ãƒ¼ãƒ‰</label>
      <select id="img-color-mode" onchange="updateImageAttr()">
        <option value="color">ãƒ•ãƒ«ã‚«ãƒ©ãƒ¼</option>
        <option value="ink">ã‚¤ãƒ³ã‚¯è‰²</option>
      </select>
    </div>
    
    <!-- ã‚¤ãƒ³ã‚¯èª¿æ•´ã‚¹ãƒ©ã‚¤ãƒ€ãƒ¼ï¼ˆã‚¤ãƒ³ã‚¯ãƒ¢ãƒ¼ãƒ‰æ™‚ã®ã¿è¡¨ç¤ºï¼‰ -->
    <div id="ink-adjust-area">
        <div class="ui-row">
            <label style="width:70px">ã‚³ãƒ³ãƒˆãƒ©ã‚¹ãƒˆ</label>
            <input type="range" min="0.5" max="3.0" step="0.1" value="1.0" id="img-contrast" oninput="updateImageAttr()">
            <input type="number" id="val-img-contrast" class="val" style="font-size:11px; width:50px;" value="1.0" min="0.5" max="3.0" step="0.1" oninput="syncInputValue('val-img-contrast','img-contrast'); updateImageAttr()">
        </div>
        <div class="ui-row">
            <label style="width:70px">æ˜ã‚‹ã•</label>
            <input type="range" min="-1.0" max="1.0" step="0.1" value="0.0" id="img-brightness" oninput="updateImageAttr()">
            <input type="number" id="val-img-brightness" class="val" style="font-size:11px; width:50px;" value="0.0" min="-1.0" max="1.0" step="0.1" oninput="syncInputValue('val-img-brightness','img-brightness'); updateImageAttr()">
        </div>
        <div class="calc-info">â€»æ˜åº¦ã«åˆã‚ã›ã¦è‡ªå‹•åè»¢</div>
    </div>

    <div class="ui-header">ã‚­ãƒ£ãƒ—ã‚·ãƒ§ãƒ³</div>
    <div class="ui-row"><label>ä½ç½®</label>
      <select id="img-cap-pos" onchange="updateImageAttr()">
        <option value="none">ãªã—</option>
        <option value="bottom" selected>ä¸‹</option>
        <option value="top">ä¸Š</option>
        <option value="left">å·¦</option>
        <option value="right">å³</option>
      </select>
    </div>
    <div class="ui-row"><label>ãƒ•ã‚©ãƒ³ãƒˆ</label><select id="img-font" class="font-selector" onchange="updateImageAttr()"></select></div>
    <div class="calc-info">â€»ãƒ€ãƒ–ãƒ«ã‚¯ãƒªãƒƒã‚¯ã§ç·¨é›†</div>

    <div class="ui-header">ã‚µã‚¤ã‚º</div>
    <div class="ui-row">
      <label>è¡¨ç¤ºã‚µã‚¤ã‚º</label>
      <span id="img-size-display" class="val" style="width:auto; font-weight:500;">-</span>
    </div>

    <div class="ui-header">ä½ç½®èª¿æ•´</div>
    <div class="nudge-pad">
      <button class="nudge-btn" onclick="nudgeSelection(0, -1)">â–²</button>
      <div class="nudge-row">
        <button class="nudge-btn" onclick="nudgeSelection(-1, 0)">â—€</button>
        <button class="nudge-btn nudge-reset" onclick="nudgeSelection(0, 0, true)">RST</button>
        <button class="nudge-btn" onclick="nudgeSelection(1, 0)">â–¶</button>
      </div>
      <button class="nudge-btn" onclick="nudgeSelection(0, 1)">â–¼</button>
    </div>

    <div class="ui-header">ãƒœãƒƒã‚¯ã‚¹æ“ä½œ</div>
    <button class="action-btn danger-btn" onclick="deleteSelectedBox()">ã“ã®ãƒœãƒƒã‚¯ã‚¹ã‚’å‰Šé™¤</button>
  </div>

  <!-- é¡Œå­—è¨­å®š -->
  <div id="panel-header" class="panel-section">
    <div class="ui-header">é¡Œå­—</div>
    <div class="ui-row"><label>æ–°èå</label><input type="text" id="hdr-title" oninput="updateHeaderAttr()" placeholder="æ–°èå"></div>
    <div class="ui-row">
      <label>ãƒ•ã‚©ãƒ³ãƒˆ</label>
      <select id="hdr-font" class="font-selector" onchange="updateHeaderAttr()"></select>
    </div>
    
    <div class="ui-header">ãƒ‡ã‚¶ã‚¤ãƒ³</div>
    <div class="ui-row"><label>å¤–æ </label><input type="range" min="0" max="10" value="4" id="hdr-border-out" oninput="updateHeaderAttr()"><input type="number" id="val-hdr-border-out" class="val" value="4" min="0" max="10" step="1" oninput="syncInputValue('val-hdr-border-out','hdr-border-out'); updateHeaderAttr()"></div>
    <div class="ui-row"><label>å†…æ </label><input type="range" min="0" max="10" value="1" id="hdr-border-in" oninput="updateHeaderAttr()"><input type="number" id="val-hdr-border-in" class="val" value="1" min="0" max="10" step="1" oninput="syncInputValue('val-hdr-border-in','hdr-border-in'); updateHeaderAttr()"></div>

    <div class="ui-header">è£…é£¾</div>
    <div class="ui-row"><label>æ–‡å­—åè»¢</label><input type="checkbox" id="hdr-text-inverted" onchange="updateHeaderAttr()"></div>
    <div class="ui-row"><label>ãƒ•ãƒå¤ªã•</label><input type="range" min="0" max="20" step="0.5" value="0" id="hdr-text-stroke" oninput="updateHeaderAttr()"><input type="number" id="val-hdr-text-stroke" class="val" value="0" min="0" max="20" step="0.5" oninput="syncInputValue('val-hdr-text-stroke','hdr-text-stroke'); updateHeaderAttr()"></div>

    <div class="ui-header">é¡Œå­—ä½ç½®</div>
    <div class="nudge-pad">
      <button class="nudge-btn" onclick="nudgeHeaderTitle(0, -1)">â–²</button>
      <div class="nudge-row">
        <button class="nudge-btn" onclick="nudgeHeaderTitle(-1, 0)">â—€</button>
        <button class="nudge-btn nudge-reset" onclick="nudgeHeaderTitle(0, 0, true)">RST</button>
        <button class="nudge-btn" onclick="nudgeHeaderTitle(1, 0)">â–¶</button>
      </div>
      <button class="nudge-btn" onclick="nudgeHeaderTitle(0, 1)">â–¼</button>
    </div>

    <div class="ui-row"><label>ä½™ç™½(ä¸Šä¸‹)</label><input type="range" min="0" max="100" value="10" id="hdr-pad-v" oninput="updateHeaderAttr()"><input type="number" id="val-hdr-pad-v" class="val" value="10" min="0" max="100" step="1" oninput="syncInputValue('val-hdr-pad-v','hdr-pad-v'); updateHeaderAttr()"></div>
    <div class="ui-row"><label>ä½™ç™½(å·¦å³)</label><input type="range" min="0" max="100" value="5" id="hdr-pad-h" oninput="updateHeaderAttr()"><input type="number" id="val-hdr-pad-h" class="val" value="5" min="0" max="100" step="1" oninput="syncInputValue('val-hdr-pad-h','hdr-pad-h'); updateHeaderAttr()"></div>

    <div class="ui-header">æ ä½ç½®</div>
    <div class="nudge-pad">
      <button class="nudge-btn" onclick="nudgeSelection(0, -1)">â–²</button>
      <div class="nudge-row">
        <button class="nudge-btn" onclick="nudgeSelection(-1, 0)">â—€</button>
        <button class="nudge-btn nudge-reset" onclick="nudgeSelection(0, 0, true)">RST</button>
        <button class="nudge-btn" onclick="nudgeSelection(1, 0)">â–¶</button>
      </div>
      <button class="nudge-btn" onclick="nudgeSelection(0, 1)">â–¼</button>
    </div>

    <div class="ui-header">ãƒœãƒƒã‚¯ã‚¹æ“ä½œ</div>
    <button class="action-btn danger-btn" onclick="deleteSelectedBox()">ã“ã®ãƒœãƒƒã‚¯ã‚¹ã‚’å‰Šé™¤</button>
  </div>

  <!-- è¦‹å‡ºã—è¨­å®š -->
  <div id="panel-headline" class="panel-section">
    <div class="ui-header">è¦‹å‡ºã—ã®èª¿æ•´</div>
    <div class="nudge-pad">
      <button class="nudge-btn" onclick="nudgeSelection(0, -1)">â–²</button>
      <div class="nudge-row">
        <button class="nudge-btn" onclick="nudgeSelection(-1, 0)">â—€</button>
        <button class="nudge-btn nudge-reset" onclick="nudgeSelection(0, 0, true)">RST</button>
        <button class="nudge-btn" onclick="nudgeSelection(1, 0)">â–¶</button>
      </div>
      <button class="nudge-btn" onclick="nudgeSelection(0, 1)">â–¼</button>
    </div>
    <div class="ui-header">ã‚¹ã‚¿ã‚¤ãƒ«</div>
    <div class="ui-row"><label>ç™½é»’åè»¢</label><input type="checkbox" id="hl-inverted" onchange="updateHeadlineAttr()"></div>
    <div class="ui-row"><label>ãƒ•ã‚©ãƒ³ãƒˆ</label><select id="hl-font" class="font-selector" onchange="updateHeadlineAttr()"></select></div>
    <div class="ui-row"><label>å¤ªã•</label><select id="hl-weight" onchange="updateHeadlineAttr()"><option value="400">æ¨™æº–</option><option value="700" selected>å¤ªå­—</option><option value="900">æ¥µå¤ª</option></select></div>
    <div class="ui-row"><label>ä½™ç™½(é•·è¾º)</label><input type="range" min="0" max="50" step="1" value="0" id="hl-pad-long" oninput="updateHeadlineAttr()"><input type="number" id="val-hl-pad-long" class="val" value="0" min="0" max="50" step="1" oninput="syncInputValue('val-hl-pad-long','hl-pad-long'); updateHeadlineAttr()"></div>
    <div class="ui-row"><label>ä½™ç™½(çŸ­è¾º)</label><input type="range" min="0" max="50" step="1" value="0" id="hl-pad-short" oninput="updateHeadlineAttr()"><input type="number" id="val-hl-pad-short" class="val" value="0" min="0" max="50" step="1" oninput="syncInputValue('val-hl-pad-short','hl-pad-short'); updateHeadlineAttr()"></div>

    <div class="ui-header">ãƒœãƒƒã‚¯ã‚¹æ“ä½œ</div>
    <button class="action-btn danger-btn" onclick="deleteSelectedBox()">ã“ã®ãƒœãƒƒã‚¯ã‚¹ã‚’å‰Šé™¤</button>
  </div>

  <!-- ç¸¦ç·šè¨­å®š -->
  <div id="panel-vline" class="panel-section">
    <div class="ui-header">ç¸¦ç·šã®èª¿æ•´</div>
    <div class="nudge-pad">
      <button class="nudge-btn" onclick="nudgeSelection(0, -1)">â–²</button>
      <div class="nudge-row">
        <button class="nudge-btn" onclick="nudgeSelection(-1, 0)">â—€</button>
        <button class="nudge-btn nudge-reset" onclick="nudgeSelection(0, 0, true)">RST</button>
        <button class="nudge-btn" onclick="nudgeSelection(1, 0)">â–¶</button>
      </div>
      <button class="nudge-btn" onclick="nudgeSelection(0, 1)">â–¼</button>
    </div>
    <div class="ui-header">å¤ªã•</div>
    <div class="ui-row"><label>ç·šã®å¤ªã•</label><input type="range" min="1" max="10" step="1" value="2" id="vl-width" oninput="updateVlineAttr()"><input type="number" id="val-vl-width" class="val" value="2" min="1" max="10" step="1" oninput="syncInputValue('val-vl-width','vl-width'); updateVlineAttr()"></div>

    <div class="ui-header">ãƒœãƒƒã‚¯ã‚¹æ“ä½œ</div>
    <button class="action-btn danger-btn" onclick="deleteSelectedBox()">ã“ã®ãƒœãƒƒã‚¯ã‚¹ã‚’å‰Šé™¤</button>
  </div>
  
  <!-- ä¿®æ­£ãƒ†ãƒ¼ãƒ—è¨­å®š -->
  <div id="panel-correction" class="panel-section">
    <div class="ui-header">å¡—ã‚Šã¤ã¶ã—</div>
    <div class="nudge-pad">
      <button class="nudge-btn" onclick="nudgeSelection(0, -1)">â–²</button>
      <div class="nudge-row">
        <button class="nudge-btn" onclick="nudgeSelection(-1, 0)">â—€</button>
        <button class="nudge-btn nudge-reset" onclick="nudgeSelection(0, 0, true)">RST</button>
      <button class="nudge-btn" onclick="nudgeSelection(1, 0)">â–¶</button>
      </div>
      <button class="nudge-btn" onclick="nudgeSelection(0, 1)">â–¼</button>
    </div>
    <div class="ui-header">è‰²</div>
    <div class="ui-row">
        <label>å¡—ã‚Šè‰²</label>
        <select id="corr-fill-mode" onchange="updateCorrectionAttr()">
            <option value="paper">ç´™è‰²</option>
            <option value="ink">ã‚¤ãƒ³ã‚¯è‰²</option>
        </select>
    </div>

    <div class="ui-header">æ ç·š</div>
    <div class="ui-row">
        <label>ã‚¹ã‚¿ã‚¤ãƒ«</label>
        <select id="corr-border-style" onchange="updateCorrectionAttr()">
            <option value="none">ãªã—</option>
            <option value="solid">å®Ÿç·š</option>
            <option value="dotted">ç‚¹ç·š</option>
            <option value="double">äºŒé‡ç·š</option>
        </select>
    </div>
    <div class="ui-row">
        <label>å¤ªã•</label>
        <input type="range" min="0" max="10" step="0.5" value="2" id="corr-border-width" oninput="updateCorrectionAttr()">
        <input type="number" id="val-corr-border-width" class="val" value="2" min="0" max="10" step="0.5" oninput="syncInputValue('val-corr-border-width','corr-border-width'); updateCorrectionAttr()">
    </div>
    <div class="calc-info">å·¦å³ã¯è¡Œé–“ã¶ã‚“ã®ä½™ç™½ã‚’ç¢ºä¿ã—ã¾ã™</div>

    <div class="ui-header">ãƒœãƒƒã‚¯ã‚¹æ“ä½œ</div>
    <button class="action-btn danger-btn" onclick="deleteSelectedBox()">ã“ã®ãƒœãƒƒã‚¯ã‚¹ã‚’å‰Šé™¤</button>
  </div>

  <!-- è‡ªç”±ãƒ†ã‚­ã‚¹ãƒˆè¨­å®š -->
  <div id="panel-free-text" class="panel-section">
    <div class="ui-header">è‡ªç”±ãƒ†ã‚­ã‚¹ãƒˆ</div>
    <div class="calc-info">å¡—ã‚Šã¤ã¶ã—ã‚ˆã‚Šä¸Šã®ãƒ¬ã‚¤ãƒ¤ãƒ¼ã§è¡¨ç¤º</div>

    <div class="ui-header">æ–‡å­—</div>
    <div class="ui-row"><label>ãƒ•ã‚©ãƒ³ãƒˆ</label><select id="ft-font" class="font-selector" onchange="updateFreeTextAttr()"></select></div>
    <div class="ui-row">
      <label>å¤ªã•</label>
      <input type="range" min="100" max="900" step="100" value="400" id="ft-weight" oninput="updateFreeTextAttr()">
      <input type="number" id="val-ft-weight" class="val" value="400" min="100" max="900" step="100" oninput="syncInputValue('val-ft-weight','ft-weight'); updateFreeTextAttr()">
    </div>
    <div class="ui-row">
      <label>ã‚µã‚¤ã‚º</label>
      <input type="range" min="8" max="1000" step="1" value="24" id="ft-size" oninput="updateFreeTextAttr()">
      <input type="number" id="val-ft-size" class="val" value="24" min="8" max="1000" step="1" oninput="syncInputValue('val-ft-size','ft-size'); updateFreeTextAttr()">
    </div>
    <div class="ui-row">
      <label>å­—é–“</label>
      <input type="range" min="-5" max="20" step="0.5" value="0" id="ft-letter" oninput="updateFreeTextAttr()">
      <input type="number" id="val-ft-letter" class="val" value="0" min="-5" max="20" step="0.5" oninput="syncInputValue('val-ft-letter','ft-letter'); updateFreeTextAttr()">
    </div>
    <div class="ui-row">
      <label>ã‚¹ã‚¿ã‚¤ãƒ«</label>
      <select id="ft-style" onchange="updateFreeTextAttr()">
        <option value="ink">ã‚¤ãƒ³ã‚¯è‰²</option>
        <option value="paper">ç´™è‰²</option>
        <option value="outline">è¢‹æ–‡å­—</option>
      </select>
    </div>
    <div class="ui-row">
      <label>æ å¤ªã•</label>
      <input type="range" min="0" max="25" step="0.5" value="1.5" id="ft-stroke-width" oninput="updateFreeTextAttr()">
      <input type="number" id="val-ft-stroke-width" class="val" value="1.5" min="0" max="25" step="0.5" oninput="syncInputValue('val-ft-stroke-width','ft-stroke-width'); updateFreeTextAttr()">
    </div>
    <div class="ui-row"><label>ç¸¦ä¸­æ¨ª</label><input type="checkbox" id="ft-tcy" checked onchange="updateFreeTextAttr()"></div>

    <div class="ui-header">æ–¹å‘</div>
    <div class="ui-row">
      <label>æ›¸å­—æ–¹å‘</label>
      <select id="ft-writing" onchange="updateFreeTextAttr()">
        <option value="vertical">ç¸¦æ›¸ã</option>
        <option value="horizontal">æ¨ªæ›¸ã</option>
      </select>
    </div>

    <div class="ui-header">é…ç½®</div>
    <div class="btn-group-row">
      <button class="btn-group-item" id="ft-align-tl" onclick="setFreeTextAlign('top-left')">å·¦ä¸Š</button>
      <button class="btn-group-item" id="ft-align-tc" onclick="setFreeTextAlign('top')">ä¸­å¤®ä¸Š</button>
      <button class="btn-group-item" id="ft-align-tr" onclick="setFreeTextAlign('top-right')">å³ä¸Š</button>
    </div>
    <div class="btn-group-row">
      <button class="btn-group-item" id="ft-align-ml" onclick="setFreeTextAlign('left')">å·¦ä¸­</button>
      <button class="btn-group-item" id="ft-align-mc" onclick="setFreeTextAlign('center')">ä¸­å¤®</button>
      <button class="btn-group-item" id="ft-align-mr" onclick="setFreeTextAlign('right')">å³ä¸­</button>
    </div>
    <div class="btn-group-row">
      <button class="btn-group-item" id="ft-align-bl" onclick="setFreeTextAlign('bottom-left')">å·¦ä¸‹</button>
      <button class="btn-group-item" id="ft-align-bc" onclick="setFreeTextAlign('bottom')">ä¸­å¤®ä¸‹</button>
      <button class="btn-group-item" id="ft-align-br" onclick="setFreeTextAlign('bottom-right')">å³ä¸‹</button>
    </div>

    <div class="ui-header">ãƒœãƒƒã‚¯ã‚¹æ“ä½œ</div>
    <button class="action-btn danger-btn" onclick="deleteSelectedBox()">ã“ã®ãƒœãƒƒã‚¯ã‚¹ã‚’å‰Šé™¤</button>
    <div class="calc-info">ãƒ€ãƒ–ãƒ«ã‚¯ãƒªãƒƒã‚¯ã§ç·¨é›†</div>
  </div>
</div>

<div id="viewport">
  <div id="canvas-transform">
    <div class="paper">
      
      <!-- å¤–å‘¨æƒ…å ± (Top) -->
      <div class="margin-info-container" id="margin-info-top">
          <div class="margin-info-item" id="info-left"></div>
          <div class="margin-info-item" id="info-center"></div>
          <div class="margin-info-item" id="info-right"></div>
      </div>
      
      <!-- ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆæ ãƒ¬ã‚¤ãƒ¤ãƒ¼ (å¤–å‘¨æ : æœ€å‰é¢) -->
      <svg id="layout-border-layer"></svg>
      
      <!-- ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆç·šãƒ¬ã‚¤ãƒ¤ãƒ¼ (æ®µé–“ç½«ç·š: èƒŒé¢) -->
      <svg id="layout-lines-layer"></svg>
      
      <div class="hanmen" id="hanmen">
        <div id="grid-layer"></div>
        <svg id="link-layer">
          <path id="temp-link-line" d=""></path>
        </svg>
      </div>

      <!-- ã‚«ãƒ©ãƒ¼ãƒ‘ãƒƒãƒ (Bottom) -->
      <div id="color-patches-bottom">
          <!-- JSã§æç”» -->
      </div>

    </div>
  </div>
</div>
<div id="measure-box"></div>
<div id="text-measure-box"></div>
<div id="header-measure-box"></div>

<script>
  // --- ã‚¹ãƒ©ã‚¤ãƒ€ãƒ¼ã¨æ•°å€¤å…¥åŠ›ã®é€£å‹•ãƒ˜ãƒ«ãƒ‘ãƒ¼ ---
  function syncSliderValue(sliderId, inputId) {
    const slider = document.getElementById(sliderId);
    const input = document.getElementById(inputId);
    if (!slider || !input) return;

    // ã‚¹ãƒ©ã‚¤ãƒ€ãƒ¼ã‹ã‚‰å…¥åŠ›ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã«åæ˜ 
    input.value = slider.value;
  }

  function syncInputValue(inputId, sliderId) {
    const slider = document.getElementById(sliderId);
    const input = document.getElementById(inputId);
    if (!slider || !input) return;

    const min = parseFloat(slider.min);
    const max = parseFloat(slider.max);
    let val = parseFloat(input.value);

    // ç¯„å›²ãƒã‚§ãƒƒã‚¯
    if (!isNaN(val)) {
      if (val < min) val = min;
      if (val > max) val = max;
      slider.value = val;
      input.value = val;
    }
  }

  // --- ãƒ•ã‚©ãƒ³ãƒˆè¨­å®š ---
  const fontOptions = [
    { label: "--- æ˜æœä½“ (Mincho) ---", options: [
      { val: '"BIZ UDMincho", serif', label: "BIZ UDæ˜æœ (æ¨™æº–)" },
      { val: '"Noto Serif JP", serif', label: "Noto Serif JP" }
    ]},
    { label: "--- ã‚´ã‚·ãƒƒã‚¯ä½“ (Gothic) ---", options: [
      { val: '"Noto Sans JP", sans-serif', label: "Noto Sans JP (æ¨™æº–)" }
    ]},
    { label: "--- ç­†æ›¸ä½“ (Brush) ---", options: [
      { val: '"Yuji Syuku", serif', label: "ä½‘å­— å®¿ (ã‚¯ãƒ©ã‚·ãƒƒã‚¯)" }
    ]}
  ];

  function updateFontSelectors() {
      const selectors = document.querySelectorAll('.font-selector');
      selectors.forEach(sel => {
          sel.innerHTML = "";
          fontOptions.forEach(group => {
              const optGroup = document.createElement('optgroup');
              optGroup.label = group.label;
              group.options.forEach(opt => {
                  const option = document.createElement('option');
                  option.value = opt.val;
                  option.innerText = opt.label;
                  optGroup.appendChild(option);
              });
              sel.appendChild(optGroup);
          });
      });
      // å¤–å‘¨æƒ…å ±ç”¨ãƒ•ã‚©ãƒ³ãƒˆã¯åˆæœŸå€¤å¤‰æ›´
      document.getElementById('marg-font').value = '"Noto Sans JP", sans-serif';
  }

  const FONT_FAMILY_BLACKLIST = new Set(['serif', 'sans-serif', 'cursive', 'fantasy', 'monospace', 'system-ui', 'ui-serif', 'ui-sans-serif', 'ui-rounded', 'ui-monospace', 'emoji', 'math']);

  function normalizeFontFamily(raw) {
      if (!raw) return null;
      const parts = raw.split(',');
      if (parts.length === 0) return null;
      const primary = parts[0].trim().replace(/^["']|["']$/g, '');
      if (!primary) return null;
      if (FONT_FAMILY_BLACKLIST.has(primary.toLowerCase())) return null;
      return `"${primary}"`;
  }

  async function ensureWebFontsLoaded() {
      if (!document.fonts || !document.fonts.load) return;
      const familyCandidates = new Set();
      const addFamily = (value) => {
          const normalized = normalizeFontFamily(value);
          if (normalized) familyCandidates.add(normalized);
      };
      addFamily(config.fontFamily);
      fontOptions.forEach(group => group.options.forEach(opt => addFamily(opt.val)));
      const loadPromises = [];
      familyCandidates.forEach(family => {
          loadPromises.push(document.fonts.load(`16px ${family}`));
      });
      if (loadPromises.length === 0) return;
      await Promise.allSettled(loadPromises);
  }

  // --- è¨­å®š ---
  let config = {
    baseFontSize: 24, charsPerDan: 11, charsGap: 1.0, pageDanCount: 8, rowsPerDan: 40,
    marginTop: 20, marginBottom: 20, marginInner: 20, marginOuter: 20,
    nudgeX: 0, nudgeY: 0, glyphScale: 1.0, lineGap: 12,
    fontFamily: '"BIZ UDMincho", serif', fontWeight: 400,
    paperPreset: 'A3',
    // ç”¨ç´™ã‚µã‚¤ã‚º
    paperW: 297, paperH: 420,

    gridColor: "#dddddd", paperColor: "#fcfcfc", textColor: "#111111",
    borderColor: "#000000", borderWidth: 1.0, dividerColor: "#000000", dividerWidth: 1.0,

    // å¤–å‘¨æƒ…å ±è¨­å®š (å€‹åˆ¥åŒ–)
    marginalia: {
        left: { 
            text: new Date().toLocaleDateString('ja-JP', {year:'numeric', month:'2-digit', day:'2-digit'}), 
            font: '"Noto Sans JP", sans-serif', 
            size: 12, spacing: 2, weight: 400 
        },
        center: { 
            text: "ï¼ˆæ–°èåæ‰‹å…¥åŠ›ï¼‰", 
            font: '"Noto Sans JP", sans-serif', 
            size: 12, spacing: 2, weight: 400 
        },
        right: { 
            text: "ã€‡ã€‡ã«ã¤ã„ã¦è€ƒãˆã‚‹", 
            font: '"Noto Sans JP", sans-serif', 
            size: 12, spacing: 2, weight: 400 
        }
    }
  };
  
  // ç·¨é›†ä¸­ã®å¤–å‘¨ãƒ–ãƒ­ãƒƒã‚¯
  let currentMarginaliaTarget = 'left';

  const SCALE_Y = 0.85;
  const PX_PER_MM = 3.78;

  let baseHDan, baseHGap, baseHUnit; 
  let physicalHDan, physicalHGap, physicalHUnit;
  let linePitch;

  let groups = [];
  let undoStack = []; let redoStack = []; const HISTORY_LIMIT = 100;
  let currentFileName = "shinbun_data.json";
  // let isExportFlatten = false; // å»ƒæ­¢: å¸¸ã«è¦‹ãŸç›®é€šã‚Šã«å‡ºåŠ›ã™ã‚‹

  // Viewport
  let viewX = 50, viewY = 50, viewScale = 0.6;
  let currentTool = 'hand'; 
  let isMouseDown = false, isDragging = false; 
  let activePointerId = null; // for touch/stylus/mouse unified handling
  const activePointers = new Map(); // pointerId -> {x,y}
  const previousPointers = new Map(); // pointerId -> {x,y}
  let isPinching = false, pinchStartDist = 0, pinchStartScale = 1, pinchCenter = { x: 0, y: 0 }, pinchPrevCenter = null, pinchPrevDist = 0;
  const TOUCH_PAN_FACTOR = 0.65; // dampen touch pan so movement tracks finger better
  const DRAG_THRESHOLD = 10;
  let lastTapTime = 0, lastTapPos = { x: 0, y: 0 }, lastTapTargetId = null;
  let opMode = 'none';
  let startX, startY, startViewX, startViewY, dragStartX, dragStartY;
  let initialElemX, initialElemY, anchorRight, anchorTop, anchorLeft, anchorBottom;
  let targetId = null, ghost = null, selectedId = null;
  let resizeCorner = 'br'; // ãƒªã‚µã‚¤ã‚ºæ“ä½œã®ã‚³ãƒ¼ãƒŠãƒ¼ (tl, tr, bl, br)
  let linkingSourceId = null, linkingStartX = 0, linkingStartY = 0;
  let linkingSourceType = null;
  let anchorSnapX = 0, anchorSnapY = 0;
  let editingGroupId = null; 
  let isFreeCreationMode = false; 
  let isDirty = false; // å¤‰æ›´æ¤œçŸ¥
  let pointerMovedSinceDown = false;
  let selectionMovedSinceDown = false;
  let previousToolOnMiddle = null;

  // ãƒ“ãƒ¥ãƒ¼çŠ¶æ…‹ï¼ˆã‚ºãƒ¼ãƒ ãƒ»ãƒ‘ãƒ³ï¼‰ã‚’ä¿å­˜ï¼å¾©å…ƒã™ã‚‹ãŸã‚ã®ç®¡ç†ãƒ•ãƒ©ã‚°
  let hasRestoredCanvasView = false;

  function getCanvasState() {
      return {
          viewX,
          viewY,
          viewScale,
          paperW: config.paperW,
          paperH: config.paperH,
      };
  }

  function applyCanvasState(state) {
      if (!state) return false;
      const { viewX: vx, viewY: vy, viewScale: vs, paperW, paperH } = state;
      
      // ç”¨ç´™ã‚µã‚¤ã‚ºã‚‚ä¿å­˜ã•ã‚Œã¦ã„ã‚‹å ´åˆã¯åæ˜ ï¼ˆã‚«ã‚¹ã‚¿ãƒ /ç¸¦æ¨ªã‚’ãã®ã¾ã¾å¾©å…ƒï¼‰
      const hasPaper = [paperW, paperH].every(v => typeof v === 'number' && isFinite(v));
      if (hasPaper) {
          config.paperW = paperW;
          config.paperH = paperH;
          const wInput = document.getElementById('paper-w-mm');
          const hInput = document.getElementById('paper-h-mm');
          if (wInput) wInput.value = paperW;
          if (hInput) hInput.value = paperH;
      }

      const hasView = [vx, vy, vs].every(v => typeof v === 'number' && isFinite(v));
      if (hasView) {
          viewX = vx; viewY = vy; viewScale = vs;
          updateTransform();
      }
      return hasView;
  }

  function hideLaunchScreen() {
      const screen = document.getElementById('launch-screen');
      if (!screen) return;
      screen.classList.add('loaded');
      setTimeout(() => {
          if (screen.parentNode) screen.parentNode.removeChild(screen);
      }, 500);
  }

  const viewport = document.getElementById('viewport');
  const canvasTransform = document.getElementById('canvas-transform');
  const hanmen = document.getElementById('hanmen');
  const gridLayer = document.getElementById('grid-layer');
  const layoutLinesLayer = document.getElementById('layout-lines-layer');
  const layoutBorderLayer = document.getElementById('layout-border-layer');
  const linkLayer = document.getElementById('link-layer');
  const tempLinkLine = document.getElementById('temp-link-line');
  const measureBox = document.getElementById('measure-box');
  const hlMeasureBox = document.getElementById('text-measure-box');
  const headerMeasureBox = document.getElementById('header-measure-box');
  const root = document.documentElement;
  const overflowStatusText = document.getElementById('overflow-status-text');
  const svgFiltersContainer = document.getElementById('svg-filters-container');
  function setInitialViewportVars() {
    root.style.setProperty('--initial-vh', `${window.innerHeight}px`);
  }
  setInitialViewportVars();
  window.addEventListener('orientationchange', () => {
    setTimeout(setInitialViewportVars, 300);
  });
  document.addEventListener('focusin', () => {
    window.scrollTo(0, 0);
  });
  document.addEventListener('focusout', () => {
    window.scrollTo(0, 0);
  });
  function clearPortHighlights() { document.querySelectorAll('.port').forEach(p => p.classList.remove('link-mode-compatible','port-hovered')); }
  function highlightCompatiblePorts(sourceId) {
      clearPortHighlights();
      const selector = (linkingSourceType === 'in') ? '.port-out' : '.port-in';
      document.querySelectorAll(selector).forEach(p => {
          const gid = p.closest('.article-group')?.dataset.id;
          if (!gid || gid === sourceId) return;
          // æ¥ç¶šå…ˆã¯æœªæ¥ç¶šã®ã‚‚ã®ã ã‘ã‚’ãƒã‚¤ãƒ©ã‚¤ãƒˆï¼ˆèµ¤/é’ã‚¯ãƒªãƒƒã‚¯æ™‚ã«ç·‘/é»„ã¯é™¤å¤–ï¼‰
          if (selector === '.port-in' && p.classList.contains('connected')) return;
          if (selector === '.port-out' && p.classList.contains('linked')) return;
          p.classList.add('link-mode-compatible');
      });
  }
  function updatePatternColor() {
      const patLine = document.querySelector('#pat-lines line');
      if (patLine) patLine.setAttribute('stroke', config.textColor || '#000');
  }
  function applyConfigToUI() {
      // ç”¨ç´™ãƒ»ãƒãƒ¼ã‚¸ãƒ³
      if (document.getElementById('paper-preset') && config.paperPreset) document.getElementById('paper-preset').value = config.paperPreset;
      if (document.getElementById('paper-w-mm')) document.getElementById('paper-w-mm').value = config.paperW;
      if (document.getElementById('paper-h-mm')) document.getElementById('paper-h-mm').value = config.paperH;
      if (document.getElementById('margin-top')) document.getElementById('margin-top').value = config.marginTop;
      if (document.getElementById('margin-bottom')) document.getElementById('margin-bottom').value = config.marginBottom;
      if (document.getElementById('margin-left')) document.getElementById('margin-left').value = config.marginOuter;
      if (document.getElementById('margin-right')) document.getElementById('margin-right').value = config.marginInner;
      
      // ç´™é¢ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆè¨­å®š
      if (document.getElementById('paper-dan-count')) {
          document.getElementById('paper-dan-count').value = config.pageDanCount;
          document.getElementById('val-paper-dan-count').value = config.pageDanCount;
      }
      if (document.getElementById('paper-rows-per-dan')) {
          document.getElementById('paper-rows-per-dan').value = config.rowsPerDan;
          document.getElementById('val-paper-rows-per-dan').value = config.rowsPerDan;
      }
      if (document.getElementById('paper-chars-per-dan')) {
          document.getElementById('paper-chars-per-dan').value = config.charsPerDan;
          document.getElementById('val-paper-chars-per-dan').value = config.charsPerDan;
      }

      // è‰²ãƒ»ç·š
      if (document.getElementById('inp-grid-color')) document.getElementById('inp-grid-color').value = config.gridColor;
      if (document.getElementById('inp-paper-color')) document.getElementById('inp-paper-color').value = config.paperColor;
      if (document.getElementById('inp-text-color')) document.getElementById('inp-text-color').value = config.textColor;
      if (document.getElementById('inp-border-width')) { document.getElementById('inp-border-width').value = config.borderWidth; document.getElementById('val-border-width').value = config.borderWidth; }
      if (document.getElementById('inp-divider-width')) { document.getElementById('inp-divider-width').value = config.dividerWidth; document.getElementById('val-divider-width').value = config.dividerWidth; }
      // ã‚°ãƒªãƒƒãƒ‰è¡¨ç¤º
      if (document.getElementById('chk-grid')) document.getElementById('chk-grid').checked = true;
      // ãƒ•ã‚©ãƒ³ãƒˆã¨å­—å½¢å€ç‡ãƒ»å¤ªã•
      if (document.getElementById('inp-font')) document.getElementById('inp-font').value = config.fontFamily;
      if (document.getElementById('inp-font-weight')) { document.getElementById('inp-font-weight').value = config.fontWeight; document.getElementById('val-font-weight').value = config.fontWeight; }
      if (document.getElementById('inp-glyph-scale')) { document.getElementById('inp-glyph-scale').value = config.glyphScale; document.getElementById('val-glyph-scale').value = config.glyphScale; }
      // å¤–å‘¨æƒ…å ±ï¼ˆç¾åœ¨é¸æŠä¸­ã®ã‚¿ãƒ¼ã‚²ãƒƒãƒˆã«åæ˜ ï¼‰
      if (document.getElementById('marg-text')) document.getElementById('marg-text').value = config.marginalia[currentMarginaliaTarget].text;
      if (document.getElementById('marg-font')) document.getElementById('marg-font').value = config.marginalia[currentMarginaliaTarget].font;
      if (document.getElementById('marg-size')) { document.getElementById('marg-size').value = config.marginalia[currentMarginaliaTarget].size; document.getElementById('val-marg-size').value = config.marginalia[currentMarginaliaTarget].size; }
      if (document.getElementById('marg-weight')) { document.getElementById('marg-weight').value = config.marginalia[currentMarginaliaTarget].weight || 400; document.getElementById('val-marg-weight').value = config.marginalia[currentMarginaliaTarget].weight || 400; }
      if (document.getElementById('marg-spacing')) { document.getElementById('marg-spacing').value = config.marginalia[currentMarginaliaTarget].spacing; document.getElementById('val-marg-spacing').value = config.marginalia[currentMarginaliaTarget].spacing; }
  }

  // ãƒˆãƒªãƒŸãƒ³ã‚°ç”¨å¤‰æ•°
  let cropCanvas = document.getElementById('crop-canvas');
  let cropCtx = cropCanvas.getContext('2d');
  let cropImageObj = null;
  let cropState = { scale: 1.0, x: 0, y: 0, minScale: 1.0 };
  let isCropDragging = false;
  let cropStartX=0, cropStartY=0;
  let cropStartState = { x: 0, y: 0 };
  const MAX_IMG_SIZE = 2400; // px: ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰æ™‚ã«è»½ããƒªã‚µã‚¤ã‚ºã™ã‚‹æœ€å¤§ä¸€è¾ºï¼ˆç”»è³ªé‡è¦–ï¼‰
  const STORAGE_LIMIT_BYTES = 4.5 * 1024 * 1024; // autosaveç›®æ¨™ä¸Šé™

  // ç”»åƒåœ§ç¸®ï¼ˆãƒªã‚µã‚¤ã‚ºï¼‹å†ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‰ï¼‰ã€‚ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã¯ç”»è³ªå¯„ã‚Šï¼ˆå“è³ª0.9ã€ä¸€è¾ºMAX_IMG_SIZEï¼‰
  async function compressImage(src, maxSize = MAX_IMG_SIZE, quality = 0.9) {
      return new Promise((resolve) => {
          const img = new Image();
          img.onload = () => {
              try {
                  const { width, height } = img;
                  let targetW = width, targetH = height;
                  if (Math.max(width, height) > maxSize) {
                      const scale = maxSize / Math.max(width, height);
                      targetW = Math.round(width * scale);
                      targetH = Math.round(height * scale);
                  }
                  const cvs = document.createElement('canvas');
                  cvs.width = targetW;
                  cvs.height = targetH;
                  const ctx = cvs.getContext('2d');
                  ctx.drawImage(img, 0, 0, targetW, targetH);
                  const out = cvs.toDataURL('image/jpeg', quality);
                  resolve(out);
              } catch(e) {
                  console.error('compressImage failed', e);
                  resolve(src);
              }
          };
          img.onerror = () => resolve(src);
          img.src = src;
      });
  }

  // ç”»åƒã‚’ã‚¤ãƒ³ã‚¯è‰²ã«ãƒãƒƒãƒ—ã™ã‚‹ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£ï¼ˆç™½â†’ç´™è‰²ã€é»’â†’ã‚¤ãƒ³ã‚¯è‰²ï¼‰
  function lerpColor(c1, c2, t) {
      return {
          r: Math.round(c1.r + (c2.r - c1.r) * t),
          g: Math.round(c1.g + (c2.g - c1.g) * t),
          b: Math.round(c1.b + (c2.b - c1.b) * t),
      };
  }
  function hexToRgb(hex) {
      const v = parseInt(hex.slice(1), 16);
      return { r: (v >> 16) & 255, g: (v >> 8) & 255, b: v & 255 };
  }
  function clamp01(v) { return Math.min(1, Math.max(0, v)); }
  // ç”»åƒã‚’ã‚¤ãƒ³ã‚¯è‰²ã«å¤‰æ›ã€‚è‰²å¤‰æ›´ã‚„æ›¸ãå‡ºã—å‰ã«ã‚‚å†è¨ˆç®—ã§ãã‚‹ã‚ˆã†Promiseã§è¿”ã™
  function convertImageToInk(g, shouldRender = true) {
      return new Promise((resolve) => {
          if (!g.imageSrc) { resolve(); return; }
          const img = new Image();
          img.crossOrigin = 'anonymous';
          img.onload = () => {
              try {
                  const cvs = document.createElement('canvas');
                  cvs.width = img.width; cvs.height = img.height;
                  const ctx = cvs.getContext('2d');
                  ctx.drawImage(img, 0, 0);
                  const imgData = ctx.getImageData(0, 0, cvs.width, cvs.height);
                  const data = imgData.data;
                  const paper = hexToRgb(config.paperColor || '#ffffff');
                  const ink = hexToRgb(config.textColor || '#000000');
                  const luma = (c) => (0.299 * c.r + 0.587 * c.g + 0.114 * c.b) / 255;
                  const inkIsDarker = luma(ink) < luma(paper); // trueãªã‚‰ç™½â†’ç´™ã€é»’â†’ã‚¤ãƒ³ã‚¯ã€‚falseãªã‚‰åè»¢ã§ç™½â†’ã‚¤ãƒ³ã‚¯ã€é»’â†’ç´™ã€‚
                  const contrast = g.inkContrast ?? 1.0; // 1.0=é€šå¸¸
                  const bright = g.inkBrightness ?? 0.0; // -1..1
                  for (let i = 0; i < data.length; i += 4) {
                      const r = data[i], gch = data[i+1], b = data[i+2];
                      let lum = (0.299*r + 0.587*gch + 0.114*b) / 255; // 0=é»’,1=ç™½
                      lum = (lum - 0.5) * contrast + 0.5 + bright; // ã‚³ãƒ³ãƒˆãƒ©ã‚¹ãƒˆ/æ˜ã‚‹ã•èª¿æ•´
                      lum = clamp01(lum);
                      const col = inkIsDarker ? lerpColor(ink, paper, lum) : lerpColor(paper, ink, lum);
                      data[i] = col.r; data[i+1] = col.g; data[i+2] = col.b;
                  }
                  ctx.putImageData(imgData, 0, 0);
                  g.imageInkSrc = cvs.toDataURL('image/png');
                  if (shouldRender) renderGroups();
              } catch(e) {
                  console.error("convertImageToInk failed:", e);
              } finally {
                  resolve();
              }
          };
          img.onerror = () => { resolve(); };
          img.src = g.imageSrc;
      });
  }

  // --- åˆæœŸåŒ– ---
  function init() {
    updateFontSelectors();
    selectMarginaliaTarget('left');

    // AutoSaveã®ç¢ºèª
    if (localStorage.getItem('shinbun_autosave_v82')) {
        if(confirm("å‰å›ä½œæ¥­ã—ã¦ã„ãŸå†…å®¹ãŒæ®‹ã£ã¦ã„ã¾ã™ã€‚å¾©å…ƒã—ã¾ã™ã‹ï¼Ÿ")) {
            restoreAutosave();
        } else {
            localStorage.removeItem('shinbun_autosave_v82');
        }
    }

    updatePaperSize(); // ã‚µã‚¤ã‚ºåˆæœŸåŒ–
    if (hasRestoredCanvasView) updateTransform();
    else fitView();
    setTool('hand');
    updateColors();
    isDirty = false;
    hideLaunchScreen();
  }

  // --- ãƒ•ã‚¡ã‚¤ãƒ«æ“ä½œ ---
  function openFileMenu() { document.getElementById('file-menu-overlay').style.display = 'flex'; }
  function openExportMenu() { document.getElementById('export-menu-overlay').style.display = 'flex'; }

  function buildSavePayload(customGroups = groups) {
      return {
          version: "Ver.84",
          timestamp: new Date().toISOString(),
          config: config,
          groups: customGroups,
          fileName: currentFileName,
          canvas: getCanvasState()
      };
  }

  function saveFile(saveAs) {
      let fileName = currentFileName;
      if (saveAs) {
          const input = prompt("ãƒ•ã‚¡ã‚¤ãƒ«åã‚’å…¥åŠ›ã—ã¦ãã ã•ã„", currentFileName);
          if (!input) return; // ã‚­ãƒ£ãƒ³ã‚»ãƒ«
          fileName = input;
          if(!fileName.endsWith(".json")) fileName += ".json";
      }
      currentFileName = fileName;

      const data = buildSavePayload();
      const jsonStr = JSON.stringify(data, null, 2);
      const blob = new Blob([jsonStr], {type: "application/json"});
      
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = fileName;
      a.click();
      URL.revokeObjectURL(url);
      
      isDirty = false;
      document.getElementById('file-menu-overlay').style.display='none';
  }

  function loadFile(input) {
      if (!input.files || !input.files[0]) return;
      const file = input.files[0];
      const reader = new FileReader();
      reader.onload = function(e) {
          try {
              const data = JSON.parse(e.target.result);
              if (data.config && data.groups) {
                  config = data.config;
                  groups = data.groups;
                  currentFileName = file.name;
                  applyConfigToUI();
                  hasRestoredCanvasView = applyCanvasState(data.canvas);
                  updatePaperSize();
                  updateColors();
                  if (!hasRestoredCanvasView) fitView();
                  else updateTransform();
                  isDirty = false;
                  saveToLocalStorage();
              } else {
                  alert("ç„¡åŠ¹ãªãƒ•ã‚¡ã‚¤ãƒ«å½¢å¼ã§ã™ã€‚");
              }
          } catch(err) {
              alert("èª­ã¿è¾¼ã¿ã‚¨ãƒ©ãƒ¼: " + err);
          }
      };
      reader.readAsText(file);
      document.getElementById('file-menu-overlay').style.display='none';
      input.value = '';
  }

  function resetCanvasConfirm() {
      if (confirm("ç¾åœ¨ã®ä½œæ¥­å†…å®¹ã¯å¤±ã‚ã‚Œã¾ã™ã€‚æ–°è¦ä½œæˆã—ã¾ã™ã‹ï¼Ÿ")) {
          groups = [];
          undoStack = []; redoStack = [];
          isDirty = false;
          renderGroups();
          localStorage.removeItem('shinbun_autosave_v82');
          document.getElementById('file-menu-overlay').style.display='none';
      }
  }

  // --- Auto Save (Local Storage) ---
  async function saveToLocalStorage() {
      const baseData = () => buildSavePayload();
      const indicator = (msg = "ä¿å­˜ã—ã¾ã—ãŸ") => {
          const ind = document.getElementById('auto-save-indicator');
          if (!ind) return;
          ind.textContent = msg;
          ind.style.opacity = 1;
          setTimeout(() => { ind.style.opacity = 0; }, 2000);
      };
      const estimateBytes = (obj) => JSON.stringify(obj).length * 2; // UTF-16æ›ç®—ã®ã–ã£ãã‚Šå®¹é‡
      const imageGroups = groups.filter(g => g.type === 'image');

      // æ®µéšçš„ã«åœ§ç¸®ãƒ¬ãƒ™ãƒ«ã‚’ä¸Šã’ã¦4.5MBæœªæº€ã‚’ç›®æŒ‡ã™ï¼ˆã§ãã‚‹ã ã‘å¼±ã„åœ§ç¸®ã‹ã‚‰è©¦ã™ï¼‰
      const compressLevels = [
          { maxSize: 1400, quality: 0.75, label: "å¼±" },
          { maxSize: 1200, quality: 0.65, label: "ä¸­" },
          { maxSize: 1000, quality: 0.55, label: "å¼·" },
          { maxSize: 800,  quality: 0.45, label: "æœ€å¼·" }
      ];

      const buildDataWithCompression = async (level) => {
          const tasks = groups.map(async g => {
              if (g.type !== 'image') return g;
              const compressed = g.imageSrc ? await compressImage(g.imageSrc, level.maxSize, level.quality) : null;
              return { ...g, imageSrc: compressed, originalSrc: compressed, imageInkSrc: null };
          });
          const newGroups = await Promise.all(tasks);
          const data = { ...buildSavePayload(newGroups), autosaveNote: `compress:${level.label}` };
          return { data, size: estimateBytes(data), level };
      };

      try {
          // ã¾ãšã¯ç¾çŠ¶ã®ã¾ã¾ã‚µã‚¤ã‚ºãƒã‚§ãƒƒã‚¯
          let data = baseData();
          let size = estimateBytes(data);
          if (size > STORAGE_LIMIT_BYTES) {
              // åœ§ç¸®æ®µéšã‚’è©¦ã™
              let appliedLevel = null;
              for (const lvl of compressLevels) {
                  const res = await buildDataWithCompression(lvl);
                  data = res.data; size = res.size;
                  appliedLevel = lvl;
                  if (size <= STORAGE_LIMIT_BYTES) break;
              }
              // ãã‚Œã§ã‚‚è¶…ãˆã‚‹å ´åˆã¯ç”»åƒã‚’çœç•¥
              if (size > STORAGE_LIMIT_BYTES) {
                  const slimGroups = groups.map(g => {
                      if (g.type !== 'image') return g;
                      const { imageSrc, imageInkSrc, originalSrc, ...rest } = g;
                      return { ...rest, imageSrc: null, imageInkSrc: null, originalSrc: null, hasImageOmitted: true };
                  });
                  data = { ...buildSavePayload(slimGroups), autosaveNote: "images omitted to fit storage" };
                  size = estimateBytes(data);
                  indicator(`ä¿å­˜ã—ã¾ã—ãŸï¼ˆç”»åƒçœç•¥: ${imageGroups.length}ä»¶ / æ¨å®š ${Math.round(size/1024)} KBï¼‰`);
              } else {
                  indicator(`ä¿å­˜ã—ã¾ã—ãŸï¼ˆç”»åƒ${imageGroups.length}ä»¶ / åœ§ç¸®:${appliedLevel ? appliedLevel.label : "ãªã—"} / ç´„${Math.round(size/1024)} KBï¼‰`);
              }
          } else {
              indicator(`ä¿å­˜ã—ã¾ã—ãŸï¼ˆç”»åƒ${imageGroups.length}ä»¶ / ç´„${Math.round(size/1024)} KBï¼‰`);
          }
          localStorage.setItem('shinbun_autosave_v82', JSON.stringify(data));
      } catch(err) {
          console.error("Auto Save Failed:", err);
          indicator("ä¿å­˜ã«å¤±æ•—ã—ã¾ã—ãŸï¼ˆå®¹é‡ä¸è¶³ï¼‰");
      }
  }

  function restoreAutosave() {
      try {
          const raw = localStorage.getItem('shinbun_autosave_v82');
          if (!raw) return;
          const data = JSON.parse(raw);
          config = data.config;
          groups = data.groups;
          currentFileName = data.fileName || "restored_shinbun.json";
          
          applyConfigToUI();
          hasRestoredCanvasView = applyCanvasState(data.canvas);
          updatePaperSize();
          updateColors();
          isDirty = false;
          console.log("Restored from Autosave");
      } catch(e) {
          console.error("Restore Failed:", e);
      }
  }


  // --- ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆ (html2canvas) ---

// ================================
// Pure SVG export (NO foreignObject)
// ç¸¦æ›¸ãã¯ 1æ–‡å­—ãšã¤åº§æ¨™é…ç½®ï¼ˆæ–¹å¼Aï¼‰
// ================================

// XML escape
function escXML(s) {
  return String(s)
    .replace(/&/g, "&amp;")
    .replace(/</g, "&lt;")
    .replace(/>/g, "&gt;")
    .replace(/"/g, "&quot;")
    .replace(/'/g, "&apos;");
}

// displayText ã®HTMLï¼ˆ<br>, <span class="tcy">ï¼‰ã‚’ tokenåˆ—ã«å¤‰æ›ã™ã‚‹
function htmlToTokens(html) {
  if (!html) return [];
  // <br> ã‚’ \n ã«
  let s = html.replace(/<br\s*\/?>/gi, "\n");

  // tcy span ã‚’ç‰¹æ®Šãƒˆãƒ¼ã‚¯ãƒ³ã«ï¼ˆä¸­èº«ã ã‘æŠœãï¼‰
  // ä¾‹: <span class="tcy">12</span>
  const tokens = [];
  const re = /<span\s+class=["']tcy["']\s*>(.*?)<\/span>/gi;

  let last = 0;
  let m;
  while ((m = re.exec(s)) !== null) {
    const before = s.slice(last, m.index);
    pushTextAsTokens(before, tokens);
    tokens.push({ type: "tcy", value: decodeHtmlEntities(m[1]) });
    last = m.index + m[0].length;
  }
  pushTextAsTokens(s.slice(last), tokens);

  return tokens;

  function pushTextAsTokens(text, out) {
    // ä»–ã®ã‚¿ã‚°ã¯æ¨ã¦ã‚‹ï¼ˆ<b>ç­‰ãŒæ··ã–ã£ã¦ã‚‚è½ã¡ãªã„ã‚ˆã†ã«ï¼‰
    const plain = text.replace(/<[^>]+>/g, "");
    const decoded = decodeHtmlEntities(plain);
    for (const ch of decoded) {
      if (ch === "\n") out.push({ type: "nl" });
      else out.push({ type: "ch", value: ch });
    }
  }

  function decodeHtmlEntities(str) {
    // displayTextã¯å†…éƒ¨ç”Ÿæˆãªã®ã§é‡ããªã„ç¯„å›²ã§DOMã‚’ä½¿ã£ã¦æˆ»ã™
    const ta = document.createElement("textarea");
    ta.innerHTML = str;
    return ta.value;
  }
}

function escXML(s) {
  return String(s)
    .replace(/&/g, "&amp;")
    .replace(/</g, "&lt;")
    .replace(/>/g, "&gt;");
}
function escAttr(s) {
  return String(s)
    .replace(/&/g, "&amp;")
    .replace(/"/g, "&quot;")
    .replace(/</g, "&lt;")
    .replace(/>/g, "&gt;");
}
// "BIZ UDMincho", serif â†’ 'BIZ UDMincho', serif ã«æ­£è¦åŒ–
function toSvgFontFamily(ff) {
  if (!ff) return "'BIZ UDMincho', serif";
  const parts = String(ff).split(",").map(p => p.trim()).filter(Boolean);
  return parts.map(p => {
    const unq = p.replace(/^["']|["']$/g, "");
    return /\s/.test(unq) ? `'${unq}'` : unq;
  }).join(", ");
}

function renderTokensVerticalToSVG(tokens, boxW, boxH_logical, fontSize, lineGap, fontFamily, fontWeight, fill) {
  const pitchX = fontSize + lineGap;
  const pitchY = fontSize + lineGap;
  const cols = Math.max(1, Math.round((boxW + lineGap) / pitchX));
  const rows = Math.max(1, Math.floor(boxH_logical / pitchY));

  let col = 0;
  let row = 0;
  let out = "";

  const ff = toSvgFontFamily(fontFamily);
  const fw = (fontWeight != null) ? String(fontWeight) : "400";
  const fs = `${fontSize}px`;
  const fl = fill || "#111111";

  const pushNewColumn = () => { col++; row = 0; };

  for (const t of tokens) {
    if (t.type === "nl") { pushNewColumn(); continue; }
    if (col >= cols) break;

    const xCenter = (boxW - (fontSize / 2)) - (col * pitchX);
    const yCenter = (fontSize / 2) + (row * pitchY);
    if (!Number.isFinite(xCenter) || !Number.isFinite(yCenter)) break;

    const attrs =
      `x="${xCenter}" y="${yCenter}" ` +
      `text-anchor="middle" dominant-baseline="central" ` +
      `font-family="${escAttr(ff)}" ` +
      `font-weight="${escAttr(fw)}" ` +
      `font-size="${escAttr(fs)}" ` +
      `fill="${escAttr(fl)}"`;

    if (t.type === "tcy") {
      out += `<text ${attrs} textLength="${fontSize}" lengthAdjust="spacingAndGlyphs">${escXML(t.value)}</text>\n`;
    } else {
      out += `<text ${attrs}>${escXML(t.value)}</text>\n`;
    }

    row++;
    if (row >= rows) pushNewColumn();
  }

  return out;
}

function buildPaperSVG(fontCSS) {
  const paperEl = document.querySelector(".paper");
  const W = Math.round(paperEl.offsetWidth);
  const H = Math.round(paperEl.offsetHeight);

  const paperColor = config.paperColor || "#ffffff";
  const textColor  = config.textColor  || "#111111";

  let svg = "";
  svg += `<?xml version="1.0" encoding="UTF-8"?>\n`;
  svg += `<svg xmlns="http://www.w3.org/2000/svg" width="${W}" height="${H}" viewBox="0 0 ${W} ${H}">\n`;

  // âœ… ã“ã“ã« fontCSS ã‚’å…¥ã‚Œã‚‹ï¼ˆAæ–¹å¼ã®æœ¬ä½“ï¼‰
  svg += `<defs>\n`;
  svg += `<style><![CDATA[\n${fontCSS || ""}\n]]></style>\n`;
  svg += `</defs>\n`;

  // âœ… èƒŒæ™¯
  svg += `<rect x="0" y="0" width="${W}" height="${H}" fill="${paperColor}"/>\n`;

  // âœ… ãƒ‡ãƒãƒƒã‚°æ ï¼ˆã“ã‚ŒãŒè¦‹ãˆãªã„ãªã‚‰SVGâ†’PNGçµŒè·¯ãŒå£Šã‚Œã¦ã‚‹ï¼‰
  svg += `<rect x="0" y="0" width="${W}" height="${H}" fill="none" stroke="#000" stroke-width="4"/>\n`;

  // âœ… ãƒ‡ãƒãƒƒã‚°æ–‡å­—
  svg += `<text x="40" y="60" font-size="48" fill="${textColor}">ãƒ†</text>\n`;

  // ã“ã“ã‹ã‚‰å…ˆã¯ groups ã‚’æãï¼ˆã¾ã æœªå®Ÿè£…ãªã‚‰ã€ä»Šã¯ã“ã®ã¾ã¾ã§OKï¼‰
  for (const g of groups) {
    // ã¾ãšã¯ article ã ã‘ã§ã‚‚æãå‡¦ç†ã‚’æˆ»ã™
  }

  svg += `</svg>`;
  return { svg, width: W, height: H };
}


async function exportViaPureSVG(format) {
  document.getElementById("export-menu-overlay").style.display = "none";

  // Aæ–¹å¼ï¼šCSSæ–‡å­—åˆ—ã‚’å—ã‘å–ã‚‹
  const fontCSS = await embedGoogleFonts();

  console.log("fontCSS length:", fontCSS?.length);
  console.log("fontCSS has @font-face:", /@font-face/.test(fontCSS || ""));


  deselectAll();
  document.body.classList.add("preview-mode");

  // å¿µã®ãŸã‚ãƒ•ã‚©ãƒ³ãƒˆãƒ­ãƒ¼ãƒ‰å¾…ã¡
  await document.fonts.ready;
  await new Promise(r => setTimeout(r, 200));

  renderGroups();

  // Aæ–¹å¼ï¼šå¼•æ•°ã§æ¸¡ã™
  const { svg, width, height } = buildPaperSVG(fontCSS);

  const blob = new Blob([svg], { type: "image/svg+xml;charset=utf-8" });
  const url = URL.createObjectURL(blob);

  try {
    const img = new Image();
    img.decoding = "async";

    await new Promise((resolve, reject) => {
      img.onload = resolve;
      img.onerror = reject;
      img.src = url;
    });

    // Safariå¯¾ç­–ï¼šimg.onloadå¾Œã‚‚ãƒ•ã‚©ãƒ³ãƒˆé©ç”¨ãŒé…ã‚Œã‚‹ã“ã¨ãŒã‚ã‚‹ã®ã§å°‘ã—å¾…ã¤ï¼ˆåŠ¹ãã‚±ãƒ¼ã‚¹ãŒã‚ã‚‹ï¼‰
    await new Promise(r => setTimeout(r, 150));

    const scale = 2;
    const canvas = document.createElement("canvas");
    canvas.width = Math.round(width * scale);
    canvas.height = Math.round(height * scale);

    const ctx = canvas.getContext("2d");
    ctx.setTransform(scale, 0, 0, scale, 0, 0);
    ctx.drawImage(img, 0, 0);

    const link = document.createElement("a");
    if (format === "jpg" || format === "jpeg") {
      link.href = canvas.toDataURL("image/jpeg", 0.92);
      link.download = "shinbun.jpg";
    } else {
      link.href = canvas.toDataURL("image/png");
      link.download = "shinbun.png";
    }
    link.click();
  } finally {
    URL.revokeObjectURL(url);
    document.body.classList.remove("preview-mode");
  }
}

async function embedGoogleFonts() {
  console.log("ãƒ•ã‚©ãƒ³ãƒˆåŸ‹ã‚è¾¼ã¿å‡¦ç†ã‚’é–‹å§‹ã—ã¾ã™...");

  if (window.location.protocol === "file:") {
    alert("ã€æ³¨æ„ã€‘file:// ç›´é–‹ãã¯ãƒ•ã‚©ãƒ³ãƒˆåŸ‹ã‚è¾¼ã¿ãŒå‹•ãã¾ã›ã‚“ã€‚Live Serverç­‰ã§é–‹ã„ã¦ãã ã•ã„ã€‚");
    return "";
  }

  // rel=stylesheet ã® Google Fonts ã ã‘
  const links = document.querySelectorAll('link[rel="stylesheet"][href*="fonts.googleapis.com"]');
  console.log(`å‡¦ç†å¯¾è±¡ã®CSSãƒªãƒ³ã‚¯æ•°: ${links.length}`);
  if (links.length === 0) return "";

  // æ—¢ã«åŸ‹ã‚è¾¼ã¿æ¸ˆã¿ãªã‚‰ã€ãã®ä¸­èº«ã‚’è¿”ã™ï¼ˆâ˜…Aæ–¹å¼ï¼‰
  const existing = document.getElementById("embedded-google-fonts");
  if (existing && existing.textContent && existing.textContent.includes("@font-face")) {
    console.log("æ—¢ã«ãƒ•ã‚©ãƒ³ãƒˆã¯åŸ‹ã‚è¾¼ã¿æ¸ˆã¿ã§ã™ã€‚æ—¢å­˜CSSã‚’è¿”ã—ã¾ã™ã€‚");
    return existing.textContent;
  }

  const urlRegex = /url\s*\(\s*(['"]?)(https:\/\/fonts\.gstatic\.com\/[^)'"]+)\1\s*\)/g;

  const allCss = await Promise.all(Array.from(links).map(async (link) => {
    console.log(`CSSå–å¾—ä¸­...: ${link.href}`);
    const cssRes = await fetch(link.href);
    let cssText = await cssRes.text();

    const urls = [];
    let match;
    while ((match = urlRegex.exec(cssText)) !== null) urls.push(match[2]);
    const uniqueUrls = Array.from(new Set(urls));

    const converted = await Promise.all(uniqueUrls.map(async (u) => {
      try {
        const res = await fetch(u);
        const blob = await res.blob();
        const base64 = await new Promise((resolve, reject) => {
          const r = new FileReader();
          r.onloadend = () => resolve(r.result);
          r.onerror = reject;
          r.readAsDataURL(blob);
        });
        return { u, base64 };
      } catch {
        return null;
      }
    }));

    let replacedCount = 0;
    for (const item of converted) {
      if (!item) continue;
      while (cssText.indexOf(item.u) !== -1) {
        cssText = cssText.replace(item.u, item.base64);
        replacedCount++;
      }
    }
    console.log(`å¤‰æ›å®Œäº†: ${replacedCount} ç®‡æ‰€ã®ãƒ•ã‚©ãƒ³ãƒˆURLã‚’Base64åŒ–ã—ã¾ã—ãŸã€‚`);
    return cssText;
  }));

  const finalCss = allCss.join("\n");

  // style ã«ä¿å­˜ï¼ˆãŸã ã— buildPaperSVG ã¯ã‚‚ã†ä¾å­˜ã—ãªã„ï¼‰
  const style = document.createElement("style");
  style.id = "embedded-google-fonts";
  style.textContent = finalCss;
  document.head.appendChild(style);

  console.log("â˜…ãƒ•ã‚©ãƒ³ãƒˆåŸ‹ã‚è¾¼ã¿æˆåŠŸï¼");
  return finalCss; // â˜…ã“ã“ãŒAæ–¹å¼ã®æ ¸
}


async function exportCanvasToImage(format) {
  // Pure SVG å„ªå…ˆï¼ˆã¾ãšã“ã‚Œã§å‹ã¤ï¼‰
  try {
    await exportViaPureSVG(format);
    return;
  } catch (e) {
    console.warn("Pure SVG export failed. Fallback to html2canvas:", e);
    // â†“ ã“ã“ã‹ã‚‰ä¸‹ã¯â€œä¿é™ºâ€ã¨ã—ã¦ html2canvas ã‚’èµ°ã‚‰ã›ã‚‹
  }

  // ====== ã“ã“ã‹ã‚‰å…ˆã¯ã‚ãªãŸã®æ—¢å­˜ html2canvas æ–¹å¼ ======
  document.getElementById('export-menu-overlay').style.display='none';

  await embedGoogleFonts();

  deselectAll();
  document.body.classList.add('preview-mode');

  const inkTasks = [];
  groups.forEach(g => {
    if (g.type === 'image' && g.colorMode === 'ink' && !g.imageInkSrc) {
      inkTasks.push(convertImageToInk(g, false));
    }
  });
  if (inkTasks.length > 0) {
    await Promise.all(inkTasks);
    renderGroups();
  }

  const gridWasVisible = document.getElementById('chk-grid') ? document.getElementById('chk-grid').checked : true;
  const gridPrevDisplay = gridLayer.style.display;
  gridLayer.style.display = 'none';
  gridLayer.style.opacity = 0;

  await document.fonts.ready;
  await new Promise(r => setTimeout(r, 1000));

  renderGroups();

  const paperElement = document.querySelector('.paper');

  const originalTransform = canvasTransform.style.transform;
  const originalLeft = paperElement.style.left;
  const originalTop = paperElement.style.top;
  const originalParent = paperElement.parentNode;
  const originalNext = paperElement.nextSibling;
  const originalBodyOverflow = document.body.style.overflow;
  const originalHtmlOverflow = document.documentElement.style.overflow;

  window.scrollTo(0,0);
  canvasTransform.style.transform = "scale(1)";
  paperElement.style.left = "0px";
  paperElement.style.top = "0px";
  paperElement.style.margin = "0";

  const tempWrapper = document.createElement('div');
  tempWrapper.style.position = 'absolute';
  tempWrapper.style.top = '0';
  tempWrapper.style.left = '0';
  tempWrapper.style.overflow = 'visible';
  tempWrapper.style.zIndex = '-1';
  document.body.appendChild(tempWrapper);
  tempWrapper.appendChild(paperElement);
  document.body.style.overflow = 'visible';
  document.documentElement.style.overflow = 'visible';

  try {
    const canvas = await html2canvas(paperElement, {
      scale: 2,
      useCORS: true,
      allowTaint: true,
      logging: true,
      backgroundColor: null,
      scrollX: 0, scrollY: 0,
      x: 0, y: 0,
      width: paperElement.offsetWidth,
      height: paperElement.offsetHeight,
      windowWidth: paperElement.scrollWidth,
      windowHeight: paperElement.scrollHeight,
      foreignObjectRendering: true,

      onclone: function(clonedDoc) {
        const originalStyle = document.getElementById('embedded-google-fonts');
        if (originalStyle) {
          const newStyle = clonedDoc.createElement('style');
          newStyle.id = 'embedded-google-fonts'; // â†ã“ã‚Œä»˜ã‘ã‚‹ã¨ãƒ‡ãƒãƒƒã‚°ã—ã‚„ã™ã„
          newStyle.textContent = originalStyle.textContent;
          clonedDoc.head.appendChild(newStyle);
        }
        clonedDoc.body.classList.add('preview-mode');
      }
    });

    const link = document.createElement('a');
    if (format === 'png') {
      link.href = canvas.toDataURL('image/png');
      link.download = 'shinbun.png';
    } else {
      link.href = canvas.toDataURL('image/jpeg', 0.9);
      link.download = 'shinbun.jpg';
    }
    link.click();

  } catch (err) {
    alert("æ›¸ãå‡ºã—å¤±æ•—: " + err);
    console.error(err);
  } finally {
    if (tempWrapper && tempWrapper.parentNode) {
      originalParent.insertBefore(paperElement, originalNext);
      tempWrapper.remove();
    }
    document.body.style.overflow = originalBodyOverflow;
    document.documentElement.style.overflow = originalHtmlOverflow;
    document.body.classList.remove('preview-mode');
    canvasTransform.style.transform = originalTransform;
    paperElement.style.left = originalLeft;
    paperElement.style.top = originalTop;
    gridLayer.style.display = gridPrevDisplay;
    gridLayer.style.opacity = gridWasVisible ? 1 : 0;
    renderGroups();
  }
}


  // çµ‚äº†æ™‚ç¢ºèª (æœªä¿å­˜ã®å ´åˆ)
  window.onbeforeunload = function(e) {
      if (isDirty) { 
          e.preventDefault();
          e.returnValue = ''; 
      }
  };

  function setTool(tool) {
    currentTool = tool;
    document.querySelectorAll('.tool-btn').forEach(b => b.classList.remove('active'));
    document.getElementById('tool-' + tool).classList.add('active');
    
    if (tool === 'hand') {
        document.body.classList.add('tool-hand');
        viewport.style.cursor = 'grab';
    } else {
        document.body.classList.remove('tool-hand');
        viewport.style.cursor = 'crosshair';
    }
    deselectAll();
  }
  
  function switchPanel(panelId) {
    document.querySelectorAll('.panel-section').forEach(el => el.classList.remove('active'));
    const target = document.getElementById(panelId);
    if(target) target.classList.add('active');
  }
  
  function swapPaperWH() {
      const wInput = document.getElementById('paper-w-mm');
      const hInput = document.getElementById('paper-h-mm');
      const temp = wInput.value;
      wInput.value = hInput.value;
      hInput.value = temp;
      document.getElementById('paper-preset').value = 'custom';
      updatePaperSize(false);
  }

  function updatePaperConfigInternal() {
    // ã‚¹ãƒ©ã‚¤ãƒ€ãƒ¼ã¨å…¥åŠ›ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‚’åŒæœŸ
    syncSliderValue('paper-dan-count', 'val-paper-dan-count');
    syncSliderValue('paper-rows-per-dan', 'val-paper-rows-per-dan');
    syncSliderValue('paper-chars-per-dan', 'val-paper-chars-per-dan');

    config.pageDanCount = parseInt(document.getElementById('paper-dan-count').value);
    config.rowsPerDan = parseInt(document.getElementById('paper-rows-per-dan').value);
    config.charsPerDan = parseInt(document.getElementById('paper-chars-per-dan').value);

    calculateLayout();
  }

function updatePaperSize(fromPreset = false) {
      const presetSelect = document.getElementById('paper-preset');
      const wInput = document.getElementById('paper-w-mm');
      const hInput = document.getElementById('paper-h-mm');
      const presets = {
          A3: { w: 297, h: 420 },
          A4: { w: 210, h: 297 },
          B4: { w: 257, h: 364 }
      };

      if (fromPreset) {
          const preset = presets[presetSelect.value];
          if (preset) {
              wInput.value = preset.w;
              hInput.value = preset.h;
          }
      } else {
          const currentW = parseFloat(wInput.value);
          const currentH = parseFloat(hInput.value);
          const matched = Object.entries(presets).find(([, size]) => size.w === currentW && size.h === currentH);
          presetSelect.value = matched ? matched[0] : 'custom';
      }

      config.paperW = parseFloat(wInput.value);
      config.paperH = parseFloat(hInput.value);
      
      root.style.setProperty('--paper-w', config.paperW + 'mm');
      root.style.setProperty('--paper-h', config.paperH + 'mm');
      
      calculateLayout();
  }

  function updateMargins() {
      config.marginTop = parseFloat(document.getElementById('margin-top').value);
      config.marginBottom = parseFloat(document.getElementById('margin-bottom').value);
      config.marginOuter = parseFloat(document.getElementById('margin-left').value); 
      config.marginInner = parseFloat(document.getElementById('margin-right').value); 

      calculateLayout();
  }

  // --- å¤–å‘¨æƒ…å ± (Marginalia) åˆ¶å¾¡ ---

  function selectMarginaliaTarget(target) {
      currentMarginaliaTarget = target;
      document.querySelectorAll('.btn-group-item').forEach(b => b.classList.remove('active'));
      document.getElementById('btn-marg-' + target).classList.add('active');

      const data = config.marginalia[target];
      document.getElementById('marg-text').value = data.text;
      document.getElementById('marg-font').value = data.font;
      document.getElementById('marg-size').value = data.size;
      document.getElementById('marg-weight').value = data.weight || 400;
      document.getElementById('marg-spacing').value = data.spacing;
      
      document.getElementById('val-marg-size').value = data.size;
      document.getElementById('val-marg-weight').value = data.weight || 400;
      document.getElementById('val-marg-spacing').value = data.spacing;
  }

  function updateMarginaliaConfig() {
      // ã‚¹ãƒ©ã‚¤ãƒ€ãƒ¼ã¨å…¥åŠ›ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‚’åŒæœŸ
      syncSliderValue('marg-size', 'val-marg-size');
      syncSliderValue('marg-weight', 'val-marg-weight');
      syncSliderValue('marg-spacing', 'val-marg-spacing');

      const target = currentMarginaliaTarget;
      const data = config.marginalia[target];

      data.text = document.getElementById('marg-text').value;
      data.font = document.getElementById('marg-font').value;
      data.size = parseFloat(document.getElementById('marg-size').value);
      data.weight = parseInt(document.getElementById('marg-weight').value) || 400;
      data.spacing = parseFloat(document.getElementById('marg-spacing').value);

      renderMarginalia();
      isDirty = true;
      saveToLocalStorage();
  }

  function renderMarginalia() {
      const leftEl = document.getElementById('info-left');
      const centerEl = document.getElementById('info-center');
      const rightEl = document.getElementById('info-right');
      
      const setStyleAndText = (el, data) => {
          el.innerText = data.text;
          const weight = data.weight || 400;
          el.style = `font-family: ${data.font}; font-size: ${data.size}pt; letter-spacing: ${data.spacing}px; font-weight: ${weight};`;
      };

      setStyleAndText(leftEl, config.marginalia.left);
      setStyleAndText(centerEl, config.marginalia.center);
      setStyleAndText(rightEl, config.marginalia.right);
  }

  function renderColorPatch() {
      const container = document.getElementById('color-patches-bottom');
      const colors = [
          '#000000', // K
          'none',    // Paper (Stroke only)
          '#ffff00', // Y
          '#ff00ff', // M
          '#00ffff', // C
          '#000000', // K
          '#000000'  // K
      ];
      
      const patchSize = 3.78; // 1mm in px approx
      const gap = 11.34; // 3mm in px approx
      
      let html = '';
      colors.forEach((c, i) => {
          let fill = c;
          let stroke = 'none';
          if (c === 'none') {
              fill = config.paperColor;
              stroke = 'none'; 
          }
          const r = patchSize / 2;
          const cx = r; const cy = r;
          const d = `M ${cx} 0 L ${patchSize} ${cy} L ${cx} ${patchSize} L 0 ${cy} Z`;
          
          html += `<svg width="${patchSize}" height="${patchSize}" class="color-patch-svg" style="margin: 0 ${gap/2}px;">
                    <path d="${d}" fill="${fill}" stroke="${stroke}" stroke-width="0.5" />
                   </svg>`;
      });
      container.innerHTML = html;
  }

  function calculateLayout() {
    const fontEl = document.getElementById('inp-font');
    if(fontEl && fontEl.value) {
        config.fontFamily = fontEl.value;
    }

    const effectiveH_px = (config.paperH - config.marginTop - config.marginBottom) * PX_PER_MM;
    const logicalH_px = effectiveH_px / SCALE_Y;
    const totalUnitsV = (config.charsPerDan * config.pageDanCount) + (config.charsGap * (config.pageDanCount - 1));
    let calculatedFontSize = logicalH_px / totalUnitsV;
    if (calculatedFontSize < 10) calculatedFontSize = 10;
    config.baseFontSize = calculatedFontSize;

    const effectiveW_px = (config.paperW - config.marginInner - config.marginOuter) * PX_PER_MM;
    let calcLineGap = 0;
    if (config.rowsPerDan > 1) {
      calcLineGap = (effectiveW_px - (config.baseFontSize * config.rowsPerDan)) / (config.rowsPerDan - 1);
    }
    if (calcLineGap < 0) calcLineGap = 0;
    config.lineGap = calcLineGap;

    updateSettingsInternal();
  }

  function updateSettingsInternal() {
    baseHDan = config.baseFontSize * config.charsPerDan;
    baseHGap = config.baseFontSize * config.charsGap;
    baseHUnit = baseHDan + baseHGap;
    
    physicalHDan = baseHDan * SCALE_Y;
    physicalHGap = baseHGap * SCALE_Y;
    physicalHUnit = baseHUnit * SCALE_Y;
    
    linePitch = config.baseFontSize + config.lineGap;

    root.style.setProperty('--base-font-size', config.baseFontSize + 'px');
    root.style.setProperty('--line-gap', config.lineGap + 'px');
    root.style.setProperty('--h-gap', baseHGap + 'px'); 
    
    root.style.setProperty('--m-top', config.marginTop + 'mm');
    root.style.setProperty('--m-bottom', config.marginBottom + 'mm');
    root.style.setProperty('--m-inner', config.marginInner + 'mm');
    root.style.setProperty('--m-outer', config.marginOuter + 'mm');
    root.style.setProperty('--font-family', config.fontFamily);
    root.style.setProperty('--font-weight', config.fontWeight);
    
    updateVisuals();
    renderLayoutLines(); 
    renderPaperGrid();       
    renderGroups();
    renderMarginalia();
    renderColorPatch();
    saveToLocalStorage();
  }

  async function updateColors() {
    // ã‚¹ãƒ©ã‚¤ãƒ€ãƒ¼ã¨å…¥åŠ›ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‚’åŒæœŸ
    syncSliderValue('inp-divider-width', 'val-divider-width');
    syncSliderValue('inp-border-width', 'val-border-width');

    config.gridColor = document.getElementById('inp-grid-color').value;
    config.paperColor = document.getElementById('inp-paper-color').value;
    config.textColor = document.getElementById('inp-text-color').value;

    config.borderWidth = parseFloat(document.getElementById('inp-border-width').value);
    config.dividerWidth = parseFloat(document.getElementById('inp-divider-width').value);

    document.querySelector('.paper').style.backgroundColor = config.paperColor;
    root.style.setProperty('--text-color', config.textColor);
    root.style.setProperty('--paper-color', config.paperColor);
    root.style.setProperty('--border-width', config.borderWidth + 'px');
    root.style.setProperty('--divider-width', config.dividerWidth + 'px');
    updatePatternColor();
    
    // ã‚¤ãƒ³ã‚¯è‰²ç”»åƒã¯è‰²å¤‰æ›´ã«åˆã‚ã›ã¦å†ç”Ÿæˆã™ã‚‹ï¼ˆå…¨ã¦å®Œäº†å¾Œã«å†æç”»ï¼‰
    const inkTasks = [];
    groups.forEach(g => {
        if (g.type === 'image' && g.colorMode === 'ink') {
            g.imageInkSrc = null;
            inkTasks.push(convertImageToInk(g, false));
        }
    });
    await Promise.all(inkTasks);
    
    renderPaperGrid(); renderGroups(); renderColorPatch();
    isDirty = true;
    saveToLocalStorage();
  }

  function updateVisuals() {
    // ã‚¹ãƒ©ã‚¤ãƒ€ãƒ¼ã¨å…¥åŠ›ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‚’åŒæœŸ
    syncSliderValue('inp-glyph-scale', 'val-glyph-scale');
    if (document.getElementById('inp-font-weight')) {
        syncSliderValue('inp-font-weight', 'val-font-weight');
    }

    config.glyphScale = parseFloat(document.getElementById('inp-glyph-scale').value);
    if (document.getElementById('inp-font-weight')) {
        config.fontWeight = parseInt(document.getElementById('inp-font-weight').value) || 400;
        root.style.setProperty('--font-weight', config.fontWeight);
    }
    root.style.setProperty('--glyph-scale', config.glyphScale);
    root.style.setProperty('--nudge-x', config.nudgeX + 'px');
    root.style.setProperty('--nudge-y', config.nudgeY + 'px');
    renderGroups();
    isDirty = true;
    saveToLocalStorage();
  }
  
  function updateHeadlineAttr() {
    if (!selectedId) return;
    const g = groups.find(i => i.id === selectedId);
    if (!g || g.type !== 'headline') return;

    // ã‚¹ãƒ©ã‚¤ãƒ€ãƒ¼ã¨å…¥åŠ›ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‚’åŒæœŸ
    syncSliderValue('hl-pad-long', 'val-hl-pad-long');
    syncSliderValue('hl-pad-short', 'val-hl-pad-short');

    g.fontFamily = document.getElementById('hl-font').value;
    g.fontWeight = document.getElementById('hl-weight').value;
    g.isInverted = document.getElementById('hl-inverted').checked;
    g.padLong = parseInt(document.getElementById('hl-pad-long').value);
    g.padShort = parseInt(document.getElementById('hl-pad-short').value);

    renderGroups();
    isDirty = true;
    saveToLocalStorage();
  }

  function updateVlineAttr() {
    if (!selectedId) return;
    const g = groups.find(i => i.id === selectedId);
    if (!g || g.type !== 'vline') return;

    // ã‚¹ãƒ©ã‚¤ãƒ€ãƒ¼ã¨å…¥åŠ›ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‚’åŒæœŸ
    syncSliderValue('vl-width', 'val-vl-width');

    g.lineWidth = parseInt(document.getElementById('vl-width').value);

    renderGroups();
    isDirty = true;
    saveToLocalStorage();
  }

  function updateArticleAttr() {
      if (!selectedId) return;
      const g = groups.find(i => i.id === selectedId);
      if (!g || g.type !== 'article') return;
      g.freeLayout = document.getElementById('art-free-layout').checked;

      if (g.freeLayout && !g.h) {
          g.h = (g.danCount * physicalHDan) + ((g.danCount - 1) * physicalHGap);
      }

      // ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚’ã‚¯ãƒªã‚¢ï¼ˆãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆãƒ¢ãƒ¼ãƒ‰ãŒå¤‰ã‚ã£ãŸãŸã‚ï¼‰
      delete g._capacityCache;
      delete g._capacityCacheKey;

      // ãƒ†ã‚­ã‚¹ãƒˆã‚’å†è¨ˆç®—ã—ã¦æ–‡å­—æ•°ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ã‚’æ›´æ–°
      reflowText();
      renderGroups();
      updateOverflowStatus(g);

      isDirty = true;
      saveToLocalStorage();
  }

  function updateHeaderAttr() {
      if (!selectedId) return;
      const g = groups.find(i => i.id === selectedId);
      if (!g || g.type !== 'header') return;

      // ã‚¹ãƒ©ã‚¤ãƒ€ãƒ¼ã¨å…¥åŠ›ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‚’åŒæœŸ
      syncSliderValue('hdr-border-out', 'val-hdr-border-out');
      syncSliderValue('hdr-border-in', 'val-hdr-border-in');
      syncSliderValue('hdr-text-stroke', 'val-hdr-text-stroke');
      syncSliderValue('hdr-pad-v', 'val-hdr-pad-v');
      syncSliderValue('hdr-pad-h', 'val-hdr-pad-h');

      g.text = document.getElementById('hdr-title').value;
      g.fontFamily = document.getElementById('hdr-font').value;
      g.isTitleInverted = document.getElementById('hdr-text-inverted').checked;
      g.titleStrokeWidth = parseFloat(document.getElementById('hdr-text-stroke').value);

      g.titlePadV = parseInt(document.getElementById('hdr-pad-v').value);
      g.titlePadH = parseInt(document.getElementById('hdr-pad-h').value);

      g.borderOut = parseInt(document.getElementById('hdr-border-out').value);
      g.borderIn = parseInt(document.getElementById('hdr-border-in').value);

      renderGroups();
      isDirty = true;
      saveToLocalStorage();
  }

  function updateCorrectionAttr() {
      if (!selectedId) return;
      const g = groups.find(i => i.id === selectedId);
      if (!g || g.type !== 'correction') return;

      // ã‚¹ãƒ©ã‚¤ãƒ€ãƒ¼ã¨å…¥åŠ›ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‚’åŒæœŸ
      syncSliderValue('corr-border-width', 'val-corr-border-width');

      g.fillMode = document.getElementById('corr-fill-mode').value;
      g.borderStyle = document.getElementById('corr-border-style').value;
      g.borderWidth = parseFloat(document.getElementById('corr-border-width').value);

      renderGroups();
      isDirty = true;
      saveToLocalStorage();
  }

  function setFreeTextAlign(al) {
      const mapId = {
          'top-left':'ft-align-tl', 'top':'ft-align-tc', 'top-right':'ft-align-tr',
          'left':'ft-align-ml', 'center':'ft-align-mc', 'right':'ft-align-mr',
          'bottom-left':'ft-align-bl', 'bottom':'ft-align-bc', 'bottom-right':'ft-align-br'
      };
      Object.values(mapId).forEach(id => {
          const btn = document.getElementById(id);
          if (btn) btn.classList.remove('active');
      });
      const targetId = mapId[al];
      if (targetId) {
          const btn = document.getElementById(targetId);
          if (btn) btn.classList.add('active');
      }
      if (!selectedId) return;
      const g = groups.find(i => i.id === selectedId);
      if (!g || g.type !== 'free-text') return;
      g.align = al;
      renderGroups();
      isDirty = true;
      saveToLocalStorage();
  }

function updateFreeTextAttr() {
    if (!selectedId) return;
    const g = groups.find(i => i.id === selectedId);
    if (!g || g.type !== 'free-text') return;

    g.fontFamily = document.getElementById('ft-font').value;
    g.fontWeight = parseInt(document.getElementById('ft-weight').value) || 400;
    g.fontSize = parseFloat(document.getElementById('ft-size').value) || 24;
    g.letterSpacing = parseFloat(document.getElementById('ft-letter').value) || 0;
    g.tcyEnabled = document.getElementById('ft-tcy').checked;
    g.style = document.getElementById('ft-style').value;
    g.strokeWidth = parseFloat(document.getElementById('ft-stroke-width').value) || 1.5;

    const writingSelect = document.getElementById('ft-writing');
    if (writingSelect) g.writingMode = writingSelect.value;

    renderGroups();
    isDirty = true;
    saveToLocalStorage();
}

  function nudgeHeaderTitle(dx, dy, reset = false) {
      if (!selectedId) return;
      const g = groups.find(i => i.id === selectedId);
      if (!g || g.type !== 'header') return;

      const mult = (event && event.shiftKey) ? 10 : 1;
      const ndx = dx * mult; const ndy = dy * mult;

      if (reset) { 
          g.titleNudgeX = 0; g.titleNudgeY = 0; 
      } else {
          g.titleNudgeX = (g.titleNudgeX || 0) + ndx;
          g.titleNudgeY = (g.titleNudgeY || 0) + ndy;
      }
      renderGroups();
      isDirty = true;
      saveToLocalStorage();
  }

  function updateImageAttr() {
    if (!selectedId) return;
    const g = groups.find(i => i.id === selectedId);
    if (!g || g.type !== 'image') return;
    g.captionPos = document.getElementById('img-cap-pos').value;
    g.fontFamily = document.getElementById('img-font').value;

    g.colorMode = document.getElementById('img-color-mode').value;
    const inkArea = document.getElementById('ink-adjust-area');
    if (g.colorMode === 'ink') {
        inkArea.style.display = 'block';

        // ã‚¹ãƒ©ã‚¤ãƒ€ãƒ¼ã¨å…¥åŠ›ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‚’åŒæœŸ
        syncSliderValue('img-contrast', 'val-img-contrast');
        syncSliderValue('img-brightness', 'val-img-brightness');

        g.inkContrast = parseFloat(document.getElementById('img-contrast').value);
        g.inkBrightness = parseFloat(document.getElementById('img-brightness').value);
        g.imageInkSrc = null;
        convertImageToInk(g);
    } else {
        inkArea.style.display = 'none';
    }
    
    renderGroups();
    isDirty = true;
    saveToLocalStorage();
  }

  async function handleImageUpload(input) {
      if (!selectedId || !input.files || !input.files[0]) return;
      const g = groups.find(i => i.id === selectedId);
      if (!g || g.type !== 'image') return;
      
      const file = input.files[0];
      const reader = new FileReader();
      reader.onload = async function(e) {
          saveHistory();
          // ç”»è³ªå„ªå…ˆã§è»½ããƒªã‚µã‚¤ã‚ºï¼ˆMAX_IMG_SIZE=2400, q=0.9ï¼‰ã€‚å…ƒç”»åƒãŒå°ã•ã‘ã‚Œã°ç„¡å¤‰æ›ã€‚
          const compressed = await compressImage(e.target.result, MAX_IMG_SIZE, 0.9);
          g.imageSrc = compressed;
          g.originalSrc = compressed; 
          g.imageInkSrc = null; // invalidate ink cache
          if (g.colorMode === 'ink') convertImageToInk(g);
          renderGroups();
      }
      reader.readAsDataURL(file);
      input.value = ''; 
  }

  // --- ãƒˆãƒªãƒŸãƒ³ã‚°æ©Ÿèƒ½ ---
  function openCropTool() {
      if (!selectedId) return;
      const g = groups.find(i => i.id === selectedId);
      if (!g || g.type !== 'image') return;
      
      if (!g.imageSrc && !g.originalSrc) {
          alert("ç”»åƒãŒé¸æŠã•ã‚Œã¦ã„ã¾ã›ã‚“ã€‚");
          return;
      }

      const src = g.originalSrc || g.imageSrc;
      cropImageObj = new Image();
      cropImageObj.onload = function() {
          const overlay = document.getElementById('crop-overlay');
          overlay.style.display = 'flex';
          
          const frameW = g.w; 
          let targetAspect = 1.0;
          const totalH = (g.h) ? g.h : ((g.danCount * physicalHDan) + ((g.danCount - 1) * physicalHGap));
          targetAspect = frameW / totalH;

          const maxViewW = Math.min(window.innerWidth * 0.8, 800);
          const maxViewH = Math.min(window.innerHeight * 0.6, 600);
          
          let canvasW = maxViewW;
          let canvasH = canvasW / targetAspect;
          
          if (canvasH > maxViewH) {
              canvasH = maxViewH;
              canvasW = canvasH * targetAspect;
          }

          cropCanvas.width = canvasW;
          cropCanvas.height = canvasH;
          document.getElementById('crop-canvas-container').style.width = canvasW + 'px';
          document.getElementById('crop-canvas-container').style.height = canvasH + 'px';

          const imgAspect = cropImageObj.width / cropImageObj.height;
          const frameAspect = canvasW / canvasH;

          let baseScale = 1.0;
          if (imgAspect > frameAspect) {
              baseScale = canvasH / cropImageObj.height;
          } else {
              baseScale = canvasW / cropImageObj.width;
          }
          
          cropState.minScale = baseScale;
          cropState.scale = baseScale;
          
          cropState.x = (canvasW - cropImageObj.width * baseScale) / 2;
          cropState.y = (canvasH - cropImageObj.height * baseScale) / 2;

          const slider = document.getElementById('crop-zoom');
          slider.min = baseScale;
          slider.max = baseScale * 5.0; 
          slider.value = baseScale;

          updateCropView();
      };
      cropImageObj.src = src;
  }

  function updateCropView() {
      if (!cropImageObj) return;
      
      const scaledW = cropImageObj.width * cropState.scale;
      const scaledH = cropImageObj.height * cropState.scale;
      
      if (cropState.x > 0) cropState.x = 0;
      if (cropState.y > 0) cropState.y = 0;
      if (cropState.x + scaledW < cropCanvas.width) cropState.x = cropCanvas.width - scaledW;
      if (cropState.y + scaledH < cropCanvas.height) cropState.y = cropCanvas.height - scaledH;

      cropCtx.clearRect(0, 0, cropCanvas.width, cropCanvas.height);
      cropCtx.drawImage(cropImageObj, cropState.x, cropState.y, scaledW, scaledH);
      document.getElementById('crop-zoom').value = cropState.scale;
  }

  cropCanvas.onmousedown = (e) => {
      isCropDragging = true;
      cropStartX = e.clientX;
      cropStartY = e.clientY;
      cropStartState = { x: cropState.x, y: cropState.y };
  };
  window.onmousemove = (e) => { 
      if (!isCropDragging || document.getElementById('crop-overlay').style.display === 'none') return;
      const dx = e.clientX - cropStartX;
      const dy = e.clientY - cropStartY;
      cropState.x = cropStartState.x + dx;
      cropState.y = cropStartState.y + dy;
      updateCropView();
  };
  window.onmouseup = () => { isCropDragging = false; };
  
  document.getElementById('crop-zoom').oninput = (e) => {
      const newScale = parseFloat(e.target.value);
      const oldScale = cropState.scale;
      const ratio = newScale / oldScale;
      const cx = cropCanvas.width / 2;
      const cy = cropCanvas.height / 2;
      cropState.x = cx - (cx - cropState.x) * ratio;
      cropState.y = cy - (cy - cropState.y) * ratio;
      cropState.scale = newScale;
      updateCropView();
  };

  async function applyCrop() {
      if (!selectedId || !cropImageObj) return;
      const g = groups.find(i => i.id === selectedId);
      const displayScale = cropState.scale; 
      const srcX = -cropState.x / displayScale;
      const srcY = -cropState.y / displayScale;
      const srcW = cropCanvas.width / displayScale;
      const srcH = cropCanvas.height / displayScale;
      
      const tempCvs = document.createElement('canvas');
      tempCvs.width = srcW;
      tempCvs.height = srcH;
      const tempCtx = tempCvs.getContext('2d');
      tempCtx.drawImage(cropImageObj, srcX, srcY, srcW, srcH, 0, 0, srcW, srcH);
      const croppedData = tempCvs.toDataURL('image/png');
      // ã‚¯ãƒ­ãƒƒãƒ—å¾Œã‚‚ç”»è³ªå¯„ã‚Šã§è»½ã‚ã®åœ§ç¸®ã®ã¿
      const compressed = await compressImage(croppedData, MAX_IMG_SIZE, 0.9);
      
      saveHistory();
      g.imageSrc = compressed;
      g.originalSrc = compressed; // æ¬¡å›ä»¥é™ã®ãƒˆãƒªãƒŸãƒ³ã‚°ãƒ™ãƒ¼ã‚¹ã‚‚æ›´æ–°
      g.imageInkSrc = null; // ã‚¤ãƒ³ã‚¯ãƒ¢ãƒ¼ãƒ‰ã®å ´åˆå†ç”Ÿæˆã•ã›ã‚‹
      if (g.colorMode === 'ink') {
          convertImageToInk(g, false);
      }
      closeCropEditor();
      renderGroups();
  }

  function closeCropEditor() {
      document.getElementById('crop-overlay').style.display = 'none';
      cropImageObj = null;
  }

  // --- å…±é€šæ“ä½œ ---
  function nudgeSelection(dx, dy, reset = false, evt = null) {
    const ev = evt || event;
    const mult = (ev && ev.shiftKey) ? 10 : 1;
    const ndx = dx * mult; const ndy = dy * mult;
    if (!selectedId) {
        if (reset) { config.nudgeX = 0; config.nudgeY = 0; }
        else { config.nudgeX += ndx; config.nudgeY += ndy; }
        updateVisuals();
    } else {
        const g = groups.find(i => i.id === selectedId);
        if (!g) return;
        if (g.type === 'free-text') {
            if (reset) return; // ä½ç½®ãƒªã‚»ãƒƒãƒˆã¯ãªã—
            g.x = (g.x || 0) + ndx;
            g.y = (g.y || 0) + ndy;
            renderGroups();
        } else {
            if (reset) { g.nudgeX = 0; g.nudgeY = 0; }
            else { g.nudgeX = (g.nudgeX || 0) + ndx; g.nudgeY = (g.nudgeY || 0) + ndy; }
            renderGroups();
        }
    }
    saveHistory();
  }

  function toggleGrid() {
    const show = document.getElementById('chk-grid').checked;
    gridLayer.style.opacity = show ? 1 : 0;
    if (show) { document.body.classList.remove('preview-mode'); }
    else { document.body.classList.add('preview-mode'); deselectAll(); }
  }


  function renderLayoutLines() {
    const effectiveH_px = (config.paperH - config.marginTop - config.marginBottom) * PX_PER_MM;
    const effectiveW_px = (config.paperW - config.marginInner - config.marginOuter) * PX_PER_MM;
    const mt = config.marginTop * PX_PER_MM;
    const ml = config.marginOuter * PX_PER_MM; 
    
    const off = 3 * PX_PER_MM;
    const borderX = ml - off; const borderY = mt - off;
    const borderW = effectiveW_px + (off * 2); const borderH = effectiveH_px + (off * 2);

    const borderLayer = document.getElementById('layout-border-layer');
    borderLayer.innerHTML = `<rect x="${borderX}" y="${borderY}" width="${borderW}" height="${borderH}" class="print-border" />`;

    let svgContent = '';
    for (let i = 0; i < config.pageDanCount - 1; i++) {
        let blockTop = mt + i * (physicalHDan + physicalHGap);
        let blockBottom = blockTop + physicalHDan;
        let lineY = blockBottom + (physicalHGap / 2);
        svgContent += `<line x1="${ml}" y1="${lineY}" x2="${ml + effectiveW_px}" y2="${lineY}" class="print-divider" />`;
    }
    document.getElementById('layout-lines-layer').innerHTML = svgContent;
  }

  function renderPaperGrid() {
    const w = linePitch; const h = baseHUnit; 
    const fW = config.baseFontSize; const fH = config.baseFontSize;
    const gColor = config.gridColor;
    const svg = `
      <svg width="${w}" height="${h}" xmlns="http://www.w3.org/2000/svg">
        <defs><pattern id="charPat" x="0" y="0" width="${w}" height="${fH}" patternUnits="userSpaceOnUse">
           <rect x="${config.lineGap}" y="0" width="${fW}" height="${fH}" fill="none" stroke="${gColor}" stroke-width="1" />
        </pattern></defs>
        <rect width="100%" height="100%" fill="url(#charPat)" />
      </svg>`;
    gridLayer.style.backgroundImage = `url("data:image/svg+xml;charset=utf-8,${encodeURIComponent(svg.trim())}")`;
    gridLayer.style.backgroundSize = `${w}px ${h}px`;
  }

  // --- Zoom / Pan ---
  function updateTransform() {
    canvasTransform.style.transform = `translate(${viewX}px, ${viewY}px) scale(${viewScale})`;

    // ç¸®å°æ™‚ã«ç·šãŒæ¶ˆãˆãªã„ã‚ˆã†ã€æ‹¡å¤§ç‡ã«å¿œã˜ã¦ç·šã®å¤ªã•ã‚’èª¿æ•´
    // ç”»é¢ä¸Šã§æœ€ä½0.5pxã‚’ä¿è¨¼ï¼ˆã“ã‚Œä»¥ä¸‹ã ã¨æ¶ˆãˆã‚‹ï¼‰
    const minVisibleWidth = Math.max(0.5, 0.5 / viewScale);
    root.style.setProperty('--border-width', minVisibleWidth + 'px');
    root.style.setProperty('--divider-width', minVisibleWidth + 'px');
  }
  function fitView() {
    viewScale = 0.6;
    viewX = (window.innerWidth - 80 - 320 - (config.paperW * PX_PER_MM * viewScale)) / 2 + 80;
    viewY = 50;
    updateTransform();
  }

  viewport.addEventListener('wheel', (e) => {
    e.preventDefault();
    const mx = e.clientX; const my = e.clientY;
    const wx = (mx - viewX) / viewScale; const wy = (my - viewY) / viewScale;
    const factor = 0.05;
    const delta = -Math.sign(e.deltaY) * factor;
    const newScale = Math.min(Math.max(viewScale * (1 + delta), 0.1), 5.0);
    viewX = mx - wx * newScale; viewY = my - wy * newScale;
    viewScale = newScale;
    updateTransform();
  }, { passive: false });

  viewport.addEventListener('contextmenu', e => {
    if (e.button === 1 || (e.button === 2 && e.pointerType === 'mouse')) e.preventDefault();
  });

  function screenToHanmen(sx, sy) {
    const rect = hanmen.getBoundingClientRect();
    return { x: (sx - rect.left) / viewScale, y: (sy - rect.top) / viewScale };
  }

  function startLinkFromPort(groupId, portEl) {
      const rect = portEl.getBoundingClientRect();
      const p = screenToHanmen(rect.left + rect.width/2, rect.top + rect.height/2);
      linkingSourceId = groupId;
      linkingSourceType = portEl.classList.contains('port-in') ? 'in' : 'out';
      linkingStartX = p.x; linkingStartY = p.y;
      opMode = 'link';
      tempLinkLine.setAttribute('d', `M ${linkingStartX} ${linkingStartY} L ${linkingStartX} ${linkingStartY}`);
      tempLinkLine.style.display = 'block';
      highlightCompatiblePorts(groupId);
      document.querySelectorAll('.port').forEach(el => el.classList.remove('port-hovered'));
  }

  function completeLinkTo(targetId, targetType) {
      if (!linkingSourceId || linkingSourceId === targetId) return;
      // æ¥ç¶šã¯ out -> in ã«é™å®šã€‚é–‹å§‹ãŒinã®å ´åˆã¯æ–¹å‘ã‚’åè»¢ã—ã¦è¨­å®šã™ã‚‹
      let fromId = linkingSourceId;
      let toId = targetId;
      if (linkingSourceType === targetType) return; // åŒç¨®ã¯æ¥ç¶šä¸å¯
      if (linkingSourceType === 'in' && targetType === 'out') {
          fromId = targetId; toId = linkingSourceId;
      }
      if (!checkLoop(fromId, toId)) {
          saveHistory();
          const src = groups.find(g => g.id === fromId);
          if (src) src.next = toId;
      } else {
          alert("ãƒ«ãƒ¼ãƒ—æ¥ç¶šã¯ã§ãã¾ã›ã‚“");
      }
      clearPortHighlights();
      tempLinkLine.style.display = 'none';
      linkingSourceId = null; linkingSourceType = null; opMode = 'none';
      renderGroups();
      selectObject(toId);
  }

  // --- Event Handlers ---
  function handlePointerDown(e) {
    if (activePointerId !== null && e.pointerId === undefined) return; // avoid synthetic mouse after pointer
    if (e.pointerId !== undefined) { activePointerId = e.pointerId; e.preventDefault(); }
    const key = e.pointerId || 'mouse';
    previousPointers.set(key, activePointers.get(key) || { x: e.clientX, y: e.clientY });
    activePointers.set(key, { x: e.clientX, y: e.clientY });
    if (activePointers.size === 2) {
        const pts = Array.from(activePointers.values());
        pinchStartDist = Math.hypot(pts[0].x - pts[1].x, pts[0].y - pts[1].y);
        pinchStartScale = viewScale;
        pinchCenter = { x: (pts[0].x + pts[1].x) / 2, y: (pts[0].y + pts[1].y) / 2 };
        pinchPrevCenter = { ...pinchCenter };
        pinchPrevDist = pinchStartDist;
        isPinching = true;
        opMode = 'none';
        return;
    }
    if (e.target.closest('.overlay-modal') || e.target.classList.contains('inline-editor')) return;
    
    // Reset tap detection to prevent interference
    lastTapTime = 0; 
    lastTapTargetId = null;

    isMouseDown = true; isDragging = false; 
    pointerMovedSinceDown = false;
    selectionMovedSinceDown = false;
    startX = e.clientX; startY = e.clientY;
    const hPos = screenToHanmen(e.clientX, e.clientY);

    if (e.button === 1 || (e.button === 2 && e.pointerType === 'mouse')) { // Middle or Right mouse button
        e.preventDefault();
        opMode = 'pan';
        startX = e.clientX;
        startY = e.clientY;
        startViewX = viewX;
        startViewY = viewY;
        viewport.style.cursor = 'grabbing';
        isMouseDown = true;
        return;
    }

    if (currentTool === 'hand') {
        opMode = 'pan'; startViewX = viewX; startViewY = viewY;
        viewport.style.cursor = 'grabbing';
        return; 
    }

    // Port/link logic should be checked first
    if (e.target.classList.contains('port-out')) {
        const groupEl = e.target.closest('.article-group');
        const g = groups.find(item => item.id === groupEl.dataset.id);
        if (g && g.next) { saveHistory(); g.next = null; renderGroups(); selectObject(g.id); return; }
        if (linkingSourceId) { completeLinkTo(groupEl.dataset.id, 'out'); return; }
        startLinkFromPort(groupEl.dataset.id, e.target);
        return;
    }
    if (e.target.classList.contains('port-in')) {
        const groupEl = e.target.closest('.article-group');
        const gid = groupEl.dataset.id;
        const parent = groups.find(p => p.type === 'article' && p.next === gid);
        if (parent) { saveHistory(); parent.next = null; renderGroups(); selectObject(parent.id); return; }
        if (linkingSourceId) { completeLinkTo(gid, 'in'); return; }
        startLinkFromPort(gid, e.target);
        return;
    }
    if (linkingSourceId) {
        clearPortHighlights();
        tempLinkLine.style.display = 'none';
        linkingSourceId = null; linkingSourceType = null; opMode = 'none';
    }

    if (e.target.classList.contains('resize-handle')) {
        opMode = 'resize';
        const groupEl = e.target.closest('.article-group');
        targetId = groupEl.dataset.id;
        const g = groups.find(item => item.id === targetId);

        // ã©ã®ã‚³ãƒ¼ãƒŠãƒ¼ã‹ã‚‰æ“ä½œã—ã¦ã„ã‚‹ã‹ã‚’è¨˜éŒ²
        resizeCorner = e.target.dataset.corner || 'br'; // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã¯å³ä¸‹

        // ã‚³ãƒ¼ãƒŠãƒ¼ã«å¿œã˜ã¦ã‚¢ãƒ³ã‚«ãƒ¼ãƒã‚¤ãƒ³ãƒˆã‚’è¨­å®š
        if (resizeCorner === 'tl') {
            anchorRight = g.x + g.w;
            anchorBottom = g.y + (g.h || ((g.danCount * physicalHDan) + ((g.danCount - 1) * physicalHGap)));
        } else if (resizeCorner === 'tr') {
            anchorLeft = g.x;
            anchorBottom = g.y + (g.h || ((g.danCount * physicalHDan) + ((g.danCount - 1) * physicalHGap)));
        } else if (resizeCorner === 'bl') {
            anchorRight = g.x + g.w;
            anchorTop = g.y;
        } else { // br
            anchorRight = g.x + g.w;
            anchorTop = g.y;
        }
        return;
    }

    const targetGroup = e.target.closest('.article-group');
    if (targetGroup) {
        opMode = 'move_wait'; // Set mode to wait for move, but don't select yet
        targetId = targetGroup.dataset.id;
        const tgt = groups.find(item => item.id === targetId);
        if (tgt) {
            dragStartX = hPos.x;
            dragStartY = hPos.y;
            initialElemX = tgt.x;
            initialElemY = tgt.y;
        }
        return;
    }

    if (['box','headline','correction','vline','image','header','free-text'].includes(currentTool)) {
        if (!document.body.classList.contains('preview-mode')) {
           opMode = 'draw_wait'; 
           if (currentTool === 'free-text') {
              anchorSnapX = hPos.x; anchorSnapY = hPos.y;
           } else {
              const snap = calculateSnapPoint(hPos.x, hPos.y, currentTool);
              anchorSnapX = snap.x; anchorSnapY = snap.y;
           }
        }
    }
}
  viewport.onmousedown = handlePointerDown;
  viewport.addEventListener('pointerdown', handlePointerDown);

  function handlePointerMove(e) {
    if (e.pointerId !== undefined) {
        const prev = activePointers.get(e.pointerId);
        if (prev) previousPointers.set(e.pointerId, { ...prev });
        activePointers.set(e.pointerId, { x: e.clientX, y: e.clientY });
    }
    if (isPinching) {
        if (activePointers.size >= 2) {
            const keys = Array.from(activePointers.keys()).slice(0, 2);
            const p0 = activePointers.get(keys[0]); const p1 = activePointers.get(keys[1]);
            const curCenter = { x: (p0.x + p1.x) / 2, y: (p0.y + p1.y) / 2 };
            const dist = Math.hypot(p0.x - p1.x, p0.y - p1.y);

            // 2æœ¬æŒ‡ã‚¹ãƒ¯ã‚¤ãƒ—ã§ç§»å‹•
            if (pinchPrevCenter) {
                viewX += (curCenter.x - pinchPrevCenter.x) * TOUCH_PAN_FACTOR;
                viewY += (curCenter.y - pinchPrevCenter.y) * TOUCH_PAN_FACTOR;
            }

            // ãƒ”ãƒ³ãƒã§æ‹¡å¤§ç¸®å°
            if (pinchPrevDist && dist > 0) {
                const mx = curCenter.x; const my = curCenter.y;
                const wx = (mx - viewX) / viewScale; const wy = (my - viewY) / viewScale;
                const scaleFactor = dist / pinchPrevDist;
                const newScale = Math.min(Math.max(viewScale * scaleFactor, 0.1), 5.0);
                viewX = mx - wx * newScale;
                viewY = my - wy * newScale;
                viewScale = newScale;
            }
            pinchPrevCenter = curCenter;
            pinchPrevDist = dist;
            updateTransform();
        }
        return;
    }
    
    // Middle-mouse pan logic
    if (opMode === 'pan' && isMouseDown) {
        viewX = startViewX + e.clientX - startX;
        viewY = startViewY + e.clientY - startY;
        updateTransform();
        return;
    }

    if (activePointerId !== null && e.pointerId !== undefined && activePointerId !== e.pointerId) return;
    if (activePointerId !== null && e.pointerId === undefined) return;
    if (!isMouseDown) return;
    if (!pointerMovedSinceDown && typeof startX === 'number') {
        const dx = e.clientX - startX;
        const dy = e.clientY - startY;
        if (dx !== 0 || dy !== 0) pointerMovedSinceDown = true;
    }
    if (!isDragging) {
        if (Math.sqrt(Math.pow(e.clientX - startX, 2) + Math.pow(e.clientY - startY, 2)) < DRAG_THRESHOLD) return;
        isDragging = true;
        if (opMode === 'move_wait') {
            // move_waitã‹ã‚‰moveã¸é·ç§»
            opMode = 'move';
            saveHistory();
        } else if (opMode !== 'pan' && opMode !== 'link' && opMode !== 'draw_wait') {
            saveHistory();
        }
    }
    const hPos = screenToHanmen(e.clientX, e.clientY);

    if (opMode === 'pan') {
        viewX = startViewX + e.clientX - startX; viewY = startViewY + e.clientY - startY;
        updateTransform();
    } else if (opMode === 'link') {
        const cp1x = linkingStartX; const cp1y = linkingStartY + 50;
        const cp2x = hPos.x; const cp2y = hPos.y - 50;
        const d = `M ${linkingStartX} ${linkingStartY} C ${cp1x} ${cp1y}, ${cp2x} ${cp2y}, ${hPos.x} ${hPos.y}`;
        tempLinkLine.setAttribute('d', d);
        clearPortHighlights();
        highlightCompatiblePorts(linkingSourceId);
        document.querySelectorAll('.port').forEach(el => el.classList.remove('port-hovered'));
        const target = document.elementFromPoint(e.clientX, e.clientY);
        if (target && target.classList.contains('port')) target.classList.add('port-hovered');

    } else if ((opMode === 'draw_wait' || opMode === 'draw') && isDragging) {
        if (opMode === 'draw_wait') {
            opMode = 'draw';
            ghost = document.createElement('div'); ghost.className = 'ghost';
            hanmen.appendChild(ghost);
        }
        
        if (currentTool === 'free-text') {
            const fx = Math.min(anchorSnapX, hPos.x);
            const fy = Math.min(anchorSnapY, hPos.y);
            const fw = Math.max(10, Math.abs(hPos.x - anchorSnapX));
            const fh = Math.max(10, Math.abs(hPos.y - anchorSnapY));
            ghost.style.left = Math.round(fx) + 'px'; ghost.style.top = Math.round(fy) + 'px';
            ghost.style.width = Math.round(fw) + 'px'; ghost.style.height = Math.round(fh) + 'px';
        } else {
            const fixedRight = anchorSnapX + config.baseFontSize;
            
            let unitH;
            if (currentTool === 'box') {
                unitH = isFreeCreationMode ? (config.baseFontSize * SCALE_Y) : physicalHUnit;
            } else {
                unitH = (currentTool === 'correction' || currentTool === 'image' || currentTool === 'headline' || currentTool === 'header' || currentTool === 'free-text') ? (config.baseFontSize * SCALE_Y) : physicalHUnit;
            }
            let finalY = anchorSnapY, snH = unitH;
            // ç¸¦æ–¹å‘: åŸç‚¹ã‚’ã¾ãŸã„ã ã‚‰1æ®µä¸Šã«ã‚·ãƒ•ãƒˆã—ãŸä¸Šã§é¸æŠ
            const goingUp = hPos.y < anchorSnapY;
            const charStep = config.baseFontSize * SCALE_Y;
            const upOffset = (currentTool === 'box') ? charStep : 0; // è¨˜äº‹ã¯1æ–‡å­—åˆ†ä¸Šã‚’åŸºæº–ã€ä»–ã¯ã‚ªãƒ•ã‚»ãƒƒãƒˆãªã—
            const baseY = goingUp ? (anchorSnapY - upOffset) : anchorSnapY;
            const distY = Math.abs(hPos.y - baseY);
            let dc = Math.ceil(distY / unitH); if (dc < 1) dc = 1;
            if (currentTool === 'box') {
                snH = isFreeCreationMode ? (dc * unitH) : ((dc * physicalHDan) + ((dc - 1) * physicalHGap));
            } else {
                snH = (currentTool === 'correction' || currentTool === 'image' || currentTool === 'headline' || currentTool === 'header' || currentTool === 'free-text') ? (dc * unitH) : ((dc * physicalHDan) + ((dc - 1) * physicalHGap));
            }
            // ä¸Šæ–¹å‘ã¯åŸºæº–ã‹ã‚‰é«˜ã•åˆ†ä¸Šã«ç½®ãï¼ˆè¨˜äº‹ã¯2æ–‡å­—åˆ†ä¸ŠãŒåŸºæº–ï¼‰ã€ä¸‹æ–¹å‘ã¯åŸºæº–ã«ä¸‹ã‚ã™
            finalY = goingUp ? (baseY - snH) : baseY;

            let finalX = anchorSnapX, snW = config.baseFontSize;
            // æ¨ªæ–¹å‘: åŸç‚¹ã‚’ã¾ãŸã„ã ã‚‰1åˆ—å³ã«ã‚·ãƒ•ãƒˆã—ãŸä¸Šã§é¸æŠ
            const baseXRaw = hPos.x > anchorSnapX ? (anchorSnapX + linePitch) : anchorSnapX; // å³æ–¹å‘ã¯1æ–‡å­—å³ã‚’åŸºæº–
            const anchorCol = getColIndex(baseXRaw);
            const currCol = getColIndex(hPos.x);
            const maxCol = Math.max(anchorCol, currCol);
            const minCol = Math.min(anchorCol, currCol);
            const cols = Math.max(1, maxCol - minCol + 1);
            snW = (cols * config.baseFontSize) + ((cols - 1) * config.lineGap);
            // å·¦ç«¯ã¯å·¦å´(å¤§ãã„åˆ—ç•ªå·)ã«åˆã‚ã›ã‚‹
            finalX = hanmen.clientWidth - (maxCol * linePitch) - config.baseFontSize;

            // å¼·åˆ¶ã‚¹ãƒŠãƒƒãƒ—ï¼ˆæ•´æ•°ãƒ”ã‚¯ã‚»ãƒ«ã«ä¸¸ã‚ã¦ãƒ–ãƒ¬ã‚’æŠ‘ãˆã‚‹ï¼‰
            finalX = Math.round(finalX);
            finalY = Math.round(finalY);
            snW = Math.round(snW);
            snH = Math.round(snH);

            ghost.style.left = finalX + 'px'; ghost.style.top = finalY + 'px';
            ghost.style.width = snW + 'px'; ghost.style.height = snH + 'px';
        }

    } else if (opMode === 'move') {
        selectionMovedSinceDown = true;
        let newX = initialElemX + hPos.x - dragStartX;
        let newY = initialElemY + hPos.y - dragStartY;
        const g = groups.find(item => item.id === targetId);
        
        const el = document.querySelector(`.article-group[data-id="${targetId}"]`);
        if (el) {
            if (g.type === 'free-text') {
                el.style.left = Math.round(newX) + 'px';
                el.style.top = Math.round(newY) + 'px';
            } else {
                const snap = calculateSnapPoint(newX, newY, g.type, g);
                el.style.left = snap.x + 'px'; el.style.top = snap.y + 'px';
            }
        }

    } else if (opMode === 'resize') {
        selectionMovedSinceDown = true;
        const g = groups.find(item => item.id === targetId);

        // è¨˜äº‹ã®ãƒ•ãƒªãƒ¼ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆå¯¾å¿œ
        let isFree = (g.type === 'article' && g.freeLayout);
        if (g.type === 'free-text') {
            // ã‚³ãƒ¼ãƒŠãƒ¼ã«å¿œã˜ã¦è¨ˆç®—
            let newW, newH, newX, newY;

            if (resizeCorner === 'tl') {
                newW = anchorRight - hPos.x;
                newH = anchorBottom - hPos.y;
                newX = hPos.x;
                newY = hPos.y;
            } else if (resizeCorner === 'tr') {
                newW = hPos.x - anchorLeft;
                newH = anchorBottom - hPos.y;
                newX = anchorLeft;
                newY = hPos.y;
            } else if (resizeCorner === 'bl') {
                newW = anchorRight - hPos.x;
                newH = hPos.y - anchorTop;
                newX = hPos.x;
                newY = anchorTop;
            } else { // br
                newW = hPos.x - (anchorRight - g.w);
                newH = hPos.y - anchorTop;
                newX = anchorRight - newW;
                newY = anchorTop;
            }

            newW = Math.max(10, newW);
            newH = Math.max(10, newH);

            const el = document.querySelector(`.article-group[data-id="${targetId}"]`);
            if (el) {
                el.style.left = Math.round(newX) + 'px';
                el.style.top = Math.round(newY) + 'px';
                el.style.width = Math.round(newW) + 'px';
                el.style.height = Math.round(newH) + 'px';
            }
        } else {
            let unitH = (g.type === 'correction' || g.type === 'image' || g.type === 'headline' || g.type === 'header' || g.type === 'free-text' || isFree) ? (config.baseFontSize * SCALE_Y) : physicalHUnit;

            let rawH, rawW, newX, newY;

            // ã‚³ãƒ¼ãƒŠãƒ¼ã«å¿œã˜ã¦è¨ˆç®—
            let snW, snH;

            if (resizeCorner === 'br' || resizeCorner === 'tr') {
                // å³ã‚³ãƒ¼ãƒŠãƒ¼: å·¦ç«¯å›ºå®šã€å³ã«ä¼¸ã°ã™
                let rawW = hPos.x - anchorLeft;
                if (rawW < config.baseFontSize) rawW = config.baseFontSize;
                let cols = Math.ceil(rawW / linePitch); if (cols < 1) cols = 1;
                snW = (cols * config.baseFontSize) + ((cols - 1) * config.lineGap);
            } else {
                // å·¦ã‚³ãƒ¼ãƒŠãƒ¼: å³ç«¯å›ºå®šã€å·¦ã«ä¼¸ã°ã™
                let rawW = anchorRight - hPos.x;
                if (rawW < config.baseFontSize) rawW = config.baseFontSize;
                let cols = Math.ceil(rawW / linePitch); if (cols < 1) cols = 1;
                snW = (cols * config.baseFontSize) + ((cols - 1) * config.lineGap);
            }

            if (resizeCorner === 'br' || resizeCorner === 'bl') {
                // ä¸‹ã‚³ãƒ¼ãƒŠãƒ¼: ä¸Šç«¯å›ºå®šã€ä¸‹ã«ä¼¸ã°ã™
                let rawH = hPos.y - anchorTop;
                if (rawH < unitH) rawH = unitH;
                let dc = Math.ceil(rawH / unitH); if (dc < 1) dc = 1;
                snH = (g.type === 'correction' || g.type === 'image' || g.type === 'headline' || g.type === 'header' || g.type === 'free-text' || isFree) ? (dc * unitH) : ((dc * physicalHDan) + ((dc - 1) * physicalHGap));
            } else {
                // ä¸Šã‚³ãƒ¼ãƒŠãƒ¼: ä¸‹ç«¯å›ºå®šã€ä¸Šã«ä¼¸ã°ã™
                let rawH = anchorBottom - hPos.y;
                if (rawH < unitH) rawH = unitH;
                let dc = Math.ceil(rawH / unitH); if (dc < 1) dc = 1;
                snH = (g.type === 'correction' || g.type === 'image' || g.type === 'headline' || g.type === 'header' || g.type === 'free-text' || isFree) ? (dc * unitH) : ((dc * physicalHDan) + ((dc - 1) * physicalHGap));
            }

            // ã‚³ãƒ¼ãƒŠãƒ¼ã«å¿œã˜ã¦Xä½ç½®ã¨Yä½ç½®ã‚’è¨ˆç®—
            if (resizeCorner === 'tl') {
                // å·¦ä¸Š: å³ä¸‹å›ºå®š
                newX = anchorRight - snW;
                newY = anchorBottom - snH;
            } else if (resizeCorner === 'tr') {
                // å³ä¸Š: å·¦ä¸‹å›ºå®š
                newX = anchorLeft;
                newY = anchorBottom - snH;
            } else if (resizeCorner === 'bl') {
                // å·¦ä¸‹: å³ä¸Šå›ºå®š
                newX = anchorRight - snW;
                newY = anchorTop;
            } else { // br
                // å³ä¸‹: å·¦ä¸Šå›ºå®š
                newX = anchorLeft;
                newY = anchorTop;
            }

            const el = document.querySelector(`.article-group[data-id="${targetId}"]`);
            if(el) {
                el.style.left = Math.round(newX) + 'px'; el.style.top = Math.round(newY) + 'px';
                el.style.width = Math.round(snW) + 'px'; el.style.height = Math.round(snH) + 'px';
            }
        }
    }
  }
  window.addEventListener('mousemove', handlePointerMove);
  window.addEventListener('pointermove', handlePointerMove);

  function handlePointerUp(e) {
    activePointers.delete(e.pointerId || 'mouse');
    previousPointers.delete(e.pointerId || 'mouse');
    if (isPinching && activePointers.size < 2) {
        isPinching = false; pinchStartDist = 0; pinchPrevCenter = null; pinchPrevDist = 0;
    }
    if (activePointerId !== null && e.pointerId !== undefined && activePointerId !== e.pointerId) return;
    if (!isMouseDown) return; isMouseDown = false; activePointerId = null;
    
    viewport.style.cursor = (['box','headline','correction','vline','image','header','free-text'].includes(currentTool)) ? 'crosshair' : 'default';
    if (currentTool === 'hand') viewport.style.cursor = 'grab';

    if (!isDragging) { // Click logic
        if (e.button === 0) { // Only trigger click logic on left-click
            const previouslySelectedId = selectedId;
            const targetGroup = e.target.closest('.article-group');
            const targetId = targetGroup ? targetGroup.dataset.id : null;
            const isUiElement = e.target.closest('.settings-panel') || e.target.closest('.toolbar-container') || e.target.closest('.menu-panel');

            if (e.target.closest('.resize-handle') || e.target.closest('.port')) {
                // Handle/port clicks are managed by other logic, do nothing here.
            } else if (targetId && targetId === previouslySelectedId && !document.body.classList.contains('preview-mode') && !pointerMovedSinceDown && !selectionMovedSinceDown) {
                const g = groups.find(item => item.id === targetId);
                if (g) {
                    // All editable types now use the overlay editor
                    if (['free-text', 'headline', 'header', 'article', 'image'].includes(g.type)) {
                        openOverlayEditor(g);
                    }
                }
            } else if (targetGroup) {
                selectObject(targetId);
            } else if (!isUiElement) {
                deselectAll();
            }
        }
    } else { // Drag-end logic
        if (opMode === 'link') {
            // Link mode is click-click, not handled on pointer up.
        } else if (opMode === 'draw' && ghost) {
            const x = parseFloat(ghost.style.left), y = parseFloat(ghost.style.top);
            const w = parseFloat(ghost.style.width), h = parseFloat(ghost.style.height);
            ghost.remove(); ghost = null;
            if (w > 0 && h > 0) { saveHistory(); addGroup(currentTool, x, y, w, h); }
        } else if (opMode === 'move' || opMode === 'resize') {
            const el = document.querySelector(`.article-group[data-id="${targetId}"]`);
            if (el) {
                const g = groups.find(item => item.id === targetId);
                if (opMode === 'move') { g.x = parseFloat(el.style.left); g.y = parseFloat(el.style.top); }
                else {
                    g.x = parseFloat(el.style.left);
                    g.y = parseFloat(el.style.top);
                    g.w = parseFloat(el.style.width);
                    let hVal = parseFloat(el.style.height);

                    if (g.type === 'correction' || g.type === 'image' || g.type === 'headline' || g.type === 'header' || g.type === 'free-text' || (g.type === 'article' && g.freeLayout)) {
                        g.h = hVal;
                    } else {
                        g.danCount = Math.max(1, Math.round((hVal + physicalHGap) / physicalHUnit));
                    }
                }
                renderGroups(); selectObject(targetId);
            }
        }
    }

    // Common cleanup
    isDragging = false; 
    opMode = 'none';
    isDirty = true;
    saveToLocalStorage();
}
  window.addEventListener('mouseup', handlePointerUp);
  window.addEventListener('pointerup', handlePointerUp);
  window.addEventListener('pointercancel', handlePointerUp);

  document.addEventListener('keydown', (e) => {
    // Ctrl+S ã§å³åº§ã«ä¿å­˜
    if ((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === 's') { 
        e.preventDefault(); 
        saveFile(true); // ä¿å­˜
        return;
    }
    if ((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === 'z') { e.preventDefault(); e.shiftKey ? redo() : undo(); }
    if ((e.key === 'Delete' || e.key === 'Backspace') && selectedId && document.activeElement.tagName !== 'TEXTAREA' && document.activeElement.tagName !== 'INPUT') {
        saveHistory(); deleteObject(selectedId); 
    }
  });

  function checkLoop(sourceId, targetId) {
    let curr = targetId, safety = 0;
    while(curr && safety < 1000) {
        if (curr === sourceId) return true;
        const next = groups.find(g => g.id === curr);
        if (!next || !next.next) break;
        curr = next.next; safety++;
    }
    return false;
  }
  function getColIndex(rawX) {
      let col = Math.floor((hanmen.clientWidth - rawX) / linePitch);
      return Math.max(0, col);
  }

  function calculateSnapPoint(rawX, rawY, type, obj = null) {
    let unitH;
    
    if (obj && obj.type === 'article') {
        unitH = obj.freeLayout ? (config.baseFontSize * SCALE_Y) : physicalHUnit;
    } else if (type === 'box') {
        unitH = isFreeCreationMode ? (config.baseFontSize * SCALE_Y) : physicalHUnit;
    } else if (type === 'free-text') {
        return { x: rawX, y: rawY };
    } else {
        unitH = (type === 'correction' || type === 'image' || type === 'headline' || type === 'header' || type === 'free-text') ? (config.baseFontSize * SCALE_Y) : physicalHUnit;
    }
    
    let snY = Math.round(rawY / unitH) * unitH; if (snY < 0) snY = 0;
    let col = getColIndex(rawX);
    let snX = hanmen.clientWidth - (col * linePitch) - config.baseFontSize;
    return { x: snX, y: snY };
  }

  function addGroup(type, x, y, w, h) {
    let danCount = Math.max(1, Math.round((h + physicalHGap) / physicalHUnit));
    const id = Date.now().toString();
    let newGroup = { id, x, y, w, danCount, nudgeX: 0, nudgeY: 0 };
    
    if (type === 'box') {
        newGroup.type = 'article'; newGroup.text = "è¨˜äº‹ã‚’å…¥åŠ›ã€‚"; newGroup.next = null; newGroup.displayText = [];
        newGroup.freeLayout = isFreeCreationMode; 
        if (newGroup.freeLayout) newGroup.h = h; 
    } else if (type === 'headline') {
        newGroup.type = 'headline'; newGroup.text = "è¦‹å‡ºã—";
        newGroup.h = h; 
        newGroup.fontFamily = '"Noto Sans JP", sans-serif'; newGroup.fontWeight = '700'; newGroup.isInverted = true;
        newGroup.padLong = 0; newGroup.padShort = 0;
    } else if (type === 'header') {
        newGroup.type = 'header'; newGroup.h = h; 
        newGroup.text = "ç©ºæƒ³æ–°è"; 
        newGroup.fontFamily = '"Shippori Mincho", serif'; 
        newGroup.fontWeight = 900;
        newGroup.pattern = "pat-lines"; 
        
        newGroup.isTitleInverted = false;
        // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã§è¢‹æ–‡å­—ã‚’å°‘ã—ã¤ã‘ã‚‹
        newGroup.titleStrokeWidth = 4;

        newGroup.titleNudgeX = 0; newGroup.titleNudgeY = 0;
        newGroup.titlePadV = 10; newGroup.titlePadH = 5;
        newGroup.borderOut = 4; newGroup.borderIn = 1;
    } else if (type === 'correction') {
        newGroup.type = 'correction'; newGroup.h = h; newGroup.text = "";
        newGroup.fillMode = 'paper';
        newGroup.borderStyle = 'none';
        newGroup.borderWidth = 2;
    } else if (type === 'free-text') {
        newGroup.type = 'free-text'; newGroup.h = h; newGroup.text = "è‡ªç”±ãƒ†ã‚­ã‚¹ãƒˆ";
        newGroup.fontFamily = config.fontFamily;
        newGroup.fontWeight = config.fontWeight;
        newGroup.fontSize = Math.round(config.baseFontSize);
        newGroup.letterSpacing = 0;
        newGroup.style = 'ink';
        newGroup.tcyEnabled = true;
        newGroup.writingMode = 'vertical';
        newGroup.align = 'center';
    } else if (type === 'vline') {
        newGroup.type = 'vline'; newGroup.lineWidth = 2; newGroup.text = "";
    } else if (type === 'image') {
        newGroup.type = 'image'; newGroup.h = h; newGroup.text = "ã‚­ãƒ£ãƒ—ã‚·ãƒ§ãƒ³"; 
        newGroup.captionPos = 'bottom'; newGroup.imageSrc = null; newGroup.originalSrc = null;
        newGroup.fontFamily = config.fontFamily;
        newGroup.colorMode = 'color';
        newGroup.inkContrast = 1.0;
        newGroup.inkBrightness = 0.0;
    }
    groups.push(newGroup); renderGroups(); selectObject(id);
    saveToLocalStorage();
  }
  function deleteSelectedBox() {
    if (!selectedId) return;
    const target = groups.find(g => g.id === selectedId);
    if (!target) return;
    if (!confirm("ã“ã®ãƒœãƒƒã‚¯ã‚¹ã‚’å‰Šé™¤ã—ã¾ã™ã‹ï¼Ÿ")) return;
    saveHistory();
    deleteObject(selectedId);
  }
  function deleteObject(id) {
    groups = groups.filter(g => g.id !== id);
    groups.forEach(g => { if(g.next === id) g.next = null; });
    renderGroups(); 
    deselectAll();
    saveToLocalStorage();
  }
  
  function selectObject(id) {
    deselectAll(); selectedId = id; 
    const el = document.querySelector(`.article-group[data-id="${id}"]`);
    if (el) el.classList.add('selected');
    const g = groups.find(item => item.id === id);
    if(g) {
       // æ¥ç¶šæ¸ˆã¿è¨˜äº‹ã¯ã‚¯ãƒªãƒƒã‚¯æ™‚ã«ãƒªãƒ³ã‚¯ã‚’è§£é™¤
       if (g.type === 'headline') {
         switchPanel('panel-headline');
         document.getElementById('hl-font').value = g.fontFamily;
         document.getElementById('hl-weight').value = g.fontWeight;
         document.getElementById('hl-inverted').checked = (g.isInverted !== false);
         document.getElementById('hl-pad-long').value = g.padLong || 0; document.getElementById('val-hl-pad-long').value = g.padLong || 0;
         document.getElementById('hl-pad-short').value = g.padShort || 0; document.getElementById('val-hl-pad-short').value = g.padShort || 0;
       } else if (g.type === 'header') {
         switchPanel('panel-header');
         document.getElementById('hdr-title').value = g.text;
         document.getElementById('hdr-font').value = g.fontFamily || config.fontFamily;

         document.getElementById('hdr-text-inverted').checked = (g.isTitleInverted === true);
         document.getElementById('hdr-text-stroke').value = g.titleStrokeWidth || 0;

         document.getElementById('hdr-pad-v').value = g.titlePadV || 10;
         document.getElementById('hdr-pad-h').value = g.titlePadH || 5;
         document.getElementById('hdr-border-out').value = g.borderOut !== undefined ? g.borderOut : 4;
         document.getElementById('hdr-border-in').value = g.borderIn !== undefined ? g.borderIn : 1;
       } else if (g.type === 'correction') { switchPanel('panel-correction');
         document.getElementById('corr-fill-mode').value = g.fillMode || 'paper';
         document.getElementById('corr-border-style').value = g.borderStyle || 'none';
         const bw = g.borderWidth ?? 2;
         document.getElementById('corr-border-width').value = bw;
         document.getElementById('val-corr-border-width').value = bw;
       } else if (g.type === 'vline') {
         switchPanel('panel-vline');
         document.getElementById('vl-width').value = g.lineWidth || 2; document.getElementById('val-vl-width').value = g.lineWidth || 2;
       } else if (g.type === 'image') {
         switchPanel('panel-image');
         document.getElementById('img-cap-pos').value = g.captionPos || 'bottom';
         document.getElementById('img-font').value = g.fontFamily || config.fontFamily;
         document.getElementById('img-color-mode').value = g.colorMode || 'color';
         
         const inkArea = document.getElementById('ink-adjust-area');
         if(g.colorMode === 'ink') {
             inkArea.style.display = 'block';
             document.getElementById('img-contrast').value = g.inkContrast ?? 1.0;
             document.getElementById('img-brightness').value = g.inkBrightness ?? 0.0;
             document.getElementById('val-img-contrast').value = (g.inkContrast ?? 1.0).toFixed(1);
             document.getElementById('val-img-brightness').value = (g.inkBrightness ?? 0.0).toFixed(1);
         } else {
             inkArea.style.display = 'none';
         }
         // ã‚µã‚¤ã‚ºè¡¨ç¤ºã‚’æ›´æ–°
         const sizeEl = document.getElementById('img-size-display');
         if (sizeEl) {
             const w = Math.round(g.w || 0);
             const h = Math.round(g.h || 0);
             sizeEl.textContent = `${w}px Ã— ${h}px`;
         }
       } else if (g.type === 'free-text') {
         switchPanel('panel-free-text');
         document.getElementById('ft-font').value = g.fontFamily || config.fontFamily;
         document.getElementById('ft-weight').value = g.fontWeight || 400;
         document.getElementById('val-ft-weight').value = g.fontWeight || 400;
         document.getElementById('ft-size').value = g.fontSize || 24;
         document.getElementById('val-ft-size').value = g.fontSize || 24;
         document.getElementById('ft-letter').value = g.letterSpacing ?? 0;
         document.getElementById('val-ft-letter').value = g.letterSpacing ?? 0;
         document.getElementById('ft-style').value = g.style || 'ink';
         document.getElementById('ft-stroke-width').value = g.strokeWidth ?? 1.5;
         document.getElementById('val-ft-stroke-width').value = g.strokeWidth ?? 1.5;
         document.getElementById('ft-tcy').checked = g.tcyEnabled !== false;
         const writingSelect = document.getElementById('ft-writing');
         if (writingSelect) writingSelect.value = g.writingMode || 'vertical';
         setFreeTextAlign(g.align || 'center');
       } else {
         switchPanel('panel-article'); 
         updateOverflowStatus(g);
         document.getElementById('art-free-layout').checked = (g.freeLayout === true);
       }
    }
  }
  function deselectAll() {
    selectedId = null;
    document.querySelectorAll('.selected').forEach(el => el.classList.remove('selected'));
    switchPanel('panel-global');
    closeInlineEditor();
  }
  
  function calculateSingleBoxCapacity(group) {
      // å˜ä¸€ã®ãƒœãƒƒã‚¯ã‚¹ã®å®¹é‡ã‚’è¨ˆç®—ï¼ˆã‚­ãƒ£ãƒƒã‚·ãƒ¥ä»˜ãï¼‰
      if (group.type !== 'article') return 0;

      // ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚­ãƒ¼ã‚’ç”Ÿæˆ
      const cacheKey = `${group.w}_${group.danCount}_${group.freeLayout}_${group.h}_${config.baseFontSize}_${config.lineGap}_${config.fontFamily}_${config.fontWeight}`;

      // ã‚­ãƒ£ãƒƒã‚·ãƒ¥ãŒã‚ã‚Œã°ãã‚Œã‚’è¿”ã™
      if (group._capacityCache !== undefined && group._capacityCacheKey === cacheKey) {
          return group._capacityCache;
      }

      let loopCount = (group.freeLayout) ? 1 : group.danCount;
      let currentSegHeight = (group.freeLayout && group.h) ? (group.h / SCALE_Y) : baseHDan;

      // ååˆ†ã«é•·ã„ãƒ†ã‚­ã‚¹ãƒˆã‚’ç”¨æ„ï¼ˆ1æ®µã§åã¾ã‚‹æœ€å¤§æ–‡å­—æ•°ã‚’æ¨å®šï¼‰
      const estimatedMax = 1000;

      measureBox.style.fontSize = config.baseFontSize + 'px';
      measureBox.style.lineHeight = (config.baseFontSize + config.lineGap) + 'px';
      measureBox.style.fontFamily = config.fontFamily;
      measureBox.style.fontWeight = config.fontWeight;

      let totalCapacity = 0;

      for (let i = 0; i < loopCount; i++) {
          const segWidth = group.w;
          const segHeight = currentSegHeight;

          measureBox.style.width = segWidth + 'px';
          measureBox.style.height = segHeight + 'px';

          // äºŒåˆ†æ¢ç´¢ã§åã¾ã‚‹æœ€å¤§æ–‡å­—æ•°ã‚’æ¢ã™
          let left = 0;
          let right = estimatedMax;
          let maxFit = 0;

          const tolerance = Math.max(config.baseFontSize * 0.6, config.lineGap * 0.5);

          while (left <= right) {
              const mid = Math.floor((left + right) / 2);
              measureBox.innerHTML = 'ã‚'.repeat(mid);

              const overW = measureBox.scrollWidth - measureBox.clientWidth;
              const overH = measureBox.scrollHeight - measureBox.clientHeight;

              if (overW <= tolerance && overH <= tolerance) {
                  maxFit = mid;
                  left = mid + 1;
              } else {
                  right = mid - 1;
              }
          }

          totalCapacity += maxFit;
      }

      measureBox.innerHTML = '';

      // ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã«ä¿å­˜
      group._capacityCache = totalCapacity;
      group._capacityCacheKey = cacheKey;

      return totalCapacity;
  }

  function calculateMaxCapacity(rootGroup) {
      // ãƒã‚§ãƒ¼ãƒ³å…¨ä½“ã®å®¹é‡ã‚’è¨ˆç®—
      if (rootGroup.type !== 'article') return 0;

      let totalCapacity = 0;
      let currentGroup = rootGroup;

      // ãƒã‚§ãƒ¼ãƒ³ã‚’ãŸã©ã£ã¦å…¨ãƒœãƒƒã‚¯ã‚¹ã®å®¹é‡ã‚’åˆè¨ˆ
      while (currentGroup) {
          totalCapacity += calculateSingleBoxCapacity(currentGroup);
          currentGroup = currentGroup.next ? groups.find(g => g.id === currentGroup.next) : null;
      }

      return totalCapacity;
  }

  function updateOverflowStatus(group) {
      // ãƒã‚§ãƒ¼ãƒ³ã®ãƒ«ãƒ¼ãƒˆã‚’è¦‹ã¤ã‘ã‚‹
      let root = group;
      while (true) {
          const parent = groups.find(g => g.next === root.id);
          if (!parent) break;
          root = parent;
      }

      // å®Ÿéš›ã«æ¸¬å®šã—ã¦è¡¨ç¤º
      const totalInputChars = root.text.length;
      const maxCapacity = calculateMaxCapacity(root);

      if(root.overflowCount > 0) {
          overflowStatusText.innerHTML = `<span class="overflow-warning">å…¥ã£ãŸæ–‡å­—æ•°: ${totalInputChars} / å…¥åŠ›å¯èƒ½æ–‡å­—æ•°: ${maxCapacity} (ã‚ãµã‚Œ: ${root.overflowCount})</span>`;
      } else {
          overflowStatusText.innerHTML = `<span class="overflow-ok">å…¥ã£ãŸæ–‡å­—æ•°: ${totalInputChars} / å…¥åŠ›å¯èƒ½æ–‡å­—æ•°: ${maxCapacity}</span>`;
      }
  }

  function saveHistory() {
    undoStack.push({ groups: JSON.parse(JSON.stringify(groups)) });
    if (undoStack.length > HISTORY_LIMIT) undoStack.shift(); redoStack = [];
    isDirty = true;
    saveToLocalStorage();
  }
  function undo() {
    if (undoStack.length === 0) return;
    redoStack.push({ groups: JSON.parse(JSON.stringify(groups)) });
    groups = undoStack.pop().groups; renderGroups(); deselectAll();
    isDirty = true;
    saveToLocalStorage();
  }
  function redo() {
    if (redoStack.length === 0) return;
    undoStack.push({ groups: JSON.parse(JSON.stringify(groups)) });
    groups = redoStack.pop().groups; renderGroups(); deselectAll();
    isDirty = true;
    saveToLocalStorage();
  }

  // --- ã‚¨ãƒ‡ã‚£ã‚¿é–¢é€£ ---
  function findRootGroup(group) {
    if (group.type === 'headline' || group.type === 'image' || group.type === 'header' || group.type === 'free-text') return group;
    let curr = group, depth = 0;
    while(depth < 100) {
        const parent = groups.find(p => p.next === curr.id);
        if (!parent) return curr;
        curr = parent; depth++;
    }
    return curr;
  }

  function openEditorHandler(g) {
      if (document.body.classList.contains('preview-mode') || currentTool === 'hand') return;
      openOverlayEditor(g);
  }

  function openInlineEditor(group) {
    closeInlineEditor(); saveHistory();
    const el = document.querySelector(`.article-group[data-id="${group.id}"]`);
    if (!el) return;
    const editor = document.createElement('textarea'); editor.className = 'inline-editor';
    editor.value = group.text || '';
    editor.dataset.editingId = group.id;

    editor.style.left = group.x + 'px'; editor.style.top = group.y + 'px';
    editor.style.width = group.w + 'px';

    // è‡ªç”±æ–‡ãƒ†ã‚­ã‚¹ãƒˆã®å ´åˆã¯é«˜ã•ã‚‚ãã®ã¾ã¾ä½¿ç”¨
    if (group.type === 'free-text') {
      editor.style.height = group.h + 'px';
      editor.style.transform = `translate(${group.nudgeX || 0}px, ${group.nudgeY || 0}px)`;
    } else {
      const originalHeight = (el.offsetHeight / SCALE_Y) + 20;
      editor.style.height = originalHeight + 'px';
      editor.style.transform = `translate(${config.nudgeX}px, ${config.nudgeY}px) scaleY(${SCALE_Y})`;
    }

    editor.onblur = function() { closeInlineEditor(); };
    editor.onkeydown = (e) => { if (e.key === 'Escape') closeInlineEditor(); };
    editor.oninput = function() {
        // å…¥åŠ›å†…å®¹ãŒå¤‰ã‚ã£ãŸã‚‰å³åº§ã«å†è¨ˆç®—ãƒ»åæ˜ 
        group.text = editor.value;
        reflowText(); // ãƒ†ã‚­ã‚¹ãƒˆã‚’å†è¨ˆç®—
        updateOverflowStatus(group); // ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ã‚’å³åº§ã«æ›´æ–°

        // è¦–è¦šçš„ãªæ›´æ–°ï¼ˆã‚ãµã‚Œè¡¨ç¤ºãªã©ï¼‰ã®ãŸã‚ã«è©²å½“è¦ç´ ã®ã¿æ›´æ–°
        const el = document.querySelector(`.article-group[data-id="${group.id}"]`);
        if (el) {
            if (group.overflowCount > 0) {
                el.classList.add('has-overflow');
            } else {
                el.classList.remove('has-overflow');
            }
        }
    };
    hanmen.appendChild(editor); editor.focus();
  }

  function closeInlineEditor() {
    const existing = document.querySelector('.inline-editor');
    if (existing) {
        const id = existing.dataset.editingId;
        if (id) {
            const g = groups.find(i => i.id === id);
            if (g) {
                g.text = existing.value;
                renderGroups(); 
            }
        }
        existing.onblur = null; 
        if (existing.parentNode) existing.parentNode.removeChild(existing);
        saveToLocalStorage();
    }
  }

  function openOverlayEditor(group) {
    editingGroupId = group.id;
    const overlay = document.getElementById('editor-overlay');
    const ta = document.getElementById('editor-textarea');
    ta.value = group.text;

    // æ—¢å­˜ã®inputãƒªã‚¹ãƒŠãƒ¼ã‚’å‰Šé™¤ã—ã¦ã‹ã‚‰æ–°ã—ã„ã‚‚ã®ã‚’è¿½åŠ 
    ta.oninput = function() {
        const g = groups.find(i => i.id === editingGroupId);
        if (g) {
            g.text = ta.value;
            reflowText(); // ãƒ†ã‚­ã‚¹ãƒˆã‚’å†è¨ˆç®—
            updateOverflowStatus(g); // ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ã‚’å³åº§ã«æ›´æ–°

            // è¦–è¦šçš„ãªæ›´æ–°ï¼ˆã‚ãµã‚Œè¡¨ç¤ºãªã©ï¼‰ã®ãŸã‚ã«è©²å½“è¦ç´ ã®ã¿æ›´æ–°
            const el = document.querySelector(`.article-group[data-id="${g.id}"]`);
            if (el) {
                if (g.overflowCount > 0) {
                    el.classList.add('has-overflow');
                } else {
                    el.classList.remove('has-overflow');
                }
            }
        }
    };

    overlay.style.display = 'flex'; ta.focus();
  }
  function saveOverlayEditor() {
    if (editingGroupId) {
       saveHistory();
       const g = groups.find(i => i.id === editingGroupId);
       if (g) { 
           g.text = document.getElementById('editor-textarea').value; 
           renderGroups(); 
       }
    }
    closeOverlayEditor();
  }
  function closeOverlayEditor() { document.getElementById('editor-overlay').style.display = 'none'; editingGroupId = null; }

  // --- ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚° ---
  
  function hexToLuma(hex) {
      const c = hex.substring(1);
      const rgb = parseInt(c, 16);
      const r = (rgb >> 16) & 0xff;
      const g = (rgb >>  8) & 0xff;
      const b = (rgb >>  0) & 0xff;
      return 0.299 * r + 0.587 * g + 0.114 * b;
  }

  function generateFilter(id, paperColor, inkColor, contrast, brightness) {
      const lumaPaper = hexToLuma(paperColor);
      const lumaInk = hexToLuma(inkColor);
      const isReverse = lumaInk > lumaPaper; 
      const baseSlope = 1.8 * contrast;
      const baseIntercept = -0.1 - (brightness * 0.5); 
      let matrixValues = isReverse 
          ? `0 0 0 0 0  0 0 0 0 0  0 0 0 0 0  0.2126 0.7152 0.0722 0 0`
          : `0 0 0 0 0  0 0 0 0 0  0 0 0 0 0  -0.2126 -0.7152 -0.0722 0 1`;

      return `
      <svg><filter id="filter-${id}">
        <feColorMatrix type="matrix" values="${matrixValues}" result="alpha-map" />
        <feComponentTransfer in="alpha-map" result="contrast-alpha">
          <feFuncA type="linear" slope="${baseSlope}" intercept="${baseIntercept}" /> 
        </feComponentTransfer>
        <feFlood flood-color="${inkColor}" result="ink-color" />
        <feComposite in="ink-color" in2="contrast-alpha" operator="in" />
      </filter></svg>`;
  }

  function renderGroups() {
    document.querySelectorAll('.article-group').forEach(e => e.remove());
    linkLayer.innerHTML = '<path id="temp-link-line" d=""></path>';
    const container = document.getElementById('svg-filters-container');
    const svg = container.querySelector('svg');
    if (svg) {
        const filters = svg.querySelectorAll('filter');
        filters.forEach(f => f.remove());
    }
    
    reflowText();

    groups.forEach(g => {
      // ä»¥å‰ã¯æ›¸ãå‡ºã—æ™‚ã«flattenã—ã¦ã„ãŸãŒã€CSS scaleYã§æ‰å¹³ã«ã—ã¦ã„ã‚‹ã®ã§ã€
      // flattenã™ã‚‹ã¨ç¸¦ã«ä¼¸ã³ã¦ã—ã¾ã„æç”»é ˜åŸŸã‹ã‚‰ã¯ã¿å‡ºã™åŸå› ã¨ãªã‚‹ãŸã‚å»ƒæ­¢ã€‚
      // ç¾åœ¨ã¯å¸¸ã«è¦‹ãŸç›®é€šã‚Šã®scaleYã‚’ç¶­æŒã™ã‚‹ã€‚
      const flatten = false;
      const el = document.createElement('div');
      el.className = 'article-group type-' + g.type; el.dataset.id = g.id;
      el.style.left = g.x + 'px'; el.style.top = g.y + 'px'; el.style.width = g.w + 'px';
      
      let totalH;
      if (g.type === 'correction' || g.type === 'image' || g.type === 'headline' || g.type === 'header' || g.type === 'free-text' || (g.type === 'article' && g.freeLayout)) {
          totalH = g.h;
      } else {
          totalH = (g.danCount * physicalHDan) + ((g.danCount - 1) * physicalHGap);
      }
      
      el.style.height = totalH + 'px';
      if(selectedId === g.id) el.classList.add('selected');

      // è¦‹å‡ºã—ã¨é¡Œå­—ã«ã¯å·¦å³ã«ç´™è‰²ã®ã‚·ãƒ£ãƒ‰ã‚¦ã‚’è¿½åŠ 
      if (g.type === 'headline' || g.type === 'header') {
          el.style.boxShadow = `${-config.lineGap}px 0 0 0 ${config.paperColor}, ${config.lineGap}px 0 0 0 ${config.paperColor}`;
      }

      // ãƒªã‚µã‚¤ã‚ºãƒãƒ³ãƒ‰ãƒ«ã‚’å››éš…ã«é…ç½®
      const handleTL = document.createElement('div');
      handleTL.className = 'resize-handle resize-handle-tl';
      handleTL.dataset.corner = 'tl';
      el.appendChild(handleTL);

      const handleTR = document.createElement('div');
      handleTR.className = 'resize-handle resize-handle-tr';
      handleTR.dataset.corner = 'tr';
      el.appendChild(handleTR);

      const handleBL = document.createElement('div');
      handleBL.className = 'resize-handle resize-handle-bl';
      handleBL.dataset.corner = 'bl';
      el.appendChild(handleBL);

      const handleBR = document.createElement('div');
      handleBR.className = 'resize-handle resize-handle-br';
      handleBR.dataset.corner = 'br';
      el.appendChild(handleBR);

      const tr = `translate(${g.nudgeX || 0}px, ${g.nudgeY || 0}px)`;

      // ã‚³ãƒ³ãƒ†ãƒ³ãƒ„æç”»åˆ†å²
      if (g.type === 'headline') {
          const isVertical = (totalH > g.w);
          const isInverted = (g.isInverted === true);
          const padLong = g.padLong || 0; const padShort = g.padShort || 0;
          const availW = g.w - (isVertical ? (padShort * 2) : (padLong * 2));
          const availH = totalH - (isVertical ? (padLong * 2) : (padShort * 2));

          // SVGã§æç”»ï¼ˆãƒ“ãƒ¥ãƒ¼ãƒãƒ¼ãƒˆã¨ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°ã§å®Œå…¨ä¸€è‡´ï¼‰
          const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
          svg.setAttribute('width', g.w);
          svg.setAttribute('height', totalH);
          svg.style.position = 'absolute';
          svg.style.left = '0';
          svg.style.top = '0';
          svg.style.pointerEvents = 'none';
          svg.style.transform = tr;

          // èƒŒæ™¯
          const bgRect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
          bgRect.setAttribute('width', g.w);
          bgRect.setAttribute('height', totalH);
          bgRect.setAttribute('fill', isInverted ? config.textColor : config.paperColor);
          svg.appendChild(bgRect);

          // å·¦å³ã®ä½™ç™½èƒŒæ™¯ï¼ˆç´™ã®è‰²ã§å¡—ã‚Šã¤ã¶ã—ï¼‰
          const leftRect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
          leftRect.setAttribute('x', -config.lineGap);
          leftRect.setAttribute('y', 0);
          leftRect.setAttribute('width', config.lineGap);
          leftRect.setAttribute('height', totalH);
          leftRect.setAttribute('fill', config.paperColor);
          svg.appendChild(leftRect);

          const rightRect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
          rightRect.setAttribute('x', g.w);
          rightRect.setAttribute('y', 0);
          rightRect.setAttribute('width', config.lineGap);
          rightRect.setAttribute('height', totalH);
          rightRect.setAttribute('fill', config.paperColor);
          svg.appendChild(rightRect);

          if (availW > 0 && availH > 0) {
             const shortSide = isVertical ? availW : availH;
             const longSide = isVertical ? availH : availW;

             // æ¸¬å®šï¼ˆå¸¸ã«æ¨ªæ›¸ãã§æ¸¬å®šï¼‰
             let htmlText = g.text.replace(/([0-9]{1,2})/g, '<span class="tcy">$1</span>').replace(/\{\{(.*?)\}\}/g, '<span class="tcy">$1</span>');
             hlMeasureBox.innerHTML = htmlText;
             hlMeasureBox.style.fontFamily = g.fontFamily;
             hlMeasureBox.style.fontWeight = g.fontWeight;
             hlMeasureBox.style.fontSize = shortSide + 'px';
             hlMeasureBox.style.writingMode = 'horizontal-tb';
             hlMeasureBox.style.lineHeight = isVertical ? '1.0' : '0.9';
             window.getComputedStyle(hlMeasureBox).fontSize;
             const actualLen = hlMeasureBox.offsetWidth;
             let scaleFactor = (actualLen > 0) ? (longSide / actualLen) : 1.0;

             // foreignObjectã§HTMLã‚’åŸ‹ã‚è¾¼ã¿
             const fo = document.createElementNS('http://www.w3.org/2000/svg', 'foreignObject');
             fo.setAttribute('x', 0);
             fo.setAttribute('y', 0);
             fo.setAttribute('width', g.w);
             fo.setAttribute('height', totalH);

             const contentDiv = document.createElement('div');
             contentDiv.setAttribute('xmlns', 'http://www.w3.org/1999/xhtml');
             contentDiv.style.width = '100%';
             contentDiv.style.height = '100%';
             contentDiv.style.position = 'relative';

             const textSpan = document.createElement('span');
             textSpan.style.fontFamily = g.fontFamily;
             textSpan.style.fontWeight = g.fontWeight;
             textSpan.style.fontSize = shortSide + 'px';
             textSpan.style.color = isInverted ? config.paperColor : config.textColor;
             textSpan.style.writingMode = 'horizontal-tb';
             textSpan.style.whiteSpace = 'nowrap';
             textSpan.style.lineHeight = isVertical ? '1.0' : '0.9';
             textSpan.style.position = 'absolute';
             textSpan.style.left = '0';
             textSpan.style.top = '0';
             textSpan.style.transformOrigin = '0 0';

             // å®Œå…¨ä¸­å¤®æƒãˆï¼šãƒ‘ãƒ‡ã‚£ãƒ³ã‚°ã‚’è€ƒæ…®ã—ãŸåˆ©ç”¨å¯èƒ½é ˜åŸŸã®ä¸­å¿ƒã«ãƒ†ã‚­ã‚¹ãƒˆã®ä¸­å¿ƒã‚’é…ç½®
             if (isVertical) {
                 // ç¸¦æ›¸ãï¼šä¸€æ–‡å­—ãšã¤é…ç½®ï¼ˆç¸¦ä¸­æ¨ªå¯¾å¿œï¼‰
                 textSpan.style.display = 'inline-block';
                 textSpan.style.textAlign = 'center';

                 const availAreaCenterX = padShort + availW / 2;
                 const availAreaCenterY = padLong + availH / 2;

                 const textCenterX = shortSide / 2;
                 const textCenterY = actualLen / 2;
                 const scaledTextCenterY = textCenterY * scaleFactor;

                 const absoluteX = availAreaCenterX - textCenterX;
                 const absoluteY = availAreaCenterY - scaledTextCenterY;

                 textSpan.style.transform = `translate(${absoluteX}px, ${absoluteY}px) scale(1, ${scaleFactor})`;

                 // HTMLãƒ†ã‚­ã‚¹ãƒˆã‚’ãƒ‘ãƒ¼ã‚¹ã—ã¦ä¸€æ–‡å­—ãšã¤å‡¦ç†
                 const tempDiv = document.createElement('div');
                 tempDiv.innerHTML = htmlText;
                 const processNode = (node) => {
                     if (node.nodeType === Node.TEXT_NODE) {
                         const chars = node.textContent.split('');
                         chars.forEach(char => {
                             const charSpan = document.createElement('span');
                             charSpan.innerText = char;
                             charSpan.style.display = 'block';
                             charSpan.style.lineHeight = '1.0';
                             charSpan.style.height = shortSide + 'px';
                             textSpan.appendChild(charSpan);
                         });
                     } else if (node.classList && node.classList.contains('tcy')) {
                         // ç¸¦ä¸­æ¨ªè¦ç´ ï¼ˆæ•°å­—ãªã©ï¼‰
                         const tcyText = node.textContent;

                         // æ¸¬å®šã—ã¦åã¾ã‚‹ã‚µã‚¤ã‚ºã‚’è¨ˆç®—
                         hlMeasureBox.innerText = tcyText;
                         hlMeasureBox.style.fontSize = shortSide + 'px';
                         hlMeasureBox.style.writingMode = 'horizontal-tb';
                         hlMeasureBox.style.lineHeight = '1.0';
                         window.getComputedStyle(hlMeasureBox).fontSize;
                         const tcyWidth = hlMeasureBox.offsetWidth;
                         const tcyFontSize = tcyWidth > 0 ? (shortSide / tcyWidth) * shortSide : shortSide * 0.5;

                         const wrapperSpan = document.createElement('span');
                         wrapperSpan.style.display = 'block';
                         wrapperSpan.style.height = shortSide + 'px';
                         wrapperSpan.style.lineHeight = shortSide + 'px';
                         wrapperSpan.style.textAlign = 'center';

                         const chars = tcyText.split('');
                         chars.forEach(char => {
                             const charSpan = document.createElement('span');
                             charSpan.innerText = char;
                             charSpan.style.display = 'inline-block';
                             charSpan.style.fontFamily = g.fontFamily;
                             charSpan.style.fontWeight = g.fontWeight;
                             charSpan.style.fontSize = tcyFontSize + 'px';
                             charSpan.style.lineHeight = '1.0';
                             charSpan.style.verticalAlign = 'middle';
                             wrapperSpan.appendChild(charSpan);
                         });
                         textSpan.appendChild(wrapperSpan);
                     }
                 };
                 Array.from(tempDiv.childNodes).forEach(processNode);
             } else {
                 // æ¨ªæ›¸ãï¼šHTMLã‚’ãã®ã¾ã¾è¡¨ç¤º
                 textSpan.innerHTML = htmlText;

                 const availAreaCenterX = padLong + availW / 2;
                 const availAreaCenterY = padShort + availH / 2;

                 const textCenterX = actualLen / 2;
                 const textCenterY = shortSide / 2;
                 const scaledTextCenterX = textCenterX * scaleFactor;

                 const absoluteX = availAreaCenterX - scaledTextCenterX;
                 const absoluteY = availAreaCenterY - textCenterY;

                 textSpan.style.transform = `translate(${absoluteX}px, ${absoluteY}px) scale(${scaleFactor}, 1)`;
             }

             contentDiv.appendChild(textSpan);
             fo.appendChild(contentDiv);
             svg.appendChild(fo);
          }

          el.appendChild(svg);

      } else if (g.type === 'header') {
          const borderOut = g.borderOut !== undefined ? g.borderOut : 4;
          const borderIn = g.borderIn !== undefined ? g.borderIn : 1;
          const padV = g.titlePadV || 10;
          const padH = g.titlePadH || 5;
          const borderSpace = borderOut + 4 + borderIn;

          // SVGã§æç”»ï¼ˆãƒ“ãƒ¥ãƒ¼ãƒãƒ¼ãƒˆã¨ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°ã§å®Œå…¨ä¸€è‡´ï¼‰
          const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
          svg.setAttribute('width', g.w);
          svg.setAttribute('height', totalH);
          svg.style.position = 'absolute';
          svg.style.left = '0';
          svg.style.top = '0';
          svg.style.pointerEvents = 'none';
          svg.style.transform = tr;

          // å·¦ã®ä½™ç™½èƒŒæ™¯ï¼ˆç´™ã®è‰²ã§å¡—ã‚Šã¤ã¶ã—ï¼‰
          const leftRect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
          leftRect.setAttribute('x', -config.lineGap);
          leftRect.setAttribute('y', 0);
          leftRect.setAttribute('width', config.lineGap);
          leftRect.setAttribute('height', totalH);
          leftRect.setAttribute('fill', config.paperColor);
          svg.appendChild(leftRect);

          // å³ã®ä½™ç™½èƒŒæ™¯ï¼ˆç´™ã®è‰²ã§å¡—ã‚Šã¤ã¶ã—ï¼‰
          const rightRect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
          rightRect.setAttribute('x', g.w);
          rightRect.setAttribute('y', 0);
          rightRect.setAttribute('width', config.lineGap);
          rightRect.setAttribute('height', totalH);
          rightRect.setAttribute('fill', config.paperColor);
          svg.appendChild(rightRect);

          // foreignObjectã§é¡Œå­—ã®æ§‹é€ ã‚’åŸ‹ã‚è¾¼ã¿
          const fo = document.createElementNS('http://www.w3.org/2000/svg', 'foreignObject');
          fo.setAttribute('x', 0);
          fo.setAttribute('y', 0);
          fo.setAttribute('width', g.w);
          fo.setAttribute('height', totalH);

          const containerDiv = document.createElement('div');
          containerDiv.setAttribute('xmlns', 'http://www.w3.org/1999/xhtml');
          containerDiv.style.width = '100%';
          containerDiv.style.height = '100%';
          containerDiv.style.position = 'relative';

          // å¤–æ ï¼ˆçµ¶å¯¾é…ç½®ï¼‰
          const outerBox = document.createElement('div');
          outerBox.style.position = 'absolute';
          outerBox.style.left = '0';
          outerBox.style.top = '0';
          outerBox.style.width = g.w + 'px';
          outerBox.style.height = totalH + 'px';
          outerBox.style.border = `${borderOut}px solid ${config.textColor}`;
          outerBox.style.padding = '4px';
          outerBox.style.boxSizing = 'border-box';
          outerBox.style.backgroundColor = config.paperColor;
          outerBox.style.overflow = 'hidden';
          outerBox.style.borderRadius = '2px';

          // å†…æ ï¼ˆouterBoxã®å­è¦ç´ ã¨ã—ã¦ç›¸å¯¾é…ç½®ï¼‰
          const innerBox = document.createElement('div');
          innerBox.style.position = 'relative';
          innerBox.style.width = '100%';
          innerBox.style.height = '100%';
          innerBox.style.border = `${borderIn}px solid ${config.textColor}`;
          innerBox.style.overflow = 'hidden';
          innerBox.style.padding = `${padV}px ${padH}px`;
          innerBox.style.borderRadius = '1px';
          innerBox.style.boxSizing = 'border-box';

          // åœ°ç´‹ãƒ‘ã‚¿ãƒ¼ãƒ³
          const patternSvg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
          patternSvg.style.position = 'absolute';
          patternSvg.style.top = '0';
          patternSvg.style.left = '0';
          patternSvg.style.width = '100%';
          patternSvg.style.height = '100%';
          patternSvg.style.zIndex = '0';
          patternSvg.style.pointerEvents = 'none';
          const patId = `pat-lines-${g.id}`;
          patternSvg.innerHTML = `
            <defs>
              <pattern id="${patId}" x="0" y="0" width="10" height="4" patternUnits="userSpaceOnUse">
                <line x1="0" y1="2" x2="10" y2="2" stroke="${config.textColor}" stroke-width="0.5" stroke-linecap="round" />
              </pattern>
            </defs>
            <rect width="100%" height="100%" fill="url(#${patId})" />
          `;
          innerBox.appendChild(patternSvg);

          // åˆ©ç”¨å¯èƒ½ãªå¹…ã¨é«˜ã•ã‚’è¨ˆç®—
          const availW = Math.max(10, g.w - (borderSpace * 2) - (padH * 2));
          const availH = Math.max(10, totalH - (borderSpace * 2) - (padV * 2));
          const isVertical = availH > availW;

          // æ¸¬å®šï¼ˆå¸¸ã«æ¨ªæ›¸ãã§æ¸¬å®šï¼‰
          const shortSide = isVertical ? availW : availH;
          const longSide = isVertical ? availH : availW;
          const baseFontSize = shortSide;

          // æ•°å­—ã‚„{{}}ã‚’ç¸¦ä¸­æ¨ªã¨ã—ã¦å‡¦ç†
          let htmlText = g.text.replace(/([0-9]{1,2})/g, '<span class="tcy">$1</span>').replace(/\{\{(.*?)\}\}/g, '<span class="tcy">$1</span>');

          headerMeasureBox.innerHTML = htmlText;
          headerMeasureBox.style.fontFamily = g.fontFamily || config.fontFamily;
          headerMeasureBox.style.fontWeight = g.fontWeight || 900;
          headerMeasureBox.style.fontSize = baseFontSize + 'px';
          headerMeasureBox.style.writingMode = 'horizontal-tb';
          headerMeasureBox.style.lineHeight = '0.85';
          window.getComputedStyle(headerMeasureBox).fontSize;

          const measuredLong = headerMeasureBox.offsetWidth;
          let scale = measuredLong > 0 ? longSide / measuredLong : 1.0;

          // ãƒ†ã‚­ã‚¹ãƒˆ
          const isTitleInverted = (g.isTitleInverted === true);
          const strokeW = g.titleStrokeWidth || 0;
          const translateX = g.titleNudgeX || 0;
          const translateY = g.titleNudgeY || 0;

          const textSpan = document.createElement('span');
          textSpan.style.fontFamily = g.fontFamily || config.fontFamily;
          textSpan.style.fontWeight = g.fontWeight || 900;
          textSpan.style.fontSize = baseFontSize + 'px';
          textSpan.style.color = isTitleInverted ? config.paperColor : config.textColor;
          textSpan.style.writingMode = 'horizontal-tb';
          textSpan.style.lineHeight = '0.85';
          textSpan.style.whiteSpace = 'nowrap';
          textSpan.style.position = 'absolute';
          textSpan.style.left = '0';
          textSpan.style.top = '0';
          textSpan.style.transformOrigin = '0 0';
          textSpan.style.zIndex = '2';
          textSpan.style.background = 'transparent';

          if (strokeW > 0) {
              textSpan.style.webkitTextStrokeWidth = strokeW + 'px';
              textSpan.style.webkitTextStrokeColor = isTitleInverted ? config.textColor : config.paperColor;
              textSpan.style.paintOrder = 'stroke fill';
          }

          // å®Œå…¨ä¸­å¤®æƒãˆï¼šinnerBoxã®å®Ÿéš›ã®åˆ©ç”¨å¯èƒ½é ˜åŸŸã®ä¸­å¿ƒã«ãƒ†ã‚­ã‚¹ãƒˆã®ä¸­å¿ƒã‚’é…ç½®
          // innerBoxã®é–‹å§‹ä½ç½® = borderOut + 4px(outerBoxã®padding) + borderIn
          const innerBoxOffsetX = borderOut + 4 + borderIn + padH;
          const innerBoxOffsetY = borderOut + 4 + borderIn + padV;

          if (isVertical) {
              // ç¸¦æ›¸ãï¼šä¸€æ–‡å­—ãšã¤é…ç½®ï¼ˆç¸¦ä¸­æ¨ªå¯¾å¿œï¼‰
              textSpan.style.display = 'inline-block';
              textSpan.style.textAlign = 'center';
              textSpan.style.lineHeight = '1.0';

              const availAreaCenterX = innerBoxOffsetX + availW / 2;
              const availAreaCenterY = innerBoxOffsetY + availH / 2;

              const textCenterX = baseFontSize / 2;
              const textCenterY = measuredLong / 2;
              const scaledTextCenterY = textCenterY * scale;

              const absoluteX = availAreaCenterX - textCenterX + translateX;
              const absoluteY = availAreaCenterY - scaledTextCenterY + translateY;

              textSpan.style.transform = `translate(${absoluteX}px, ${absoluteY}px) scale(1, ${scale})`;

              // HTMLãƒ†ã‚­ã‚¹ãƒˆã‚’ãƒ‘ãƒ¼ã‚¹ã—ã¦ä¸€æ–‡å­—ãšã¤å‡¦ç†
              const tempDiv = document.createElement('div');
              tempDiv.innerHTML = htmlText;
              const processNode = (node) => {
                  if (node.nodeType === Node.TEXT_NODE) {
                      const chars = node.textContent.split('');
                      chars.forEach(char => {
                          const charSpan = document.createElement('span');
                          charSpan.innerText = char;
                          charSpan.style.display = 'block';
                          charSpan.style.lineHeight = '1.0';
                          charSpan.style.height = baseFontSize + 'px';
                          textSpan.appendChild(charSpan);
                      });
                  } else if (node.classList && node.classList.contains('tcy')) {
                      // ç¸¦ä¸­æ¨ªè¦ç´ ï¼ˆæ•°å­—ãªã©ï¼‰
                      const tcyText = node.textContent;

                      // æ¸¬å®šã—ã¦åã¾ã‚‹ã‚µã‚¤ã‚ºã‚’è¨ˆç®—
                      headerMeasureBox.innerText = tcyText;
                      headerMeasureBox.style.fontSize = baseFontSize + 'px';
                      headerMeasureBox.style.writingMode = 'horizontal-tb';
                      headerMeasureBox.style.lineHeight = '1.0';
                      window.getComputedStyle(headerMeasureBox).fontSize;
                      const tcyWidth = headerMeasureBox.offsetWidth;
                      const tcyFontSize = tcyWidth > 0 ? (baseFontSize / tcyWidth) * baseFontSize : baseFontSize * 0.5;

                      const wrapperSpan = document.createElement('span');
                      wrapperSpan.style.display = 'block';
                      wrapperSpan.style.height = baseFontSize + 'px';
                      wrapperSpan.style.lineHeight = baseFontSize + 'px';
                      wrapperSpan.style.textAlign = 'center';

                      const chars = tcyText.split('');
                      chars.forEach(char => {
                          const charSpan = document.createElement('span');
                          charSpan.innerText = char;
                          charSpan.style.display = 'inline-block';
                          charSpan.style.fontFamily = g.fontFamily || config.fontFamily;
                          charSpan.style.fontWeight = g.fontWeight || 900;
                          charSpan.style.fontSize = tcyFontSize + 'px';
                          charSpan.style.lineHeight = '1.0';
                          charSpan.style.verticalAlign = 'middle';
                          wrapperSpan.appendChild(charSpan);
                      });
                      textSpan.appendChild(wrapperSpan);
                  }
              };
              Array.from(tempDiv.childNodes).forEach(processNode);
          } else {
              // æ¨ªæ›¸ãï¼šHTMLã‚’ãã®ã¾ã¾è¡¨ç¤º
              textSpan.innerHTML = htmlText;

              const availAreaCenterX = innerBoxOffsetX + availW / 2;
              const availAreaCenterY = innerBoxOffsetY + availH / 2;

              const textCenterX = measuredLong / 2;
              const textCenterY = baseFontSize / 2;
              const scaledTextCenterX = textCenterX * scale;

              const absoluteX = availAreaCenterX - scaledTextCenterX + translateX;
              const absoluteY = availAreaCenterY - textCenterY + translateY;

              textSpan.style.transform = `translate(${absoluteX}px, ${absoluteY}px) scale(${scale}, 1)`;
          }

          outerBox.appendChild(innerBox);
          containerDiv.appendChild(outerBox);
          containerDiv.appendChild(textSpan);
          fo.appendChild(containerDiv);
          svg.appendChild(fo);
          el.appendChild(svg);

      } else if (g.type === 'correction') {
          const box = document.createElement('div'); box.className = 'correction-box';
          const inner = document.createElement('div'); inner.className = 'correction-inner';
          inner.style.position = 'relative';
          const fillCol = (g.fillMode === 'ink') ? config.textColor : config.paperColor;
          inner.style.backgroundColor = fillCol;
          inner.style.paddingLeft = config.lineGap + 'px';
          inner.style.paddingRight = config.lineGap + 'px';
          inner.style.boxSizing = 'border-box';
          inner.style.boxShadow = `calc(var(--line-gap)*-1) 0 0 0 ${config.paperColor}, var(--line-gap) 0 0 0 ${config.paperColor}`;
          const bStyle = g.borderStyle || 'none';
          const borderCol = (g.fillMode === 'ink') ? config.paperColor : config.textColor;
          const bWidth = g.borderWidth ?? 2;
          // æ ç·šæç”»: ç´™è‰²ã®æ™‚ã¯0è·é›¢ã€ã‚¤ãƒ³ã‚¯ã®æ™‚ã¯1mmå†…å´
          if (bStyle !== 'none' && bWidth > 0) {
              const frame = document.createElement('div');
              frame.style.position = 'absolute';
              frame.style.inset = (g.fillMode === 'paper') ? '0px' : `${PX_PER_MM}px`;
              frame.style.pointerEvents = 'none';
              frame.style.borderStyle = bStyle;
              frame.style.borderWidth = `${bWidth}px`;
              frame.style.borderColor = borderCol;
              frame.style.boxSizing = 'border-box';
              inner.appendChild(frame);
          }
          inner.style.transform = tr;
          box.appendChild(inner); el.appendChild(box);

      } else if (g.type === 'free-text') {
          el.style.zIndex = 80; // å¡—ã‚Šã¤ã¶ã—ã‚ˆã‚Šä¸Šã«è¡¨ç¤º
          const wrap = document.createElement('div'); wrap.className = 'free-text-wrapper';
          wrap.style.transform = `translate(${g.nudgeX || 0}px, ${g.nudgeY || 0}px)`;
          const alignMap = {
              'top-left': ['flex-start','flex-start','left'],
              'top': ['center','flex-start','center'],
              'top-right': ['flex-end','flex-start','right'],
              'left': ['flex-start','center','left'],
              'center': ['center','center','center'],
              'right': ['flex-end','center','right'],
              'bottom-left': ['flex-start','flex-end','left'],
              'bottom': ['center','flex-end','center'],
              'bottom-right': ['flex-end','flex-end','right']
          };
          const [jc, ai, ta] = alignMap[g.align || 'center'] || ['center','center','center'];
          wrap.style.justifyContent = jc;
          wrap.style.alignItems = ai;

          const content = document.createElement('div'); content.className = 'free-text-content';
          content.style.fontFamily = g.fontFamily || config.fontFamily;
          content.style.fontWeight = g.fontWeight || 400;
          content.style.fontSize = (g.fontSize || 24) + 'px';
          content.style.letterSpacing = (g.letterSpacing || 0) + 'px';
          const writingMode = g.writingMode || 'vertical';
          content.style.writingMode = writingMode === 'horizontal' ? 'horizontal-tb' : 'vertical-rl';
          content.style.lineHeight = 1.4;
          // ã‚¹ã‚¿ã‚¤ãƒ«åˆ‡æ›¿ï¼ˆã‚¤ãƒ³ã‚¯/ç´™è‰²/è¢‹æ–‡å­—/è¢‹ï¼‹å½±ï¼‰
          const inkCol = config.textColor;
          const paperCol = config.paperColor;
          content.style.webkitTextStrokeWidth = '0px';
          content.style.webkitTextStrokeColor = 'transparent';
          content.style.textShadow = 'none';
          content.style.paintOrder = 'normal';

          const styleMode = g.style || 'ink';
          const strokeWidth = g.strokeWidth ?? 1.5;
          const shadowX = g.shadowX ?? 2;
          const shadowY = g.shadowY ?? 2;

          if (styleMode === 'paper') {
              content.style.color = paperCol;
          } else if (styleMode === 'outline') {
              content.style.color = paperCol;
              content.style.webkitTextStrokeWidth = strokeWidth + 'px';
              content.style.webkitTextStrokeColor = inkCol;
              content.style.paintOrder = 'stroke fill';
              content.style.webkitTextStrokeLinejoin = 'round';
          } else { // ink
              content.style.color = inkCol;
          }
          if (writingMode === 'horizontal') content.style.textAlign = ta;
          else content.style.textAlign = '';

          const useTCY = (g.tcyEnabled !== undefined) ? g.tcyEnabled : (g.tcy ?? true);
          const formatFreeText = (text) => {
              let t = text || "";
              if (useTCY) {
                  t = t.replace(/([0-9]{1,2})/g, '<span class="tcy">$1</span>');
              }
              return t.replace(/\n/g, '<br>');
          };
          content.innerHTML = formatFreeText(g.text);
          wrap.appendChild(content);
          el.appendChild(wrap);

      } else if (g.type === 'vline') {
          const box = document.createElement('div'); box.className = 'vline-box';
          const innerBg = document.createElement('div'); 
          innerBg.style.width = '100%'; innerBg.style.height = '100%';
          innerBg.style.display = 'flex'; innerBg.style.justifyContent = 'center'; innerBg.style.alignItems = 'center';
          innerBg.style.backgroundColor = config.paperColor;
          innerBg.style.boxShadow = `calc(var(--line-gap)*-1) 0 0 0 ${config.paperColor}, var(--line-gap) 0 0 0 ${config.paperColor}`;
          const line = document.createElement('div'); line.className = 'vline-inner';
          line.style.width = (g.lineWidth || 2) + 'px'; line.style.backgroundColor = config.textColor;
          innerBg.appendChild(line); innerBg.style.transform = tr;
          box.appendChild(innerBg); el.appendChild(box);

      } else if (g.type === 'image') {
          const box = document.createElement('div'); box.className = 'image-box';
          
          box.style.overflow = 'visible';
          box.style.backgroundColor = config.paperColor;
          box.style.boxShadow = `-${config.lineGap}px 0 0 0 ${config.paperColor}, ${config.lineGap}px 0 0 0 ${config.paperColor}`;

          const pos = g.captionPos || 'bottom';
          if (pos === 'top') { box.style.flexDirection = 'column'; }
          else if (pos === 'bottom') { box.style.flexDirection = 'column'; }
          else if (pos === 'left') { box.style.flexDirection = 'row'; }
          else if (pos === 'right') { box.style.flexDirection = 'row'; }

      const imgContainer = document.createElement('div'); imgContainer.className = 'image-container';
      
      if (g.imageSrc) {
          const img = document.createElement('img');
          img.className = 'image-content';
          if (g.colorMode === 'ink') {
              img.src = g.imageInkSrc || g.imageSrc;
              if (!g.imageInkSrc) convertImageToInk(g);
          } else {
              img.src = g.imageSrc;
          }
          imgContainer.appendChild(img);
      } else {
              imgContainer.innerText = "No Image";
          }

          const caption = document.createElement('div'); caption.className = 'image-caption';
          caption.innerText = g.text;
          caption.style.fontFamily = g.fontFamily || config.fontFamily;
          
          if (pos === 'left' || pos === 'right') caption.classList.add('caption-v');
          else caption.classList.add('caption-h');

          if (pos === 'none') {
              box.appendChild(imgContainer);
          } else if (pos === 'top') {
              box.appendChild(caption); box.appendChild(imgContainer);
          } else if (pos === 'bottom') {
              box.appendChild(imgContainer); box.appendChild(caption);
          } else if (pos === 'left') {
              box.appendChild(caption); box.appendChild(imgContainer);
          } else if (pos === 'right') {
              box.appendChild(imgContainer); box.appendChild(caption);
          }
          
          const wrapper = document.createElement('div');
          wrapper.style.width = '100%'; wrapper.style.height = (flatten ? totalH : (totalH / SCALE_Y)) + 'px';
          if (!flatten) {
              wrapper.style.transformOrigin = 'top right';
              wrapper.style.transform = `scaleY(${SCALE_Y})`;
              box.style.transform = tr + ` scaleY(${1/SCALE_Y})`;
          } else {
              wrapper.style.transform = 'none';
              box.style.transform = tr;
          }
          
          wrapper.appendChild(box);
          el.appendChild(wrapper);

      } else { // Article
          if(g.overflowCount > 0) el.classList.add('has-overflow');
          
          if (g.freeLayout) {
              el.style.backgroundColor = config.paperColor;
              el.style.boxShadow = `-${config.lineGap}px 0 0 0 ${config.paperColor}, ${config.lineGap}px 0 0 0 ${config.paperColor}`;
          }

          const wrapper = document.createElement('div'); wrapper.className = 'article-transform-wrapper';
          wrapper.style.width = '100%';
          wrapper.style.height = flatten ? totalH + 'px' : (totalH / SCALE_Y) + 'px';
          if (flatten) {
              wrapper.style.transform = `translate(${g.nudgeX || 0}px, ${g.nudgeY || 0}px)`;
          } else {
              wrapper.style.transformOrigin = 'top right';
              wrapper.style.transform = `translate(${g.nudgeX || 0}px, ${g.nudgeY || 0}px) scaleY(${SCALE_Y})`;
          }
          el.appendChild(wrapper);

          let loopCount = (g.freeLayout) ? 1 : g.danCount;
          let segH = (g.freeLayout) ? (g.h / SCALE_Y) : baseHDan;
          if (flatten) segH = (g.freeLayout) ? g.h : physicalHDan;

          for (let i = 0; i < loopCount; i++) {
            if (i > 0) {
              const spacer = document.createElement('div'); spacer.className = 'spacer';
              spacer.style.height = flatten ? (g.freeLayout ? g.h : physicalHGap) + 'px' : '';
              wrapper.appendChild(spacer);
            }
            const seg = document.createElement('div'); seg.className = 'segment';
            seg.style.height = segH + 'px'; 
            seg.innerHTML = (g.displayText && g.displayText[i]) ? g.displayText[i] : "";
            wrapper.appendChild(seg);
          }
          const isConnected = groups.some(parent => parent.next === g.id);
          const inPort = document.createElement('div'); inPort.className = 'port port-in';
          if (isConnected) inPort.classList.add('connected');
          el.appendChild(inPort);
          const outPort = document.createElement('div'); outPort.className = 'port port-out';
          if (g.next) outPort.classList.add('linked'); el.appendChild(outPort);
          if (g.next) {
              const nextG = groups.find(grp => grp.id === g.next);
              if (nextG) drawLinkLine(g, nextG);
          }
      }
      
      hanmen.appendChild(el);
    });
  }

  function reflowText() {
    groups.forEach(g => { if (g.type === 'article') { g.displayText = []; g.overflowCount = 0; } });
    const roots = groups.filter(g => g.type === 'article' && !groups.some(other => other.next === g.id));
    
    roots.forEach(root => {
        let currentGroup = root; let formattedText = root.text;
        formattedText = formattedText.replace(/([0-9]+)/g, (match) => { return (match.length <= 2) ? "{{" + match + "}}" : match; });
        if (!formattedText.startsWith("\u3000")) formattedText = "\u3000" + formattedText;
        formattedText = formattedText.replace(/\n(?!\u3000)/g, "\n\u3000");
        let processedHTML = formattedText.replace(/\{\{(.*?)\}\}/g, '<span class="tcy">$1</span>').replace(/\n/g, '<br>');
        let remainingHTML = processedHTML;
        let chainGroups = []; 
        while (currentGroup) {
            chainGroups.push(currentGroup); if (remainingHTML.length === 0) break;
            
            // ãƒ•ãƒªãƒ¼ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆå¯¾å¿œ
            let loopCount = (currentGroup.freeLayout) ? 1 : currentGroup.danCount;
            const flattenLayout = false; // ç¸¦çµ„ã¿å´©ã‚Œé˜²æ­¢ã®ãŸã‚å¸¸ã«å¾“æ¥ã®é«˜ã•è¨ˆç®—ã‚’ä½¿ã†
            let currentSegHeight = (currentGroup.freeLayout && currentGroup.h) ? (currentGroup.h / SCALE_Y) : baseHDan;

            for (let i = 0; i < loopCount; i++) {
                if (remainingHTML.length === 0) break;
                const segWidth = currentGroup.w; const segHeight = currentSegHeight; 
                measureBox.style.width = segWidth + 'px'; measureBox.style.height = segHeight + 'px';
                measureBox.style.fontSize = config.baseFontSize + 'px';
                measureBox.style.lineHeight = (config.baseFontSize + config.lineGap) + 'px';
                measureBox.style.fontFamily = config.fontFamily;
                measureBox.style.fontWeight = config.fontWeight;
                measureBox.style.fontWeight = config.fontWeight;

                measureBox.innerHTML = remainingHTML;
                const tokens = remainingHTML.match(/(<[^>]+>|[^<])/g) || [];
                let fitCount = tokens.length;
                
                // Safariå¯¾ç­–: ã‚„ã‚„ç·©ã‚ã®è¨±å®¹ç¯„å›²ï¼ˆå³ã—ã™ãã‚‹ã¨1è¡Œæ¬ ã‘ã‚‹ãŸã‚ï¼‰
                const tolerance = Math.max(config.baseFontSize * 0.6, config.lineGap * 0.5);

                while (fitCount > 0) {
                    const tryHTML = tokens.slice(0, fitCount).join(''); measureBox.innerHTML = tryHTML;
                    const overW = measureBox.scrollWidth - measureBox.clientWidth;
                    const overH = measureBox.scrollHeight - measureBox.clientHeight;
                    if (overW <= tolerance && overH <= tolerance) {
                        currentGroup.displayText[i] = tryHTML; remainingHTML = tokens.slice(fitCount).join(''); break;
                    }
                    fitCount--;
                }
                if (fitCount === 0) remainingHTML = "";
            }
            currentGroup = currentGroup.next ? groups.find(g => g.id === currentGroup.next) : null;
        }
        if (remainingHTML.length > 0) {
            const tempDiv = document.createElement('div'); tempDiv.innerHTML = remainingHTML;
            const overflowLen = tempDiv.textContent.length;
            chainGroups.forEach(g => { g.overflowCount = overflowLen; });
        }
    });
  }

  function drawLinkLine(g1, g2) {
    const x1 = g1.x + (g1.w / 2); 
    const y1 = g1.y + ((g1.danCount * physicalHDan) + ((g1.danCount - 1) * physicalHGap)) + 5; 
    const x2 = g2.x + (g2.w / 2); const y2 = g2.y - 5; 
    const path = document.createElementNS("http://www.w3.org/2000/svg", "path");
    const d = `M ${x1} ${y1} C ${x1} ${y1+50}, ${x2} ${y2-50}, ${x2} ${y2}`;
    path.setAttribute("d", d); path.setAttribute("class", "link-line"); linkLayer.appendChild(path);
  }

  function registerServiceWorker() {
    if (!('serviceWorker' in navigator)) return;
    window.addEventListener('load', () => {
      navigator.serviceWorker.register('sw.js').catch((err) => console.warn('SW registration failed', err));
    });
  }

  init();
  registerServiceWorker();
</script>
</body>
</html>
